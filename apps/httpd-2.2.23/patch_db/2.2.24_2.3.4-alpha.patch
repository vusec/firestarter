diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/ap_config.h /tmp/patch.inc.get2.9J0UCU/include/ap_config.h
*** /tmp/patch.inc.get1.AvnxJA/include/ap_config.h	2013-04-28 19:22:12.347306069 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/ap_config.h	2013-04-28 19:22:13.463311601 +0200
***************
*** 238,250 ****
  #define AP_NONBLOCK_WHEN_MULTI_LISTEN 1
  #endif
  
! /* TODO - We need to put OS detection back to make all the following work */
  
! #if defined(SUNOS4) || defined(IRIX) || defined(NEXT) || defined(AUX3) \
!     || defined (UW) || defined(LYNXOS) || defined(TPF)
! /* These systems don't do well with any lingering close code; I don't know
!  * why -- manoj */
! #define NO_LINGCLOSE
  #endif
  
  /* If APR has OTHER_CHILD logic, use reliable piped logs. */
--- 238,253 ----
  #define AP_NONBLOCK_WHEN_MULTI_LISTEN 1
  #endif
  
! #if AP_ENABLE_DTRACE && HAVE_SYS_SDT_H
! #include <sys/sdt.h>
! #else
! #undef _DTRACE_VERSION
! #endif
  
! #ifdef _DTRACE_VERSION
! #include "apache_probes.h"
! #else
! #include "apache_noprobes.h"
  #endif
  
  /* If APR has OTHER_CHILD logic, use reliable piped logs. */
Only in /tmp/patch.inc.get2.9J0UCU/include: ap_expr.h
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/ap_listen.h /tmp/patch.inc.get2.9J0UCU/include/ap_listen.h
*** /tmp/patch.inc.get1.AvnxJA/include/ap_listen.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/ap_listen.h	2013-04-28 19:22:13.455311562 +0200
***************
*** 34,39 ****
--- 34,40 ----
  extern "C" {
  #endif
  
+ typedef struct ap_slave_t ap_slave_t;
  typedef struct ap_listen_rec ap_listen_rec;
  typedef apr_status_t (*accept_function)(void **csd, ap_listen_rec *lr, apr_pool_t *ptrans);
  
*************** struct ap_listen_rec {
*** 68,73 ****
--- 69,76 ----
       * The default protocol for this listening socket.
       */
      const char* protocol;
+ 
+     ap_slave_t *slave;
  };
  
  /**
*************** AP_DECLARE(int) ap_setup_listeners(serve
*** 93,98 ****
--- 96,106 ----
   */
  AP_DECLARE_NONSTD(void) ap_close_listeners(void);
  
+ /**
+  * FIXMEDOC
+  */
+ AP_DECLARE_NONSTD(int) ap_close_selected_listeners(ap_slave_t *);
+ 
  /* Although these functions are exported from libmain, they are not really
   * public functions.  These functions are actually called while parsing the
   * config file, when one of the LISTEN_COMMANDS directives is read.  These
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/ap_mmn.h /tmp/patch.inc.get2.9J0UCU/include/ap_mmn.h
*** /tmp/patch.inc.get1.AvnxJA/include/ap_mmn.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/ap_mmn.h	2013-04-28 19:22:13.455311562 +0200
***************
*** 40,185 ****
   */
  
  /*
!  * 20010224 (2.0.13-dev) MODULE_MAGIC_COOKIE reset to "AP20"
!  * 20010523 (2.0.19-dev) bump for scoreboard structure reordering
!  * 20010627 (2.0.19-dev) more API changes than I can count
!  * 20010726 (2.0.22-dev) more big API changes
!  * 20010808 (2.0.23-dev) dir d_is_absolute bit introduced, bucket changes, etc
!  * 20010825 (2.0.25-dev) removed d_is_absolute, introduced map_to_storage hook
!  * 20011002 (2.0.26-dev) removed 1.3-depreciated request_rec.content_language
!  * 20011127 (2.0.29-dev) bump for postconfig hook change, and removal of socket
!  *                       from connection record
!  * 20011212 (2.0.30-dev) bump for new used_path_info member of request_rec
!  * 20011218 (2.0.30-dev) bump for new sbh member of conn_rec, different 
!  *                       declarations for scoreboard, new parameter to
!  *                       create_connection hook
!  * 20020102 (2.0.30-dev) bump for changed type of limit_req_body in 
!  *                       core_dir_config
!  * 20020109 (2.0.31-dev) bump for changed shm and scoreboard declarations
!  * 20020111 (2.0.31-dev) bump for ETag fields added at end of cor_dir_config
!  * 20020114 (2.0.31-dev) mod_dav changed how it asks its provider to fulfill
!  *                       a GET request
!  * 20020118 (2.0.31-dev) Input filtering split of blocking and mode
!  * 20020127 (2.0.31-dev) bump for pre_mpm hook change
!  * 20020128 (2.0.31-dev) bump for pre_config hook change
!  * 20020218 (2.0.33-dev) bump for AddOutputFilterByType directive
!  * 20020220 (2.0.33-dev) bump for scoreboard.h structure change
!  * 20020302 (2.0.33-dev) bump for protocol_filter additions.
!  * 20020306 (2.0.34-dev) bump for filter type renames.
!  * 20020318 (2.0.34-dev) mod_dav's API for REPORT generation changed
!  * 20020319 (2.0.34-dev) M_INVALID changed, plus new M_* methods for RFC 3253
!  * 20020327 (2.0.35-dev) Add parameter to quick_handler hook
!  * 20020329 (2.0.35-dev) bump for addition of freelists to bucket API
!  * 20020329.1 (2.0.36) minor bump for new arg to opt fn ap_cgi_build_command
!  * 20020506 (2.0.37-dev) Removed r->boundary in request_rec.
!  * 20020529 (2.0.37-dev) Standardized the names of some apr_pool_*_set funcs
!  * 20020602 (2.0.37-dev) Bucket API change (metadata buckets)
!  * 20020612 (2.0.38-dev) Changed server_rec->[keep_alive_]timeout to apr time
!  * 20020625 (2.0.40-dev) Changed conn_rec->keepalive to an enumeration
!  * 20020628 (2.0.40-dev) Added filter_init to filter registration functions
!  * 20020903 (2.0.41-dev) APR's error constants changed
!  * 20020903.1 (2.1.0-dev) allow_encoded_slashes added to core_dir_config
   * 20020903.2 (2.0.46-dev) add ap_escape_logitem
!  * 20030213.1 (2.1.0-dev) changed log_writer optional fn's to return previous
!  *                        handler
!  * 20030821 (2.1.0-dev) bumped mod_include's entire API
!  * 20030821.1 (2.1.0-dev) added XHTML doctypes
!  * 20030821.2 (2.1.0-dev) added ap_escape_errorlog_item
!  * 20030821.3 (2.1.0-dev) added ap_get_server_revision / ap_version_t
!  * 20040425 (2.1.0-dev) removed ap_add_named_module API
!  *                      changed ap_add_module, ap_add_loaded_module,
!  *                      ap_setup_prelinked_modules, ap_process_resource_config
!  * 20040425.1 (2.1.0-dev) Added ap_module_symbol_t and ap_prelinked_module_symbols
!  * 20050101.0 (2.1.2-dev) Axed misnamed http_method for http_scheme (which it was!)
!  * 20050127.0 (2.1.3-dev) renamed regex_t->ap_regex_t, regmatch_t->ap_regmatch_t,
!  *                        REG_*->AP_REG_*, removed reg* in place of ap_reg*;
!  *                        added ap_regex.h
!  * 20050217.0 (2.1.3-dev) Axed find_child_by_pid, mpm_*_completion_context (winnt mpm)
!  *                        symbols from the public sector, and decorated real_exit_code
!  *                        with ap_ in the win32 os.h.
!  * 20050305.0 (2.1.4-dev) added pid and generation fields to worker_score
!  * 20050305.1 (2.1.5-dev) added ap_vhost_iterate_given_conn.
!  * 20050305.2 (2.1.5-dev) added AP_INIT_TAKE_ARGV.
!  * 20050305.3 (2.1.5-dev) added Protocol Framework.
!  * 20050701.0 (2.1.7-dev) Bump MODULE_MAGIC_COOKIE to "AP21"!
!  * 20050701.1 (2.1.7-dev) trace_enable member added to core server_config
!  * 20050708.0 (2.1.7-dev) Bump MODULE_MAGIC_COOKIE to "AP22"!
!  * 20050708.1 (2.1.7-dev) add proxy request_status hook (minor)
!  * 20051006.0 (2.1.8-dev) NET_TIME filter eliminated
!  * 20051115.0 (2.1.10-dev/2.2.0) add use_canonical_phys_port to core_dir_config
!  * 20051115.1 (2.2.1)  flush_packets and flush_wait members added to
   *                         proxy_server (minor)
!  * 20051115.2 (2.2.2)  added inreslist member to proxy_conn_rec (minor)
!  * 20051115.3 (2.2.3)  Added server_scheme member to server_rec (minor)
!  * 20051115.4 (2.2.4)  Added ap_get_server_banner() and
!  *                         ap_get_server_description() (minor)
!  * 20051115.5 (2.2.5)  Added ap_mpm_safe_kill() (minor)
!  * 20051115.6 (2.2.7)  Added retry_set to proxy_worker (minor)
!  * 20051115.7 (2.2.7)  Added conn_rec::clogging_input_filters (minor)
!  * 20051115.8 (2.2.7)  Added flags to proxy_alias (minor)
!  * 20051115.9 (2.2.7)  Add ap_send_interim_response API
!  * 20051115.10 (2.2.7)  Added ap_mod_status_reqtail (minor)
!  * 20051115.11 (2.2.7)  Add *ftp_directory_charset to proxy_dir_conf
!  * 20051115.12 (2.2.8)  Add optional function ap_logio_add_bytes_in() to mog_logio
!  * 20051115.13 (2.2.9)  Add disablereuse and disablereuse_set
!  *                      to proxy_worker struct (minor)
!  * 20051115.14 (2.2.9)  Add ap_proxy_ssl_connection_cleanup and
!  *                      add *scpool, *r and need_flush to proxy_conn_rec
!  *                      structure
!  * 20051115.15 (2.2.9)  Add interpolate_env to proxy_dir_conf and
!  *                      introduce proxy_req_conf.
!  * 20051115.16 (2.2.9)  Add conn_timeout and conn_timeout_set to
!  *                      proxy_worker struct.
!  * 20051115.17 (2.2.10) Add scolonsep to proxy_balancer
!  * 20051115.18 (2.2.10) Add chroot support to unixd_config
!  * 20051115.19 (2.2.11) Added ap_timeout_parameter_parse to util.c / httpd.h
!  * 20051115.20 (2.2.11) Add ap_proxy_buckets_lifetime_transform to mod_proxy.h
!  * 20051115.21 (2.2.11) Export mod_rewrite.h in the public API
!  * 20051115.22 (2.2.12) Add ap_escape_html2 API, with additional option
!  * 20051115.23 (2.2.12) Add ap_open_piped_log_ex API, with cmdtype option,
!  *                      and conditional cmdtype member of piped_log struct
!  * 20051115.24 (2.2.15) Add forward member to proxy_conn_rec
!  * 20051115.25 (2.2.17) Add errstatuses member to proxy_balancer
!  * 20051115.26 (2.2.18) Add ap_cache_check_allowed()
!  * 20051115.27 (2.2.18) BROKEN ABI fixed in 2.2.19: 
!  *                      ap_unescape_url_keep2f() signature change
!  *                      Add core_dir_config.decode_encoded_slashes.
!  * 20051115.28 (2.2.19) Restore ap_unescape_url_keep2f(char *url) signature 
!  *                      altered in 2.2.18.  Add ap_unescape_url_keep2f_ex().
!  * 20051115.29 (2.2.21) add max_ranges to core_dir_config
!  * 20051115.30 (2.2.21) add ap_set_accept_ranges()
!  * 20051115.31 (2.2.23) Add forcerecovery to proxy_balancer_shared struct
   */
  
! #define MODULE_MAGIC_COOKIE 0x41503232UL /* "AP22" */
  
  #ifndef MODULE_MAGIC_NUMBER_MAJOR
! #define MODULE_MAGIC_NUMBER_MAJOR 20051115
  #endif
! #define MODULE_MAGIC_NUMBER_MINOR 31                    /* 0...n */
  
  /**
   * Determine if the server's current MODULE_MAGIC_NUMBER is at least a
   * specified value.
!  * <pre>
   * Useful for testing for features.
   * For example, suppose you wish to use the apr_table_overlap
   *    function.  You can do this:
!  * 
   * #if AP_MODULE_MAGIC_AT_LEAST(19980812,2)
   *     ... use apr_table_overlap()
   * #else
   *     ... alternative code which doesn't use apr_table_overlap()
   * #endif
!  * </pre>
   * @param major The major module magic number
   * @param minor The minor module magic number
!  * @deffunc AP_MODULE_MAGIC_AT_LEAST(int major, int minor)
   */
! #define AP_MODULE_MAGIC_AT_LEAST(major,minor)		\
!     ((major) < MODULE_MAGIC_NUMBER_MAJOR 		\
! 	|| ((major) == MODULE_MAGIC_NUMBER_MAJOR 	\
! 	    && (minor) <= MODULE_MAGIC_NUMBER_MINOR))
  
  /** @deprecated present for backwards compatibility */
  #define MODULE_MAGIC_NUMBER MODULE_MAGIC_NUMBER_MAJOR
--- 40,245 ----
   */
  
  /*
!  * 20010224   (2.0.13-dev) MODULE_MAGIC_COOKIE reset to "AP20"
!  * 20010523   (2.0.19-dev) bump for scoreboard structure reordering
!  * 20010627   (2.0.19-dev) more API changes than I can count
!  * 20010726   (2.0.22-dev) more big API changes
!  * 20010808   (2.0.23-dev) dir d_is_absolute bit introduced, bucket changes, etc
!  * 20010825   (2.0.25-dev) removed d_is_absolute, introduced map_to_storage hook
!  * 20011002   (2.0.26-dev) removed 1.3-deprecated request_rec.content_language
!  * 20011127   (2.0.29-dev) bump for postconfig hook change, and removal of
!  *                         socket from connection record
!  * 20011212   (2.0.30-dev) bump for new used_path_info member of request_rec
!  * 20011218   (2.0.30-dev) bump for new sbh member of conn_rec, different
!  *                         declarations for scoreboard, new parameter to
!  *                         create_connection hook
!  * 20020102   (2.0.30-dev) bump for changed type of limit_req_body in
!  *                         core_dir_config
!  * 20020109   (2.0.31-dev) bump for changed shm and scoreboard declarations
!  * 20020111   (2.0.31-dev) bump for ETag fields added at end of cor_dir_config
!  * 20020114   (2.0.31-dev) mod_dav changed how it asks its provider to fulfill
!  *                         a GET request
!  * 20020118   (2.0.31-dev) Input filtering split of blocking and mode
!  * 20020127   (2.0.31-dev) bump for pre_mpm hook change
!  * 20020128   (2.0.31-dev) bump for pre_config hook change
!  * 20020218   (2.0.33-dev) bump for AddOutputFilterByType directive
!  * 20020220   (2.0.33-dev) bump for scoreboard.h structure change
!  * 20020302   (2.0.33-dev) bump for protocol_filter additions.
!  * 20020306   (2.0.34-dev) bump for filter type renames.
!  * 20020318   (2.0.34-dev) mod_dav's API for REPORT generation changed
!  * 20020319   (2.0.34-dev) M_INVALID changed, plus new M_* methods for RFC 3253
!  * 20020327   (2.0.35-dev) Add parameter to quick_handler hook
!  * 20020329   (2.0.35-dev) bump for addition of freelists to bucket API
!  * 20020329.1 (2.0.36)     minor bump for new arg to opt fn ap_cgi_build_command
!  * 20020506   (2.0.37-dev) Removed r->boundary in request_rec.
!  * 20020529   (2.0.37-dev) Standardized the names of some apr_pool_*_set funcs
!  * 20020602   (2.0.37-dev) Bucket API change (metadata buckets)
!  * 20020612   (2.0.38-dev) Changed server_rec->[keep_alive_]timeout to apr time
!  * 20020625   (2.0.40-dev) Changed conn_rec->keepalive to an enumeration
!  * 20020628   (2.0.40-dev) Added filter_init to filter registration functions
!  * 20020903   (2.0.41-dev) APR's error constants changed
!  * 20020903.1 (2.1.0-dev)  allow_encoded_slashes added to core_dir_config
   * 20020903.2 (2.0.46-dev) add ap_escape_logitem
!  * 20030213.1 (2.1.0-dev)  changed log_writer optional fn's to return previous
!  *                         handler
!  * 20030821   (2.1.0-dev)  bumped mod_include's entire API
!  * 20030821.1 (2.1.0-dev)  added XHTML doctypes
!  * 20030821.2 (2.1.0-dev)  added ap_escape_errorlog_item
!  * 20030821.3 (2.1.0-dev)  added ap_get_server_revision / ap_version_t
!  * 20040425   (2.1.0-dev)  removed ap_add_named_module API
!  *                         changed ap_add_module, ap_add_loaded_module,
!  *                         ap_setup_prelinked_modules,
!  *                         ap_process_resource_config
!  * 20040425.1 (2.1.0-dev)  Added ap_module_symbol_t and
!  *                         ap_prelinked_module_symbols
!  * 20050101.0 (2.1.2-dev)  Axed misnamed http_method for http_scheme
!  *                         (which it was!)
!  * 20050127.0 (2.1.3-dev)  renamed regex_t->ap_regex_t,
!  *                         regmatch_t->ap_regmatch_t, REG_*->AP_REG_*,
!  *                         removed reg* in place of ap_reg*; added ap_regex.h
!  * 20050217.0 (2.1.3-dev)  Axed find_child_by_pid, mpm_*_completion_context
!  *                         (winnt mpm) symbols from the public sector, and
!  *                         decorated real_exit_code with ap_ in the win32/os.h.
!  * 20050305.0 (2.1.4-dev)  added pid and generation fields to worker_score
!  * 20050305.1 (2.1.5-dev)  added ap_vhost_iterate_given_conn.
!  * 20050305.2 (2.1.5-dev)  added AP_INIT_TAKE_ARGV.
!  * 20050305.3 (2.1.5-dev)  added Protocol Framework.
!  * 20050701.0 (2.1.7-dev)  Bump MODULE_MAGIC_COOKIE to "AP21"!
!  * 20050701.1 (2.1.7-dev)  trace_enable member added to core server_config
!  * 20050708.0 (2.1.7-dev)  Bump MODULE_MAGIC_COOKIE to "AP22"!
!  * 20050708.1 (2.1.7-dev)  add proxy request_status hook (minor)
!  * 20050919.0 (2.1.8-dev)  mod_ssl ssl_ext_list optional function added
!  * 20051005.0 (2.1.8-dev)  NET_TIME filter eliminated
!  * 20051005.0 (2.3.0-dev)  Bump MODULE_MAGIC_COOKIE to "AP24"!
!  * 20051115.0 (2.3.0-dev)  Added use_canonical_phys_port to core_dir_config
!  * 20060110.0 (2.3.0-dev)  Conversion of Authz to be provider based
!  *                         addition of <SatisfyAll><SatisfyOne>
!  *                         removal of Satisfy, Allow, Deny, Order
!  * 20060110.1 (2.3.0-dev)  minex and minex_set members added to
!  *                         cache_server_conf (minor)
!  * 20060110.2 (2.3.0-dev)  flush_packets and flush_wait members added to
   *                         proxy_server (minor)
!  * 20060110.3 (2.3.0-dev)  added inreslist member to proxy_conn_rec (minor)
!  * 20060110.4 (2.3.0-dev)  Added server_scheme member to server_rec (minor)
!  * 20060905.0 (2.3.0-dev)  Replaced ap_get_server_version() with
!  *                         ap_get_server_banner() and ap_get_server_description()
!  * 20060905.1 (2.3.0-dev)  Enable retry=0 for the worker (minor)
!  * 20060905.2 (2.3.0-dev)  Added ap_all_available_mutexes_string,
!  *                         ap_available_mutexes_string and
!  *                         ap_parse_mutex()
!  * 20060905.3 (2.3.0-dev)  Added conn_rec::clogging_input_filters.
!  * 20060905.4 (2.3.0-dev)  Added proxy_balancer::sticky_path.
!  * 20060905.5 (2.3.0-dev)  Added ap_mpm_safe_kill()
!  * 20070823.0 (2.3.0-dev)  Removed ap_all_available_mutexes_string,
!  *                         ap_available_mutexes_string for macros
!  * 20070823.1 (2.3.0-dev)  add ap_send_interim_response()
!  * 20071023.0 (2.3.0-dev)  add ap_get_scoreboard(sbh) split from the less
!  *                         conventional ap_get_scoreboard(proc, thread)
!  * 20071023.1 (2.3.0-dev)  Add flags field to struct proxy_alias
!  * 20071023.2 (2.3.0-dev)  Add ap_mod_status_reqtail
!  * 20071023.3 (2.3.0-dev)  Declare ap_time_process_request() as part of the
!  *                         public scoreboard API.
!  * 20071108.1 (2.3.0-dev)  Add the optional kept_body brigade to request_rec
!  * 20071108.2 (2.3.0-dev)  Add st and keep fields to struct util_ldap_connection_t
!  * 20071108.3 (2.3.0-dev)  Add API guarantee for adding connection filters
!  *                         with non-NULL request_rec pointer (ap_add_*_filter*)
!  * 20071108.4 (2.3.0-dev)  Add ap_proxy_ssl_connection_cleanup
!  * 20071108.5 (2.3.0-dev)  Add *scpool to proxy_conn_rec structure
!  * 20071108.6 (2.3.0-dev)  Add *r and need_flush to proxy_conn_rec structure
!  * 20071108.7 (2.3.0-dev)  Add *ftp_directory_charset to proxy_dir_conf
!  * 20071108.8 (2.3.0-dev)  Add optional function ap_logio_add_bytes_in() to mog_logio
!  * 20071108.9 (2.3.0-dev)  Add chroot support to unixd_config
!  * 20071108.10(2.3.0-dev)  Introduce new ap_expr API
!  * 20071108.11(2.3.0-dev)  Revise/Expand new ap_expr API
!  * 20071108.12(2.3.0-dev)  Remove ap_expr_clone from the API (same day it was added)
!  * 20080403.0 (2.3.0-dev)  Add condition field to core dir config
!  * 20080403.1 (2.3.0-dev)  Add authn/z hook and provider registration wrappers.
!  * 20080403.2 (2.3.0-dev)  Add ap_escape_path_segment_buffer() and ap_unescape_all().
!  * 20080407.0 (2.3.0-dev)  Remove ap_graceful_stop_signalled.
!  * 20080407.1              Deprecate ap_cache_cacheable_hdrs_out and add two
!  *                         generalized ap_cache_cacheable_headers_(in|out).
!  * 20080528.0 (2.3.0-dev)  Switch order of ftp_directory_charset and
!  *                         interpolate_env in proxy_dir_conf.
!  *                         Rationale: see r661069.
!  * 20080528.1 (2.3.0-dev)  add has_realm_hash() to authn_provider struct
!  * 20080722.0 (2.3.0-dev)  remove has_realm_hash() from authn_provider struct
!  * 20080722.1 (2.3.0-dev)  Add conn_timeout and conn_timeout_set to
!  *                         proxy_worker struct.
!  * 20080722.2 (2.3.0-dev)  Add scolonsep to proxy_balancer
!  * 20080829.0 (2.3.0-dev)  Add cookie attributes when removing cookies
!  * 20080830.0 (2.3.0-dev)  Cookies can be set on headers_out and err_headers_out
!  * 20080920.0 (2.3.0-dev)  Add ap_mpm_register_timed_callback.
!  * 20080920.1 (2.3.0-dev)  Export mod_rewrite.h in the public API.
!  * 20080920.2 (2.3.0-dev)  Added ap_timeout_parameter_parse to util.c / httpd.h
!  * 20081101.0 (2.3.0-dev)  Remove unused AUTHZ_GROUP_NOTE define.
!  * 20081102.0 (2.3.0-dev)  Remove authz_provider_list, authz_request_state,
!  *                         and AUTHZ_ACCESS_PASSED_NOTE.
!  * 20081104.0 (2.3.0-dev)  Remove r and need_flush fields from proxy_conn_rec
!  *                         as they are no longer used and add
!  *                         ap_proxy_buckets_lifetime_transform to mod_proxy.h
!  * 20081129.0 (2.3.0-dev)  Move AP_FILTER_ERROR and AP_NOBODY_READ|WROTE
!  *                         from util_filter.h to httpd.h and change their
!  *                         numeric values so they do not overlap with other
!  *                         potential status codes
!  * 20081201.0 (2.3.0-dev)  Rename several APIs to include ap_ prefix.
!  * 20081201.1 (2.3.0-dev)  Added ap_args_to_table and ap_body_to_table.
!  * 20081212.0 (2.3.0-dev)  Remove sb_type from process_score in scoreboard.h.
!  * 20081231.0 (2.3.0-dev)  Switch ap_escape_html API: add ap_escape_html2,
!  *                         and make ap_escape_html a macro for it.
!  * 20090130.0 (2.3.2-dev)  Add ap_ prefix to unixd_setup_child().
!  * 20090131.0 (2.3.2-dev)  Remove ap_default_type(), disable DefaultType
!  * 20090208.0 (2.3.2-dev)  Add conn_rec::current_thread.
!  * 20090208.1 (2.3.3-dev)  Add ap_retained_data_create()/ap_retained_data_get()
!  * 20090401.0 (2.3.3-dev)  Remove ap_threads_per_child, ap_max_daemons_limit,
!  *                         ap_my_generation, etc.  ap_mpm_query() can't be called
!  *                         until after the register-hooks phase.
!  * 20090401.1 (2.3.3-dev)  Protected log.c internals, http_log.h changes
!  * 20090401.2 (2.3.3-dev)  Added tmp_flush_bb to core_output_filter_ctx_t
!  * 20090401.3 (2.3.3-dev)  Added DAV options provider to mod_dav.h
!  * 20090925.0 (2.3.3-dev)  Added server_rec::context and added *server_rec
!  *                         param to ap_wait_or_timeout()
!  * 20090925.1 (2.3.3-dev)  Add optional function ap_logio_get_last_bytes() to
!  *                         mod_logio
!  * 20091011.0 (2.3.3-dev)  Move preserve_host{,_set} from proxy_server_conf to
!  *                         proxy_dir_conf
!  * 20091011.1 (2.3.3-dev)  add debug_level to util_ldap_state_t
!  * 20091031.0 (2.3.3-dev)  remove public LDAP referral-related macros
!  * 20091119.0 (2.3.4-dev)  dav_error interface uses apr_status_t parm, not errno
!  * 20091119.1 (2.3.4-dev)  ap_mutex_register(), ap_{proc,global}_mutex_create()
!  *
   */
  
! #define MODULE_MAGIC_COOKIE 0x41503234UL /* "AP24" */
  
  #ifndef MODULE_MAGIC_NUMBER_MAJOR
! #define MODULE_MAGIC_NUMBER_MAJOR 20091119
  #endif
! #define MODULE_MAGIC_NUMBER_MINOR 1                     /* 0...n */
  
  /**
   * Determine if the server's current MODULE_MAGIC_NUMBER is at least a
   * specified value.
!  *
   * Useful for testing for features.
   * For example, suppose you wish to use the apr_table_overlap
   *    function.  You can do this:
!  *
!  * \code
   * #if AP_MODULE_MAGIC_AT_LEAST(19980812,2)
   *     ... use apr_table_overlap()
   * #else
   *     ... alternative code which doesn't use apr_table_overlap()
   * #endif
!  * \endcode
!  *
   * @param major The major module magic number
   * @param minor The minor module magic number
!  * @def AP_MODULE_MAGIC_AT_LEAST(int major, int minor)
   */
! #define AP_MODULE_MAGIC_AT_LEAST(major,minor)           \
!     ((major) < MODULE_MAGIC_NUMBER_MAJOR                \
!      || ((major) == MODULE_MAGIC_NUMBER_MAJOR           \
!          && (minor) <= MODULE_MAGIC_NUMBER_MINOR))
  
  /** @deprecated present for backwards compatibility */
  #define MODULE_MAGIC_NUMBER MODULE_MAGIC_NUMBER_MAJOR
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/ap_mpm.h /tmp/patch.inc.get2.9J0UCU/include/ap_mpm.h
*** /tmp/patch.inc.get1.AvnxJA/include/ap_mpm.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/ap_mpm.h	2013-04-28 19:22:13.455311562 +0200
***************
*** 15,21 ****
   */
  
  /**
!  * @file  ap_mmn.h
   * @brief Apache Multi-Processing Module library
   *
   * @defgroup APACHE_CORE_MPM Multi-Processing Module library
--- 15,21 ----
   */
  
  /**
!  * @file  ap_mpm.h
   * @brief Apache Multi-Processing Module library
   *
   * @defgroup APACHE_CORE_MPM Multi-Processing Module library
***************
*** 27,32 ****
--- 27,33 ----
  #define AP_MPM_H
  
  #include "apr_thread_proc.h"
+ #include "httpd.h"
  
  #ifdef __cplusplus
  extern "C" {
*************** extern "C" {
*** 79,109 ****
  */
  
  /**
!  * This is the function that MPMs must create.  This function is responsible
!  * for controlling the parent and child processes.  It will run until a 
   * restart/shutdown is indicated.
   * @param pconf the configuration pool, reset before the config file is read
   * @param plog the log pool, reset after the config file is read
   * @param server_conf the global server config.
!  * @return 1 for shutdown 0 otherwise.
!  * @deffunc int ap_mpm_run(apr_pool_t *pconf, apr_pool_t *plog, server_rec *server_conf)
   */
! AP_DECLARE(int) ap_mpm_run(apr_pool_t *pconf, apr_pool_t *plog, server_rec *server_conf);
! 
! /**
!  * predicate indicating if a graceful stop has been requested ...
!  * used by the connection loop 
!  * @return 1 if a graceful stop has been requested, 0 otherwise
!  * @deffunc int ap_graceful_stop_signalled(*void)
!  */
! AP_DECLARE(int) ap_graceful_stop_signalled(void);
  
  /**
   * Spawn a process with privileges that another module has requested
   * @param r The request_rec of the current request
   * @param newproc The resulting process handle.
   * @param progname The program to run 
!  * @param const_args the arguments to pass to the new program.  The first 
   *                   one should be the program name.
   * @param env The new environment apr_table_t for the new process.  This 
   *            should be a list of NULL-terminated strings.
--- 80,101 ----
  */
  
  /**
!  * Pass control to the MPM for steady-state processing.  It is responsible
!  * for controlling the parent and child processes.  It will run until a
   * restart/shutdown is indicated.
   * @param pconf the configuration pool, reset before the config file is read
   * @param plog the log pool, reset after the config file is read
   * @param server_conf the global server config.
!  * @return DONE for shutdown OK otherwise.
   */
! AP_DECLARE_HOOK(int, mpm, (apr_pool_t *pconf, apr_pool_t *plog, server_rec *server_conf))
  
  /**
   * Spawn a process with privileges that another module has requested
   * @param r The request_rec of the current request
   * @param newproc The resulting process handle.
   * @param progname The program to run 
!  * @param args the arguments to pass to the new program.  The first 
   *                   one should be the program name.
   * @param env The new environment apr_table_t for the new process.  This 
   *            should be a list of NULL-terminated strings.
*************** AP_DECLARE(apr_status_t) ap_os_create_pr
*** 150,165 ****
  #define AP_MPMQ_MAX_DAEMONS          12  /* Max # of daemons by config   */
  #define AP_MPMQ_MPM_STATE            13  /* starting, running, stopping  */
  #define AP_MPMQ_IS_ASYNC             14  /* MPM can process async connections  */
  
  /**
!  * Query a property of the current MPM.  
   * @param query_code One of APM_MPMQ_*
   * @param result A location to place the result of the query
!  * @return APR_SUCCESS or APR_ENOTIMPL
!  * @deffunc int ap_mpm_query(int query_code, int *result)
   */
  AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result);
  
  /* Defining GPROF when compiling uses the moncontrol() function to
   * disable gprof profiling in the parent, and enable it only for
   * request processing in children (or in one_process mode).  It's
--- 142,171 ----
  #define AP_MPMQ_MAX_DAEMONS          12  /* Max # of daemons by config   */
  #define AP_MPMQ_MPM_STATE            13  /* starting, running, stopping  */
  #define AP_MPMQ_IS_ASYNC             14  /* MPM can process async connections  */
+ #define AP_MPMQ_GENERATION           15  /* MPM generation */
+ #define AP_MPMQ_HAS_SERF             16  /* MPM can drive serf internally  */
  
  /**
!  * Query a property of the current MPM.
   * @param query_code One of APM_MPMQ_*
   * @param result A location to place the result of the query
!  * @return APR_EGENERAL if an mpm-query hook has not been registered;
!  * APR_SUCCESS or APR_ENOTIMPL otherwise
!  * @remark The MPM doesn't register the implementing hook until the
!  * register_hooks hook is called, so modules cannot use ap_mpm_query()
!  * until after that point.
!  * @fn int ap_mpm_query(int query_code, int *result)
   */
  AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result);
  
+ 
+ typedef void (ap_mpm_callback_fn_t)(void *baton);
+ 
+ /* only added support in the Event MPM....  check for APR_ENOTIMPL */
+ AP_DECLARE(apr_status_t) ap_mpm_register_timed_callback(apr_time_t t,
+                                                        ap_mpm_callback_fn_t *cbfn,
+                                                        void *baton);
+     
  /* Defining GPROF when compiling uses the moncontrol() function to
   * disable gprof profiling in the parent, and enable it only for
   * request processing in children (or in one_process mode).  It's
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/ap_regex.h /tmp/patch.inc.get2.9J0UCU/include/ap_regex.h
*** /tmp/patch.inc.get1.AvnxJA/include/ap_regex.h	2013-04-28 19:22:12.347306069 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/ap_regex.h	2013-04-28 19:22:13.455311562 +0200
*************** typedef struct {
*** 100,107 ****
   * Compile a regular expression.
   * @param preg Returned compiled regex
   * @param regex The regular expression string
!  * @param cflags Bitwise OR of AP_REG_* flags (ICASE and NEWLINE supported,
!  *                                             other flags are ignored)
   * @return Zero on success or non-zero on error
   */
  AP_DECLARE(int) ap_regcomp(ap_regex_t *preg, const char *regex, int cflags);
--- 100,106 ----
   * Compile a regular expression.
   * @param preg Returned compiled regex
   * @param regex The regular expression string
!  * @param cflags Must be zero (currently).
   * @return Zero on success or non-zero on error
   */
  AP_DECLARE(int) ap_regcomp(ap_regex_t *preg, const char *regex, int cflags);
*************** AP_DECLARE(int) ap_regcomp(ap_regex_t *p
*** 112,120 ****
   * @param string The string to match
   * @param nmatch Provide information regarding the location of any matches
   * @param pmatch Provide information regarding the location of any matches
!  * @param eflags Bitwise OR of AP_REG_* flags (NOTBOL and NOTEOL supported,
!  *                                             other flags are ignored)
!  * @return 0 for successful match, AP_REG_NOMATCH otherwise
   */ 
  AP_DECLARE(int) ap_regexec(const ap_regex_t *preg, const char *string,
                             apr_size_t nmatch, ap_regmatch_t *pmatch, int eflags);
--- 111,118 ----
   * @param string The string to match
   * @param nmatch Provide information regarding the location of any matches
   * @param pmatch Provide information regarding the location of any matches
!  * @param eflags Bitwise OR of any of AP_REG_* flags 
!  * @return 0 for successful match, \p REG_NOMATCH otherwise
   */ 
  AP_DECLARE(int) ap_regexec(const ap_regex_t *preg, const char *string,
                             apr_size_t nmatch, ap_regmatch_t *pmatch, int eflags);
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/ap_regkey.h /tmp/patch.inc.get2.9J0UCU/include/ap_regkey.h
*** /tmp/patch.inc.get1.AvnxJA/include/ap_regkey.h	2013-04-28 19:22:12.347306069 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/ap_regkey.h	2013-04-28 19:22:13.463311601 +0200
*************** AP_DECLARE(apr_status_t) ap_regkey_close
*** 91,97 ****
  
  /**
   * Win32 Only: Remove the given registry key.
!  * @param parentkey The open registry key of the parent, or one of
   * <PRE>
   *           AP_REGKEY_CLASSES_ROOT
   *           AP_REGKEY_CURRENT_CONFIG
--- 91,97 ----
  
  /**
   * Win32 Only: Remove the given registry key.
!  * @param parent The open registry key of the parent, or one of
   * <PRE>
   *           AP_REGKEY_CLASSES_ROOT
   *           AP_REGKEY_CURRENT_CONFIG
*************** AP_DECLARE(apr_status_t) ap_regkey_value
*** 145,150 ****
--- 145,151 ----
   * Win32 Only: Retrieve a raw byte value from an open key.
   * @param result The raw bytes value retrieved 
   * @param resultsize Pointer to a variable to store the number raw bytes retrieved 
+  * @param resulttype Pointer to a variable to store the registry type of the value retrieved
   * @param key The registry key to retrieve the value from
   * @param valuename The named value to retrieve (pass "" for the default)
   * @param pool The pool used to store the result
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/ap_release.h /tmp/patch.inc.get2.9J0UCU/include/ap_release.h
*** /tmp/patch.inc.get1.AvnxJA/include/ap_release.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/ap_release.h	2013-04-28 19:22:13.455311562 +0200
***************
*** 25,31 ****
  #include "apr_general.h" /* stringify */
  
  #define AP_SERVER_COPYRIGHT \
!     "Copyright 2013 The Apache Software Foundation."
  
  /*
   * The below defines the base string of the Server: header. Additional
--- 25,31 ----
  #include "apr_general.h" /* stringify */
  
  #define AP_SERVER_COPYRIGHT \
!   "Copyright 2009 The Apache Software Foundation."
  
  /*
   * The below defines the base string of the Server: header. Additional
***************
*** 34,55 ****
   * The tokens are listed in order of their significance for identifying the
   * application.
   *
!  * "Product tokens should be short and to the point -- use of them for
   * advertizing or other non-essential information is explicitly forbidden."
   *
!  * Example: "Apache/1.1.0 MrWidget/0.1-alpha"
   */
  #define AP_SERVER_BASEVENDOR "Apache Software Foundation"
  #define AP_SERVER_BASEPROJECT "Apache HTTP Server"
  #define AP_SERVER_BASEPRODUCT "Apache"
  
  #define AP_SERVER_MAJORVERSION_NUMBER 2
! #define AP_SERVER_MINORVERSION_NUMBER 2
! #define AP_SERVER_PATCHLEVEL_NUMBER   24
  #define AP_SERVER_DEVBUILD_BOOLEAN    0
  
- /* Synchronize the above with docs/manual/style/version.ent */ 
- 
  #if AP_SERVER_DEVBUILD_BOOLEAN
  #define AP_SERVER_ADD_STRING          "-dev"
  #else
--- 34,53 ----
   * The tokens are listed in order of their significance for identifying the
   * application.
   *
!  * "Product tokens should be short and to the point -- use of them for 
   * advertizing or other non-essential information is explicitly forbidden."
   *
!  * Example: "Apache/1.1.0 MrWidget/0.1-alpha" 
   */
  #define AP_SERVER_BASEVENDOR "Apache Software Foundation"
  #define AP_SERVER_BASEPROJECT "Apache HTTP Server"
  #define AP_SERVER_BASEPRODUCT "Apache"
  
  #define AP_SERVER_MAJORVERSION_NUMBER 2
! #define AP_SERVER_MINORVERSION_NUMBER 3
! #define AP_SERVER_PATCHLEVEL_NUMBER   4
  #define AP_SERVER_DEVBUILD_BOOLEAN    0
  
  #if AP_SERVER_DEVBUILD_BOOLEAN
  #define AP_SERVER_ADD_STRING          "-dev"
  #else
Only in /tmp/patch.inc.get2.9J0UCU/include: ap_slotmem.h
Only in /tmp/patch.inc.get2.9J0UCU/include: ap_socache.h
Only in /tmp/patch.inc.get2.9J0UCU/include: heartbeat.h
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/http_config.h /tmp/patch.inc.get2.9J0UCU/include/http_config.h
*** /tmp/patch.inc.get1.AvnxJA/include/http_config.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/http_config.h	2013-04-28 19:22:13.455311562 +0200
*************** enum cmd_how {
*** 56,62 ****
  				 * (e.g., AddIcon)
  				 */
      FLAG,			/**< One of 'On' or 'Off' */
!     NO_ARGS,			/**< No args at all, e.g. </Directory> */
      TAKE12,			/**< one or two arguments */
      TAKE3,			/**< three arguments only */
      TAKE23,			/**< two or three arguments */
--- 56,62 ----
  				 * (e.g., AddIcon)
  				 */
      FLAG,			/**< One of 'On' or 'Off' */
!     NO_ARGS,			/**< No args at all, e.g. &lt;/Directory&gt; */
      TAKE12,			/**< one or two arguments */
      TAKE3,			/**< three arguments only */
      TAKE23,			/**< two or three arguments */
*************** typedef union {
*** 113,155 ****
  /** This configuration directive takes a flag (on/off) as a argument*/
  # define AP_FLAG	func.flag
  
! /** method of declaring a directive with no arguments */
  # define AP_INIT_NO_ARGS(directive, func, mconfig, where, help) \
      { directive, { .no_args=func }, mconfig, where, RAW_ARGS, help }
! /** method of declaring a directive with raw argument parsing */
  # define AP_INIT_RAW_ARGS(directive, func, mconfig, where, help) \
      { directive, { .raw_args=func }, mconfig, where, RAW_ARGS, help }
! /** method of declaring a directive with raw argument parsing */
  # define AP_INIT_TAKE_ARGV(directive, func, mconfig, where, help) \
      { directive, { .take_argv=func }, mconfig, where, TAKE_ARGV, help }
! /** method of declaring a directive which takes 1 argument */
  # define AP_INIT_TAKE1(directive, func, mconfig, where, help) \
      { directive, { .take1=func }, mconfig, where, TAKE1, help }
! /** method of declaring a directive which takes multiple arguments */
  # define AP_INIT_ITERATE(directive, func, mconfig, where, help) \
      { directive, { .take1=func }, mconfig, where, ITERATE, help }
! /** method of declaring a directive which takes 2 arguments */
  # define AP_INIT_TAKE2(directive, func, mconfig, where, help) \
      { directive, { .take2=func }, mconfig, where, TAKE2, help }
! /** method of declaring a directive which takes 1 or 2 arguments */
  # define AP_INIT_TAKE12(directive, func, mconfig, where, help) \
      { directive, { .take2=func }, mconfig, where, TAKE12, help }
! /** method of declaring a directive which takes multiple 2 arguments */
  # define AP_INIT_ITERATE2(directive, func, mconfig, where, help) \
      { directive, { .take2=func }, mconfig, where, ITERATE2, help }
! /** method of declaring a directive which takes 1 or 3 arguments */
  # define AP_INIT_TAKE13(directive, func, mconfig, where, help) \
      { directive, { .take3=func }, mconfig, where, TAKE13, help }
! /** method of declaring a directive which takes 2 or 3 arguments */
  # define AP_INIT_TAKE23(directive, func, mconfig, where, help) \
      { directive, { .take3=func }, mconfig, where, TAKE23, help }
! /** method of declaring a directive which takes 1 to 3 arguments */
  # define AP_INIT_TAKE123(directive, func, mconfig, where, help) \
      { directive, { .take3=func }, mconfig, where, TAKE123, help }
! /** method of declaring a directive which takes 3 arguments */
  # define AP_INIT_TAKE3(directive, func, mconfig, where, help) \
      { directive, { .take3=func }, mconfig, where, TAKE3, help }
! /** method of declaring a directive which takes a flag (on/off) as a argument*/
  # define AP_INIT_FLAG(directive, func, mconfig, where, help) \
      { directive, { .flag=func }, mconfig, where, FLAG, help }
  
--- 113,155 ----
  /** This configuration directive takes a flag (on/off) as a argument*/
  # define AP_FLAG	func.flag
  
! /** mechanism for declaring a directive with no arguments */
  # define AP_INIT_NO_ARGS(directive, func, mconfig, where, help) \
      { directive, { .no_args=func }, mconfig, where, RAW_ARGS, help }
! /** mechanism for declaring a directive with raw argument parsing */
  # define AP_INIT_RAW_ARGS(directive, func, mconfig, where, help) \
      { directive, { .raw_args=func }, mconfig, where, RAW_ARGS, help }
! /** mechanism for declaring a directive with raw argument parsing */
  # define AP_INIT_TAKE_ARGV(directive, func, mconfig, where, help) \
      { directive, { .take_argv=func }, mconfig, where, TAKE_ARGV, help }
! /** mechanism for declaring a directive which takes 1 argument */
  # define AP_INIT_TAKE1(directive, func, mconfig, where, help) \
      { directive, { .take1=func }, mconfig, where, TAKE1, help }
! /** mechanism for declaring a directive which takes multiple arguments */
  # define AP_INIT_ITERATE(directive, func, mconfig, where, help) \
      { directive, { .take1=func }, mconfig, where, ITERATE, help }
! /** mechanism for declaring a directive which takes 2 arguments */
  # define AP_INIT_TAKE2(directive, func, mconfig, where, help) \
      { directive, { .take2=func }, mconfig, where, TAKE2, help }
! /** mechanism for declaring a directive which takes 1 or 2 arguments */
  # define AP_INIT_TAKE12(directive, func, mconfig, where, help) \
      { directive, { .take2=func }, mconfig, where, TAKE12, help }
! /** mechanism for declaring a directive which takes multiple 2 arguments */
  # define AP_INIT_ITERATE2(directive, func, mconfig, where, help) \
      { directive, { .take2=func }, mconfig, where, ITERATE2, help }
! /** mechanism for declaring a directive which takes 1 or 3 arguments */
  # define AP_INIT_TAKE13(directive, func, mconfig, where, help) \
      { directive, { .take3=func }, mconfig, where, TAKE13, help }
! /** mechanism for declaring a directive which takes 2 or 3 arguments */
  # define AP_INIT_TAKE23(directive, func, mconfig, where, help) \
      { directive, { .take3=func }, mconfig, where, TAKE23, help }
! /** mechanism for declaring a directive which takes 1 to 3 arguments */
  # define AP_INIT_TAKE123(directive, func, mconfig, where, help) \
      { directive, { .take3=func }, mconfig, where, TAKE123, help }
! /** mechanism for declaring a directive which takes 3 arguments */
  # define AP_INIT_TAKE3(directive, func, mconfig, where, help) \
      { directive, { .take3=func }, mconfig, where, TAKE3, help }
! /** mechanism for declaring a directive which takes a flag (on/off) argument */
  # define AP_INIT_FLAG(directive, func, mconfig, where, help) \
      { directive, { .flag=func }, mconfig, where, FLAG, help }
  
*************** struct command_struct {
*** 208,215 ****
      void *cmd_data;		
      /** What overrides need to be allowed to enable this command. */
      int req_override;
!     /** What the command expects as arguments 
!      *  @defvar cmd_how args_how*/
      enum cmd_how args_how;
  
      /** 'usage' message, in case of syntax errors */
--- 208,214 ----
      void *cmd_data;		
      /** What overrides need to be allowed to enable this command. */
      int req_override;
!     /** What the command expects as arguments */
      enum cmd_how args_how;
  
      /** 'usage' message, in case of syntax errors */
*************** struct command_struct {
*** 225,243 ****
   * @{
   */
  #define OR_NONE 0             /**< *.conf is not available anywhere in this override */
! #define OR_LIMIT 1	     /**< *.conf inside <Directory> or <Location>
  				and .htaccess when AllowOverride Limit */
  #define OR_OPTIONS 2         /**< *.conf anywhere
                                  and .htaccess when AllowOverride Options */
  #define OR_FILEINFO 4        /**< *.conf anywhere
  				and .htaccess when AllowOverride FileInfo */
! #define OR_AUTHCFG 8         /**< *.conf inside <Directory> or <Location>
  				and .htaccess when AllowOverride AuthConfig */
  #define OR_INDEXES 16        /**< *.conf anywhere
  				and .htaccess when AllowOverride Indexes */
  #define OR_UNSET 32          /**< unset a directive (in Allow) */
! #define ACCESS_CONF 64       /**< *.conf inside <Directory> or <Location> */
! #define RSRC_CONF 128	     /**< *.conf outside <Directory> or <Location> */
  #define EXEC_ON_READ 256     /**< force directive to execute a command 
                  which would modify the configuration (like including another
                  file, or IFModule */
--- 224,242 ----
   * @{
   */
  #define OR_NONE 0             /**< *.conf is not available anywhere in this override */
! #define OR_LIMIT 1	     /**< *.conf inside &lt;Directory&gt; or &lt;Location&gt;
  				and .htaccess when AllowOverride Limit */
  #define OR_OPTIONS 2         /**< *.conf anywhere
                                  and .htaccess when AllowOverride Options */
  #define OR_FILEINFO 4        /**< *.conf anywhere
  				and .htaccess when AllowOverride FileInfo */
! #define OR_AUTHCFG 8         /**< *.conf inside &lt;Directory&gt; or &lt;Location&gt;
  				and .htaccess when AllowOverride AuthConfig */
  #define OR_INDEXES 16        /**< *.conf anywhere
  				and .htaccess when AllowOverride Indexes */
  #define OR_UNSET 32          /**< unset a directive (in Allow) */
! #define ACCESS_CONF 64       /**< *.conf inside &lt;Directory&gt; or &lt;Location&gt; */
! #define RSRC_CONF 128	     /**< *.conf outside &lt;Directory&gt; or &lt;Location&gt; */
  #define EXEC_ON_READ 256     /**< force directive to execute a command 
                  which would modify the configuration (like including another
                  file, or IFModule */
*************** struct cmd_parms_struct {
*** 275,281 ****
      void *info;
      /** Which allow-override bits are set */
      int override;
!     /** Which methods are <Limit>ed */
      apr_int64_t limited;
      /** methods which are limited */
      apr_array_header_t *limited_xmethods;
--- 274,280 ----
      void *info;
      /** Which allow-override bits are set */
      int override;
!     /** Which methods are &lt;Limit&gt;ed */
      apr_int64_t limited;
      /** methods which are limited */
      apr_array_header_t *limited_xmethods;
*************** struct cmd_parms_struct {
*** 295,302 ****
      /** Server_rec being configured for */
      server_rec *server;
      /** If configuring for a directory, pathname of that directory.  
!      *  NOPE!  That's what it meant previous to the existance of <Files>, 
!      * <Location> and regex matching.  Now the only usefulness that can be 
       * derived from this field is whether a command is being called in a 
       * server context (path == NULL) or being called in a dir context 
       * (path != NULL).  */
--- 294,301 ----
      /** Server_rec being configured for */
      server_rec *server;
      /** If configuring for a directory, pathname of that directory.  
!      *  NOPE!  That's what it meant previous to the existance of &lt;Files&gt;, 
!      * &lt;Location&gt; and regex matching.  Now the only usefulness that can be 
       * derived from this field is whether a command is being called in a 
       * server context (path == NULL) or being called in a dir context 
       * (path != NULL).  */
*************** struct module_struct {
*** 336,342 ****
      void *dynamic_load_handle;
  
      /** A pointer to the next module in the list
!      *  @defvar module_struct *next */
      struct module_struct *next;
  
      /** Magic Cookie to identify a module structure;  It's mainly 
--- 335,342 ----
      void *dynamic_load_handle;
  
      /** A pointer to the next module in the list
!      *  @var module_struct *next
!      */
      struct module_struct *next;
  
      /** Magic Cookie to identify a module structure;  It's mainly 
*************** typedef struct ap_conf_vector_t ap_conf_
*** 439,445 ****
  /**
   * Generic accessors for other modules to get at their own module-specific
   * data
!  * @param conf_vector The vector in which the modules configuration is stored.
   *        usually r->per_dir_config or s->module_config
   * @param m The module to get the data for.
   * @return The module-specific data
--- 439,445 ----
  /**
   * Generic accessors for other modules to get at their own module-specific
   * data
!  * @param cv The vector in which the modules configuration is stored.
   *        usually r->per_dir_config or s->module_config
   * @param m The module to get the data for.
   * @return The module-specific data
*************** AP_DECLARE(void *) ap_get_module_config(
*** 450,456 ****
  /**
   * Generic accessors for other modules to set at their own module-specific
   * data
!  * @param conf_vector The vector in which the modules configuration is stored.
   *        usually r->per_dir_config or s->module_config
   * @param m The module to set the data for.
   * @param val The module-specific data to set
--- 450,456 ----
  /**
   * Generic accessors for other modules to set at their own module-specific
   * data
!  * @param cv The vector in which the modules configuration is stored.
   *        usually r->per_dir_config or s->module_config
   * @param m The module to set the data for.
   * @param val The module-specific data to set
*************** AP_DECLARE_NONSTD(const char *) ap_set_i
*** 492,498 ****
  
  /**
   * Return true if the specified method is limited by being listed in
!  * a <Limit> container, or by *not* being listed in a <LimiteExcept>
   * container.
   *
   * @param   method  Pointer to a string specifying the method to check.
--- 492,498 ----
  
  /**
   * Return true if the specified method is limited by being listed in
!  * a &lt;Limit&gt; container, or by *not* being listed in a &lt;LimitExcept&gt;
   * container.
   *
   * @param   method  Pointer to a string specifying the method to check.
*************** AP_DECLARE_NONSTD(const char *) ap_set_f
*** 539,549 ****
   * @param struct_ptr pointer into a given type
   * @param arg The argument to the directive
   * @return The cmd->help value as the error string
!  * @tip This allows simple declarations such as;
!  * <pre>
   *     AP_INIT_RAW_ARGS("Foo", ap_set_deprecated, NULL, OR_ALL, 
   *         "The Foo directive is no longer supported, use Bar"),
!  * </pre>
   */
  AP_DECLARE_NONSTD(const char *) ap_set_deprecated(cmd_parms *cmd, 
                                                    void *struct_ptr, 
--- 539,549 ----
   * @param struct_ptr pointer into a given type
   * @param arg The argument to the directive
   * @return The cmd->help value as the error string
!  * @note This allows simple declarations such as:
!  * @code
   *     AP_INIT_RAW_ARGS("Foo", ap_set_deprecated, NULL, OR_ALL, 
   *         "The Foo directive is no longer supported, use Bar"),
!  * @endcode
   */
  AP_DECLARE_NONSTD(const char *) ap_set_deprecated(cmd_parms *cmd, 
                                                    void *struct_ptr, 
*************** AP_DECLARE(const char *) ap_add_module(m
*** 576,588 ****
  AP_DECLARE(void) ap_remove_module(module *m);
  /**
   * Add a module to the chained modules list and the list of loaded modules
!  * @param m The module structure of the module to add
   * @param p The pool with the same lifetime as the module
   */
  AP_DECLARE(const char *) ap_add_loaded_module(module *mod, apr_pool_t *p);
  /**
   * Remove a module fromthe chained modules list and the list of loaded modules
!  * @param m the module structure of the module to remove
   */
  AP_DECLARE(void) ap_remove_loaded_module(module *mod);
  /**
--- 576,588 ----
  AP_DECLARE(void) ap_remove_module(module *m);
  /**
   * Add a module to the chained modules list and the list of loaded modules
!  * @param mod The module structure of the module to add
   * @param p The pool with the same lifetime as the module
   */
  AP_DECLARE(const char *) ap_add_loaded_module(module *mod, apr_pool_t *p);
  /**
   * Remove a module fromthe chained modules list and the list of loaded modules
!  * @param mod the module structure of the module to remove
   */
  AP_DECLARE(void) ap_remove_loaded_module(module *mod);
  /**
*************** AP_DECLARE(int) ap_cfg_getc(ap_configfil
*** 647,653 ****
  AP_DECLARE(int) ap_cfg_closefile(ap_configfile_t *cfp);
  
  /**
!  * Read all data between the current <foo> and the matching </foo>.  All
   * of this data is forgotten immediately.  
   * @param cmd The cmd_parms to pass to the directives inside the container
   * @param directive The directive name to read until
--- 647,653 ----
  AP_DECLARE(int) ap_cfg_closefile(ap_configfile_t *cfp);
  
  /**
!  * Read all data between the current &lt;foo&gt; and the matching &lt;/foo&gt;.  All
   * of this data is forgotten immediately.  
   * @param cmd The cmd_parms to pass to the directives inside the container
   * @param directive The directive name to read until
*************** AP_DECLARE(int) ap_cfg_closefile(ap_conf
*** 656,662 ****
  AP_DECLARE(const char *) ap_soak_end_container(cmd_parms *cmd, char *directive);
  
  /**
!  * Read all data between the current <foo> and the matching </foo> and build
   * a config tree from it
   * @param p pool to allocate from
   * @param temp_pool Temporary pool to allocate from
--- 656,662 ----
  AP_DECLARE(const char *) ap_soak_end_container(cmd_parms *cmd, char *directive);
  
  /**
!  * Read all data between the current &lt;foo&gt; and the matching &lt;/foo&gt; and build
   * a config tree from it
   * @param p pool to allocate from
   * @param temp_pool Temporary pool to allocate from
*************** AP_DECLARE(const char *) ap_walk_config(
*** 710,729 ****
  AP_DECLARE(const char *) ap_check_cmd_context(cmd_parms *cmd, 
                                                unsigned forbidden);
  
! #define  NOT_IN_VIRTUALHOST     0x01 /**< Forbidden in <Virtualhost> */
! #define  NOT_IN_LIMIT           0x02 /**< Forbidden in <Limit> */
! #define  NOT_IN_DIRECTORY       0x04 /**< Forbidden in <Directory> */
! #define  NOT_IN_LOCATION        0x08 /**< Forbidden in <Location> */
! #define  NOT_IN_FILES           0x10 /**< Forbidden in <Files> */
! /** Forbidden in <Directory>/<Location>/<Files>*/
  #define  NOT_IN_DIR_LOC_FILE    (NOT_IN_DIRECTORY|NOT_IN_LOCATION|NOT_IN_FILES) 
! /** Forbidden in <VirtualHost>/<Limit>/<Directory>/<Location>/<Files> */
  #define  GLOBAL_ONLY            (NOT_IN_VIRTUALHOST|NOT_IN_LIMIT|NOT_IN_DIR_LOC_FILE) 
  
  /** @} */
  
- #ifdef CORE_PRIVATE
- 
  /**
   * @brief This structure is used to assign symbol names to module pointers
   */
--- 710,727 ----
  AP_DECLARE(const char *) ap_check_cmd_context(cmd_parms *cmd, 
                                                unsigned forbidden);
  
! #define  NOT_IN_VIRTUALHOST     0x01 /**< Forbidden in &lt;VirtualHost&gt; */
! #define  NOT_IN_LIMIT           0x02 /**< Forbidden in &lt;Limit&gt; */
! #define  NOT_IN_DIRECTORY       0x04 /**< Forbidden in &lt;Directory&gt; */
! #define  NOT_IN_LOCATION        0x08 /**< Forbidden in &lt;Location&gt; */
! #define  NOT_IN_FILES           0x10 /**< Forbidden in &lt;Files&gt; */
! /** Forbidden in &lt;Directory&gt;/&lt;Location&gt;/&lt;Files&gt;*/
  #define  NOT_IN_DIR_LOC_FILE    (NOT_IN_DIRECTORY|NOT_IN_LOCATION|NOT_IN_FILES) 
! /** Forbidden in &lt;VirtualHost&gt;/&lt;Limit&gt;/&lt;Directory&gt;/&lt;Location&gt;/&lt;Files&gt; */
  #define  GLOBAL_ONLY            (NOT_IN_VIRTUALHOST|NOT_IN_LIMIT|NOT_IN_DIR_LOC_FILE) 
  
  /** @} */
  
  /**
   * @brief This structure is used to assign symbol names to module pointers
   */
*************** typedef struct {
*** 734,761 ****
  
  /**
   * The topmost module in the list
!  * @defvar module *ap_top_module
   */
  AP_DECLARE_DATA extern module *ap_top_module;
  
  /**
   * Array of all statically linked modules
!  * @defvar module *ap_prelinked_modules[]
   */
  AP_DECLARE_DATA extern module *ap_prelinked_modules[];
  /**
   * Array of all statically linked modulenames (symbols)
!  * @defvar ap_module_symbol_t ap_prelinked_modulenames[]
   */
  AP_DECLARE_DATA extern ap_module_symbol_t ap_prelinked_module_symbols[];
  /**
   * Array of all preloaded modules
!  * @defvar module *ap_preloaded_modules[]
   */
  AP_DECLARE_DATA extern module *ap_preloaded_modules[];
  /**
   * Array of all loaded modules
!  * @defvar module **ap_loaded_modules
   */
  AP_DECLARE_DATA extern module **ap_loaded_modules;
  
--- 732,759 ----
  
  /**
   * The topmost module in the list
!  * @var module *ap_top_module
   */
  AP_DECLARE_DATA extern module *ap_top_module;
  
  /**
   * Array of all statically linked modules
!  * @var module *ap_prelinked_modules[]
   */
  AP_DECLARE_DATA extern module *ap_prelinked_modules[];
  /**
   * Array of all statically linked modulenames (symbols)
!  * @var ap_module_symbol_t ap_prelinked_module_symbols[]
   */
  AP_DECLARE_DATA extern ap_module_symbol_t ap_prelinked_module_symbols[];
  /**
   * Array of all preloaded modules
!  * @var module *ap_preloaded_modules[]
   */
  AP_DECLARE_DATA extern module *ap_preloaded_modules[];
  /**
   * Array of all loaded modules
!  * @var module **ap_loaded_modules
   */
  AP_DECLARE_DATA extern module **ap_loaded_modules;
  
*************** AP_CORE_DECLARE(ap_conf_vector_t*) ap_me
*** 861,879 ****
   */
  AP_CORE_DECLARE(ap_conf_vector_t*) ap_create_conn_config(apr_pool_t *p);
  
! /* For http_core.c... (<Directory> command and virtual hosts) */
  
  /**
   * parse an htaccess file
!  * @param resulting htaccess_result
   * @param r The request currently being served
   * @param override Which overrides are active
   * @param path The path to the htaccess file
   * @param access_name The list of possible names for .htaccess files
   * int The status of the current request
   */
  AP_CORE_DECLARE(int) ap_parse_htaccess(ap_conf_vector_t **result, 
!                                        request_rec *r, int override,
                                         int override_opts,
                                         const char *path, 
                                         const char *access_name);
--- 859,879 ----
   */
  AP_CORE_DECLARE(ap_conf_vector_t*) ap_create_conn_config(apr_pool_t *p);
  
! /* For http_core.c... (&lt;Directory&gt; command and virtual hosts) */
  
  /**
   * parse an htaccess file
!  * @param result htaccess_result
   * @param r The request currently being served
   * @param override Which overrides are active
+  * @param override_opts Which allow-override-opts bits are set
   * @param path The path to the htaccess file
   * @param access_name The list of possible names for .htaccess files
   * int The status of the current request
   */
  AP_CORE_DECLARE(int) ap_parse_htaccess(ap_conf_vector_t **result, 
!                                        request_rec *r,
!                                        int override,
                                         int override_opts,
                                         const char *path, 
                                         const char *access_name);
*************** AP_CORE_DECLARE(const char *) ap_init_vi
*** 897,903 ****
   * @param fname The name of the config file
   * @param conftree The root node of the created config tree
   * @param p Pool for general allocation
!  * @param ptem Pool for temporary allocation
   */
  AP_DECLARE(const char *) ap_process_resource_config(server_rec *s,
                                                      const char *fname,
--- 897,903 ----
   * @param fname The name of the config file
   * @param conftree The root node of the created config tree
   * @param p Pool for general allocation
!  * @param ptemp Pool for temporary allocation
   */
  AP_DECLARE(const char *) ap_process_resource_config(server_rec *s,
                                                      const char *fname,
*************** AP_DECLARE(int) ap_process_config_tree(s
*** 918,923 ****
--- 918,938 ----
                                         apr_pool_t *p,
                                         apr_pool_t *ptemp);
  
+ /**
+  * Store data which will be retained across unload/load of modules
+  * @param key The unique key associated with this module's retained data
+  * @param size in bytes of the retained data (to be allocated)
+  * @return Address of new retained data structure, initially cleared
+  */
+ AP_DECLARE(void *) ap_retained_data_create(const char *key, apr_size_t size);
+ 
+ /**
+  * Retrieve data which was stored by ap_retained_data_create()
+  * @param key The unique key associated with this module's retained data
+  * @return Address of previously retained data structure, or NULL if not yet saved
+  */
+ AP_DECLARE(void *) ap_retained_data_get(const char *key);
+     
  /* Module-method dispatchers, also for http_request.c */
  /**
   * Run the handler phase of each module until a module accepts the
*************** AP_CORE_DECLARE(void *) ap_set_config_ve
*** 963,970 ****
                                                const char *section,
                                                module *mod, apr_pool_t *pconf);
  
- #endif
- 
    /* Hooks */
  
  /**
--- 978,983 ----
*************** AP_DECLARE_HOOK(int,pre_config,(apr_pool
*** 985,990 ****
--- 998,1014 ----
                                  apr_pool_t *ptemp))
  
  /**
+  * Run the check_config function for each module
+  * @param pconf The config pool
+  * @param plog The logging streams pool
+  * @param ptemp The temporary pool
+  * @param s the server to operate upon
+  * @return OK or DECLINED on success anything else is a error
+  */
+ AP_DECLARE_HOOK(int,check_config,(apr_pool_t *pconf, apr_pool_t *plog,
+                                   apr_pool_t *ptemp, server_rec *s))
+ 
+ /**
   * Run the test_config function for each module; this hook is run
   * only if the server was invoked to test the configuration syntax.
   * @param pconf The config pool
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/http_connection.h /tmp/patch.inc.get2.9J0UCU/include/http_connection.h
*** /tmp/patch.inc.get1.AvnxJA/include/http_connection.h	2013-04-28 19:22:12.347306069 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/http_connection.h	2013-04-28 19:22:13.463311601 +0200
*************** extern "C" {
*** 38,44 ****
   * @brief Apache connection library
   */
  
- #ifdef CORE_PRIVATE
  /**
   * This is the protocol module driver.  This calls all of the
   * pre-connection and connection hooks for all protocol modules.
--- 38,43 ----
*************** AP_CORE_DECLARE(void) ap_flush_conn(conn
*** 71,77 ****
   * @param c The connection we are closing
   */
  AP_DECLARE(void) ap_lingering_close(conn_rec *c);
- #endif
  
    /* Hooks */
  /**
--- 70,75 ----
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/http_core.h /tmp/patch.inc.get2.9J0UCU/include/http_core.h
*** /tmp/patch.inc.get1.AvnxJA/include/http_core.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/http_core.h	2013-04-28 19:22:13.455311562 +0200
***************
*** 30,35 ****
--- 30,38 ----
  #include "apr_hash.h"
  #include "apr_optional.h"
  #include "util_filter.h"
+ #include "ap_expr.h"
+ 
+ #include "http_config.h"
  
  #if APR_HAVE_STRUCT_RLIMIT
  #include <sys/time.h>
*************** extern "C" {
*** 73,101 ****
  #define OPT_EXECCGI 8
  /**  directive unset */
  #define OPT_UNSET 16
! /**  IncludesNOEXEC directive */
! #define OPT_INCNOEXEC 32
  /** SymLinksIfOwnerMatch directive */
  #define OPT_SYM_OWNER 64
  /** MultiViews directive */
  #define OPT_MULTI 128
  /**  All directives */
! #define OPT_ALL (OPT_INDEXES|OPT_INCLUDES|OPT_INCNOEXEC|OPT_SYM_LINKS|OPT_EXECCGI)
  /** @} */
  
- #ifdef CORE_PRIVATE
- /* For internal use only - since 2.2.12, the OPT_INCNOEXEC bit is
-  * internally replaced by OPT_INC_WITH_EXEC.  The internal semantics
-  * of the two SSI-related bits are hence:
-  *
-  *  OPT_INCLUDES => "enable SSI, without exec= permission"
-  *  OPT_INC_WITH_EXEC => "iff OPT_INCLUDES is set, also enable exec="
-  *
-  * The set of options exposed via ap_allow_options() retains the
-  * semantics of OPT_INCNOEXEC by flipping the bit. */
- #define OPT_INC_WITH_EXEC OPT_INCNOEXEC
- #endif
- 
  /**
   * @defgroup get_remote_host Remote Host Resolution 
   * @ingroup APACHE_CORE_HTTPD
--- 76,91 ----
  #define OPT_EXECCGI 8
  /**  directive unset */
  #define OPT_UNSET 16
! /**  SSI exec= permission is permitted, iff OPT_INCLUDES is also set */
! #define OPT_INC_WITH_EXEC 32
  /** SymLinksIfOwnerMatch directive */
  #define OPT_SYM_OWNER 64
  /** MultiViews directive */
  #define OPT_MULTI 128
  /**  All directives */
! #define OPT_ALL (OPT_INDEXES|OPT_INCLUDES|OPT_INC_WITH_EXEC|OPT_SYM_LINKS|OPT_EXECCGI)
  /** @} */
  
  /**
   * @defgroup get_remote_host Remote Host Resolution 
   * @ingroup APACHE_CORE_HTTPD
*************** AP_DECLARE(int) ap_allow_options(request
*** 159,171 ****
  AP_DECLARE(int) ap_allow_overrides(request_rec *r);
  
  /**
-  * Retrieve the value of the DefaultType directive, or text/plain if not set
-  * @param r The current request
-  * @return The default type
-  */
- AP_DECLARE(const char *) ap_default_type(request_rec *r);     
- 
- /**
   * Retrieve the document root for this server
   * @param r The current request
   * @warning Don't use this!  If your request went through a Userdir, or 
--- 149,154 ----
*************** AP_DECLARE(const char *) ap_auth_name(re
*** 320,334 ****
  AP_DECLARE(int) ap_satisfies(request_rec *r);
  
  /**
-  * Retrieve information about all of the requires directives for this request
-  * @param r The current request
-  * @return An array of all requires directives for this request
-  */
- AP_DECLARE(const apr_array_header_t *) ap_requires(request_rec *r);    
- 
- #ifdef CORE_PRIVATE
- 
- /**
   * Core is also unlike other modules in being implemented in more than
   * one file... so, data structures are declared here, even though most of
   * the code that cares really is in http_core.c.  Also, another accessor.
--- 303,308 ----
*************** typedef struct {
*** 457,476 ****
      overrides_t override;
      allow_options_t override_opts;
      
-     /* MIME typing --- the core doesn't do anything at all with this,
-      * but it does know what to slap on a request for a document which
-      * goes untyped by other mechanisms before it slips out the door...
-      */
-     
-     char *ap_default_type;
-   
-     /* Authentication stuff.  Groan... */
-     
-     int *satisfy; /* for every method one */
-     char *ap_auth_type;
-     char *ap_auth_name;
-     apr_array_header_t *ap_requires;
- 
      /* Custom response config. These can contain text or a URL to redirect to.
       * if response_code_strings is NULL then there are none in the config,
       * if it's not null then it's allocated to sizeof(char*)*RESPONSE_CODES.
--- 431,436 ----
*************** typedef struct {
*** 487,493 ****
  #define HOSTNAME_LOOKUP_UNSET	3
      unsigned int hostname_lookups : 4;
  
!     signed int content_md5 : 2;  /* calculate Content-MD5? */
  
  #define USE_CANONICAL_NAME_OFF   (0)
  #define USE_CANONICAL_NAME_ON    (1)
--- 447,453 ----
  #define HOSTNAME_LOOKUP_UNSET	3
      unsigned int hostname_lookups : 4;
  
!     unsigned int content_md5 : 2;  /* calculate Content-MD5? */
  
  #define USE_CANONICAL_NAME_OFF   (0)
  #define USE_CANONICAL_NAME_ON    (1)
*************** typedef struct {
*** 568,592 ****
  #define USE_CANONICAL_PHYS_PORT_UNSET (2)
      unsigned use_canonical_phys_port : 2;
  
! 
!     unsigned int decode_encoded_slashes : 1; /* whether to decode encoded slashes in URLs */
! 
! #define AP_MAXRANGES_UNSET     -1
! #define AP_MAXRANGES_DEFAULT   -2
! #define AP_MAXRANGES_UNLIMITED -3
! #define AP_MAXRANGES_NORANGES   0
!     /** Number of Ranges before returning HTTP_OK. **/
!     int max_ranges;
! 
  } core_dir_config;
  
  /* Per-server core configuration */
  
  typedef struct {
    
- #ifdef GPROF
      char *gprof_dir;
- #endif
  
      /* Name translations --- we want the core to be able to do *something*
       * so it's at least a minimally functional web server on its own (and
--- 528,541 ----
  #define USE_CANONICAL_PHYS_PORT_UNSET (2)
      unsigned use_canonical_phys_port : 2;
  
!     ap_parse_node_t *condition;   /* Conditionally merge <If> sections */
  } core_dir_config;
  
  /* Per-server core configuration */
  
  typedef struct {
    
      char *gprof_dir;
  
      /* Name translations --- we want the core to be able to do *something*
       * so it's at least a minimally functional web server on its own (and
*************** int ap_core_input_filter(ap_filter_t *f,
*** 634,640 ****
                           apr_off_t readbytes);
  apr_status_t ap_core_output_filter(ap_filter_t *f, apr_bucket_brigade *b);
  
- #endif /* CORE_PRIVATE */
  
  AP_DECLARE(const char*) ap_get_server_protocol(server_rec* s);
  AP_DECLARE(void) ap_set_server_protocol(server_rec* s, const char* proto);
--- 583,588 ----
*************** APR_DECLARE_OPTIONAL_FN(void, ap_logio_a
*** 698,703 ****
--- 646,653 ----
  APR_DECLARE_OPTIONAL_FN(void, ap_logio_add_bytes_in,
                          (conn_rec *c, apr_off_t bytes));
  
+ APR_DECLARE_OPTIONAL_FN(apr_off_t, ap_logio_get_last_bytes, (conn_rec *c));
+ 
  /* ----------------------------------------------------------------------
   *
   * ident lookups with mod_ident
*************** APR_DECLARE_OPTIONAL_FN(void, ap_logio_a
*** 706,711 ****
--- 656,677 ----
  APR_DECLARE_OPTIONAL_FN(const char *, ap_ident_lookup,
                          (request_rec *r));
  
+ /* ----------------------------------------------------------------------
+  *
+  * authorization values with mod_authz_core
+  */
+ 
+ APR_DECLARE_OPTIONAL_FN(int, authz_some_auth_required, (request_rec *r));
+ APR_DECLARE_OPTIONAL_FN(const char *, authn_ap_auth_type, (request_rec *r));
+ APR_DECLARE_OPTIONAL_FN(const char *, authn_ap_auth_name, (request_rec *r));
+ 
+ /* ----------------------------------------------------------------------
+  *
+  * authorization values with mod_access_compat
+  */
+ 
+ APR_DECLARE_OPTIONAL_FN(int, access_compat_ap_satisfies, (request_rec *r));
+ 
  /* ---------------------------------------------------------------------- */
  
  #ifdef __cplusplus
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/httpd.h /tmp/patch.inc.get2.9J0UCU/include/httpd.h
*** /tmp/patch.inc.get1.AvnxJA/include/httpd.h	2013-04-28 19:22:12.347306069 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/httpd.h	2013-04-28 19:22:13.455311562 +0200
***************
*** 53,58 ****
--- 53,59 ----
  #include "apr_network_io.h"
  #include "apr_buckets.h"
  #include "apr_poll.h"
+ #include "apr_thread_proc.h"
  
  #include "os.h"
  
***************
*** 68,75 ****
  extern "C" {
  #endif
  
- #ifdef CORE_PRIVATE
- 
  /* ----------------------------- config dir ------------------------------ */
  
  /** Define this to be the default server home dir. Most things later in this
--- 69,74 ----
*************** extern "C" {
*** 82,90 ****
  #elif defined(WIN32)
  /** Set default for Windows file system */
  #define HTTPD_ROOT "/apache"
- #elif defined (BEOS)
- /** Set the default for BeOS */
- #define HTTPD_ROOT "/boot/home/apache"
  #elif defined (NETWARE)
  /** Set the default for NetWare */
  #define HTTPD_ROOT "/apache"
--- 81,86 ----
*************** extern "C" {
*** 154,164 ****
  #endif
  
  /** The path to the suExec wrapper, can be overridden in Configuration */
- #if !defined(NETWARE) && !defined(WIN32)
  #ifndef SUEXEC_BIN
  #define SUEXEC_BIN  HTTPD_ROOT "/bin/suexec"
  #endif
- #endif
  
  /** The timeout for waiting for messages */
  #ifndef DEFAULT_TIMEOUT
--- 150,158 ----
*************** extern "C" {
*** 186,192 ****
   *
   * Internal buffer sizes are two bytes more than the DEFAULT_LIMIT_REQUEST_LINE
   * and DEFAULT_LIMIT_REQUEST_FIELDSIZE below, which explains the 8190.
!  * These two limits can be lowered (but not raised) by the server config
   * directives LimitRequestLine and LimitRequestFieldsize, respectively.
   *
   * DEFAULT_LIMIT_REQUEST_FIELDS can be modified or disabled (set = 0) by
--- 180,186 ----
   *
   * Internal buffer sizes are two bytes more than the DEFAULT_LIMIT_REQUEST_LINE
   * and DEFAULT_LIMIT_REQUEST_FIELDSIZE below, which explains the 8190.
!  * These two limits can be lowered or raised by the server config
   * directives LimitRequestLine and LimitRequestFieldsize, respectively.
   *
   * DEFAULT_LIMIT_REQUEST_FIELDS can be modified or disabled (set = 0) by
*************** extern "C" {
*** 212,219 ****
   */
  #define DEFAULT_ADD_DEFAULT_CHARSET_NAME "iso-8859-1"
  
- #endif /* CORE_PRIVATE */
- 
  /** default HTTP Server protocol */
  #define AP_SERVER_PROTOCOL "HTTP/1.1"
  
--- 206,211 ----
*************** extern "C" {
*** 225,248 ****
  #define AP_DEFAULT_INDEX "index.html"
  #endif
  
- 
- /** 
-  * Define this to be what type you'd like returned for files with unknown 
-  * suffixes.  
-  * @warning MUST be all lower case. 
-  */
- #ifndef DEFAULT_CONTENT_TYPE
- #define DEFAULT_CONTENT_TYPE "text/plain"
- #endif
- 
- /**
-  * NO_CONTENT_TYPE is an alternative DefaultType value that suppresses
-  * setting any default type when there's no information (e.g. a proxy).
-  */
- #ifndef NO_CONTENT_TYPE
- #define NO_CONTENT_TYPE "none"
- #endif
- 
  /** The name of the MIME types file */
  #ifndef AP_TYPES_CONFIG_FILE
  #define AP_TYPES_CONFIG_FILE "conf/mime.types"
--- 217,222 ----
*************** extern "C" {
*** 337,345 ****
  #define AP_MAX_SENDFILE 16777216  /* 2^24 */
  
  /**
!  * MPM child process exit status values
!  * The MPM parent process may check the status to see if special
!  * error handling is required.
   */
  /** a normal exit */
  #define APEXIT_OK		0x0
--- 311,319 ----
  #define AP_MAX_SENDFILE 16777216  /* 2^24 */
  
  /**
!  * Special Apache error codes. These are basically used
!  *  in http_main.c so we can keep track of various errors.
!  *        
   */
  /** a normal exit */
  #define APEXIT_OK		0x0
*************** typedef struct {
*** 430,442 ****
  AP_DECLARE(void) ap_get_server_revision(ap_version_t *version);
  
  /**
-  * Get the server version string, as controlled by the ServerTokens directive
-  * @return The server version string
-  * @deprecated @see ap_get_server_banner() and ap_get_server_description()
-  */
- AP_DECLARE(const char *) ap_get_server_version(void);
- 
- /**
   * Get the server banner in a form suitable for sending over the
   * network, with the level of information controlled by the
   * ServerTokens directive.
--- 404,409 ----
*************** AP_DECLARE(const char *) ap_get_server_d
*** 455,462 ****
  
  /**
   * Add a component to the server description and banner strings
-  * (The latter is returned by the deprecated function
-  * ap_get_server_version().)
   * @param pconf The pool to allocate the component from
   * @param component The string to add
   */
--- 422,427 ----
*************** AP_DECLARE(void) ap_add_version_componen
*** 468,479 ****
   */
  AP_DECLARE(const char *) ap_get_server_built(void);
  
  #define DECLINED -1		/**< Module declines to handle */
  #define DONE -2			/**< Module has served the response completely 
  				 *  - it's safe to die() with no more output
  				 */
! #define OK 0			/**< Module has handled this stage. */
  
  
  /**
   * @defgroup HTTP_Status HTTP Status Codes
--- 433,458 ----
   */
  AP_DECLARE(const char *) ap_get_server_built(void);
  
+ /* non-HTTP status codes returned by hooks */
+ 
+ #define OK 0			/**< Module has handled this stage. */
  #define DECLINED -1		/**< Module declines to handle */
  #define DONE -2			/**< Module has served the response completely 
  				 *  - it's safe to die() with no more output
  				 */
! #define SUSPENDED -3 /**< Module will handle the remainder of the request. 
!                       * The core will never invoke the request again, */
  
+ /** Returned by the bottom-most filter if no data was written.
+  *  @see ap_pass_brigade(). */
+ #define AP_NOBODY_WROTE         -100
+ /** Returned by the bottom-most filter if no data was read.
+  *  @see ap_get_brigade(). */
+ #define AP_NOBODY_READ          -101
+ /** Returned by any filter if the filter chain encounters an error
+  *  and has already dealt with the error response.
+  */
+ #define AP_FILTER_ERROR         -102
  
  /**
   * @defgroup HTTP_Status HTTP Status Codes
*************** struct request_rec {
*** 942,948 ****
  
      /** The URI without any parsing performed */
      char *unparsed_uri;	
!     /** The path portion of the URI, or "/" if no path provided */
      char *uri;
      /** The filename on disk corresponding to this response */
      char *filename;
--- 921,927 ----
  
      /** The URI without any parsing performed */
      char *unparsed_uri;	
!     /** The path portion of the URI */
      char *uri;
      /** The filename on disk corresponding to this response */
      char *filename;
*************** struct request_rec {
*** 1001,1006 ****
--- 980,992 ----
      /** A flag to determine if the eos bucket has been sent yet */
      int eos_sent;
  
+     /** The optional kept body of the request. */
+     apr_bucket_brigade *kept_body;
+ 
+     apr_thread_mutex_t *invoke_mtx;
+ 
+     apr_table_t *body_table;
+ 
  /* Things placed at the end of the record to avoid breaking binary
   * compatibility.  It would be nice to remember to reorder the entire
   * record to improve 64bit alignment the next time we need to break
*************** struct conn_rec {
*** 1100,1110 ****
      conn_state_t *cs;
      /** Is there data pending in the input filters? */ 
      int data_in_input_filters;
!     
      /** Are there any filters that clogg/buffer the input stream, breaking
       *  the event mpm.
       */
      int clogging_input_filters;
  };
  
  /** 
--- 1086,1107 ----
      conn_state_t *cs;
      /** Is there data pending in the input filters? */ 
      int data_in_input_filters;
!     /** Is there data pending in the output filters? */
!     int data_in_output_filters;
! 
      /** Are there any filters that clogg/buffer the input stream, breaking
       *  the event mpm.
       */
      int clogging_input_filters;
+     
+     /** This points to the current thread being used to process this request,
+      * over the lifetime of a request, the value may change. Users of the connection
+      * record should not rely upon it staying the same between calls that invole
+      * the MPM.
+      */
+ #if APR_HAS_THREADS
+     apr_thread_t *current_thread;
+ #endif
  };
  
  /** 
*************** struct conn_rec {
*** 1113,1118 ****
--- 1110,1118 ----
  typedef enum  {
      CONN_STATE_CHECK_REQUEST_LINE_READABLE,
      CONN_STATE_READ_REQUEST_LINE,
+     CONN_STATE_HANDLER,
+     CONN_STATE_WRITE_COMPLETION,
+     CONN_STATE_SUSPENDED,
      CONN_STATE_LINGER
  } conn_state_e;
  
*************** struct server_rec {
*** 1235,1248 ****
  
      /** The server request scheme for redirect responses */
      const char *server_scheme;
  };
  
  typedef struct core_output_filter_ctx {
!     apr_bucket_brigade *b;
!     /** subpool of c->pool used for resources 
!      * which may outlive the request
!      */
!     apr_pool_t *deferred_write_pool;
  } core_output_filter_ctx_t;
   
  typedef struct core_filter_ctx {
--- 1235,1250 ----
  
      /** The server request scheme for redirect responses */
      const char *server_scheme;
+ 
+     /** Opaque storage location */
+     void *context;
  };
  
  typedef struct core_output_filter_ctx {
!     apr_bucket_brigade *buffered_bb;
!     apr_size_t bytes_in;
!     apr_size_t bytes_written;
!     apr_bucket_brigade *tmp_flush_bb;
  } core_output_filter_ctx_t;
   
  typedef struct core_filter_ctx {
*************** AP_DECLARE(int) ap_find_last_token(apr_p
*** 1443,1468 ****
  AP_DECLARE(int) ap_is_url(const char *u);
  
  /**
!  * Unescape a URL
!  * @param url The url to unescape
   * @return 0 on success, non-zero otherwise
   */
! AP_DECLARE(int) ap_unescape_url(char *url);
  
  /**
!  * Unescape a URL, including encoded slashes.
   * @param url The url to unescape
   * @return 0 on success, non-zero otherwise
   */
! AP_DECLARE(int) ap_unescape_url_keep2f(char *url);
  
  /**
!  * Unescape a URL, including encoded slashes.
   * @param url The url to unescape
-  * @param decode_slashes Whether or not slashes should be decoded or not
   * @return 0 on success, non-zero otherwise
   */
! AP_DECLARE(int) ap_unescape_url_keep2f_ex(char *url, int decode_slashes);
  
  /**
   * Convert all double slashes to single slashes
--- 1445,1469 ----
  AP_DECLARE(int) ap_is_url(const char *u);
  
  /**
!  * Unescape a string
!  * @param url The string to unescape
   * @return 0 on success, non-zero otherwise
   */
! AP_DECLARE(int) ap_unescape_all(char *url);
  
  /**
!  * Unescape a URL
   * @param url The url to unescape
   * @return 0 on success, non-zero otherwise
   */
! AP_DECLARE(int) ap_unescape_url(char *url);
  
  /**
!  * Unescape a URL, but leaving %2f (slashes) escaped
   * @param url The url to unescape
   * @return 0 on success, non-zero otherwise
   */
! AP_DECLARE(int) ap_unescape_url_keep2f(char *url);
  
  /**
   * Convert all double slashes to single slashes
*************** AP_DECLARE(void) ap_getparents(char *nam
*** 1486,1491 ****
--- 1487,1500 ----
  AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *s);
  
  /**
+  * Escape a path segment, as defined in RFC 1808, to a preallocated buffer.
+  * @param c The preallocated buffer to write to
+  * @param s The path to convert
+  * @return The converted URL (c)
+  */
+ AP_DECLARE(char *) ap_escape_path_segment_buffer(char *c, const char *s);
+ 
+ /**
   * convert an OS path to a URL in an OS dependant way.
   * @param p The pool to allocate from
   * @param path The path to convert
*************** AP_DECLARE(char *) ap_os_escape_path(apr
*** 1504,1515 ****
   * @param s The html to escape
   * @return The escaped string
   */
! AP_DECLARE(char *) ap_escape_html(apr_pool_t *p, const char *s);
  /**
   * Escape an html string
   * @param p The pool to allocate from
   * @param s The html to escape
!  * @param toasc Whether to escape all non-ASCII chars to &#nnn;
   * @return The escaped string
   */
  AP_DECLARE(char *) ap_escape_html2(apr_pool_t *p, const char *s, int toasc);
--- 1513,1524 ----
   * @param s The html to escape
   * @return The escaped string
   */
! #define ap_escape_html(p,s) ap_escape_html2(p,s,0)
  /**
   * Escape an html string
   * @param p The pool to allocate from
   * @param s The html to escape
!  * @param toasc Whether to escape all non-ASCII chars to \&\#nnn;
   * @return The escaped string
   */
  AP_DECLARE(char *) ap_escape_html2(apr_pool_t *p, const char *s, int toasc);
*************** AP_DECLARE(char *) ap_make_dirstr_parent
*** 1582,1588 ****
  
  /**
   * Given a directory and filename, create a single path from them.  This
!  * function is smart enough to ensure that there is a single '/' between the
   * directory and file names
   * @param a The pool to allocate from
   * @param dir The directory name
--- 1591,1597 ----
  
  /**
   * Given a directory and filename, create a single path from them.  This
!  * function is smart enough to ensure that there is a sinlge '/' between the
   * directory and file names
   * @param a The pool to allocate from
   * @param dir The directory name
*************** AP_DECLARE(int) ap_ind(const char *str,
*** 1732,1740 ****
  AP_DECLARE(int) ap_rind(const char *str, char c);
  
  /**
!  * Given a string, replace any bare " with \" .
   * @param p The pool to allocate memory from
!  * @param instring The string to search for "
   * @return A copy of the string with escaped quotes 
   */
  AP_DECLARE(char *) ap_escape_quotes(apr_pool_t *p, const char *instring);
--- 1741,1749 ----
  AP_DECLARE(int) ap_rind(const char *str, char c);
  
  /**
!  * Given a string, replace any bare &quot; with \\&quot; .
   * @param p The pool to allocate memory from
!  * @param instring The string to search for &quot;
   * @return A copy of the string with escaped quotes 
   */
  AP_DECLARE(char *) ap_escape_quotes(apr_pool_t *p, const char *instring);
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/http_log.h /tmp/patch.inc.get2.9J0UCU/include/http_log.h
*** /tmp/patch.inc.get1.AvnxJA/include/http_log.h	2013-04-28 19:22:12.347306069 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/http_log.h	2013-04-28 19:22:13.455311562 +0200
*************** AP_DECLARE(apr_status_t) ap_replace_stde
*** 121,128 ****
  int ap_open_logs(apr_pool_t *pconf, apr_pool_t *plog, 
                   apr_pool_t *ptemp, server_rec *s_main);
  
- #ifdef CORE_PRIVATE
- 
  /**
   * Perform special processing for piped loggers in MPM child
   * processes.
--- 121,126 ----
*************** int ap_open_logs(apr_pool_t *pconf, apr_
*** 133,140 ****
   */
  void ap_logs_child_init(apr_pool_t *p, server_rec *s);
  
- #endif /* CORE_PRIVATE */
- 
  /* 
   * The primary logging functions, ap_log_error, ap_log_rerror, ap_log_cerror,
   * and ap_log_perror use a printf style format string to build the log message.  
--- 131,136 ----
*************** AP_DECLARE(apr_status_t) ap_read_pid(apr
*** 272,305 ****
  typedef struct piped_log piped_log;
  
  /**
-  * @brief The piped logging structure.  
-  *
-  * Piped logs are used to move functionality out of the main server.  
-  * For example, log rotation is done with piped logs.
-  */
- struct piped_log {
-     /** The pool to use for the piped log */
-     apr_pool_t *p;
-     /** The pipe between the server and the logging process */
-     apr_file_t *fds[2];
-     /* XXX - an #ifdef that needs to be eliminated from public view. Shouldn't
-      * be hard */
- #ifdef AP_HAVE_RELIABLE_PIPED_LOGS
-     /** The name of the program the logging process is running */
-     char *program;
-     /** The pid of the logging process */
-     apr_proc_t *pid;
-     /** How to reinvoke program when it must be replaced */
-     apr_cmdtype_e cmdtype;
- #endif
- };
- 
- /**
   * Open the piped log process
   * @param p The pool to allocate out of
   * @param program The program to run in the logging process
   * @return The piped log structure
!  * @tip The log program is invoked as APR_SHELLCMD_ENV, 
   *      @see ap_open_piped_log_ex to modify this behavior
   */
  AP_DECLARE(piped_log *) ap_open_piped_log(apr_pool_t *p, const char *program);
--- 268,278 ----
  typedef struct piped_log piped_log;
  
  /**
   * Open the piped log process
   * @param p The pool to allocate out of
   * @param program The program to run in the logging process
   * @return The piped log structure
!  * @note The log program is invoked as @p APR_PROGRAM_ENV, 
   *      @see ap_open_piped_log_ex to modify this behavior
   */
  AP_DECLARE(piped_log *) ap_open_piped_log(apr_pool_t *p, const char *program);
*************** AP_DECLARE(piped_log *) ap_open_piped_lo
*** 322,339 ****
  AP_DECLARE(void) ap_close_piped_log(piped_log *pl);
  
  /**
!  * A macro to access the read side of the piped log pipe
   * @param pl The piped log structure
   * @return The native file descriptor
   */
! #define ap_piped_log_read_fd(pl)	((pl)->fds[0])
  
  /**
!  * A macro to access the write side of the piped log pipe
   * @param pl The piped log structure
   * @return The native file descriptor
   */
! #define ap_piped_log_write_fd(pl)	((pl)->fds[1])
  
  /**
   * hook method to log error messages 
--- 295,312 ----
  AP_DECLARE(void) ap_close_piped_log(piped_log *pl);
  
  /**
!  * A function to return the read side of the piped log pipe
   * @param pl The piped log structure
   * @return The native file descriptor
   */
! AP_DECLARE(apr_file_t *) ap_piped_log_read_fd(piped_log *pl);
  
  /**
!  * A function to return the write side of the piped log pipe
   * @param pl The piped log structure
   * @return The native file descriptor
   */
! AP_DECLARE(apr_file_t *) ap_piped_log_write_fd(piped_log *pl);
  
  /**
   * hook method to log error messages 
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/http_main.h /tmp/patch.inc.get2.9J0UCU/include/http_main.h
*** /tmp/patch.inc.get1.AvnxJA/include/http_main.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/http_main.h	2013-04-28 19:22:13.455311562 +0200
***************
*** 26,38 ****
  #ifndef APACHE_HTTP_MAIN_H
  #define APACHE_HTTP_MAIN_H
  
  #include "apr_optional.h"
  
  /** AP_SERVER_BASEARGS is the command argument list parsed by http_main.c
   * in apr_getopt() format.  Use this for default'ing args that the MPM
   * can safely ignore and pass on from its rewrite_args() handler.
   */
! #define AP_SERVER_BASEARGS "C:c:D:d:E:e:f:vVlLtTSMh?X"
  
  #ifdef __cplusplus
  extern "C" {
--- 26,39 ----
  #ifndef APACHE_HTTP_MAIN_H
  #define APACHE_HTTP_MAIN_H
  
+ #include "httpd.h"
  #include "apr_optional.h"
  
  /** AP_SERVER_BASEARGS is the command argument list parsed by http_main.c
   * in apr_getopt() format.  Use this for default'ing args that the MPM
   * can safely ignore and pass on from its rewrite_args() handler.
   */
! #define AP_SERVER_BASEARGS "C:c:D:d:E:e:f:vVlLtSMh?X"
  
  #ifdef __cplusplus
  extern "C" {
*************** extern "C" {
*** 42,47 ****
--- 43,52 ----
  AP_DECLARE_DATA extern const char *ap_server_argv0;
  /** The global server's ServerRoot */
  AP_DECLARE_DATA extern const char *ap_server_root;
+ /** The global server's server_rec */
+ AP_DECLARE_DATA extern server_rec *ap_server_conf;
+ /** global pool, for access prior to creation of server_rec */
+ AP_DECLARE_DATA extern apr_pool_t *ap_pglobal;
  
  /* for -C, -c and -D switches */
  /** An array of all -C directives.  These are processed before the server's
*************** AP_DECLARE_DATA extern apr_array_header_
*** 53,69 ****
  /** An array of all -D defines on the command line.  This allows people to
   *  effect the server based on command line options */
  AP_DECLARE_DATA extern apr_array_header_t *ap_server_config_defines;
- /** Available integer for using the -T switch */
- AP_DECLARE_DATA extern int ap_document_root_check;
  
  /**
   * An optional function to send signal to server on presence of '-k'
   * command line argument.
-  * Called if MPM defines AP_MPM_WANT_SIGNAL_SERVER
   * @param status The exit status after sending signal
   * @param pool Memory pool to allocate from
   */
! APR_DECLARE_OPTIONAL_FN(int, ap_signal_server, (int *, apr_pool_t *));
  
  #ifdef __cplusplus
  }
--- 58,71 ----
  /** An array of all -D defines on the command line.  This allows people to
   *  effect the server based on command line options */
  AP_DECLARE_DATA extern apr_array_header_t *ap_server_config_defines;
  
  /**
   * An optional function to send signal to server on presence of '-k'
   * command line argument.
   * @param status The exit status after sending signal
   * @param pool Memory pool to allocate from
   */
! APR_DECLARE_OPTIONAL_FN(int, ap_signal_server, (int *status, apr_pool_t *pool));
  
  #ifdef __cplusplus
  }
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/http_protocol.h /tmp/patch.inc.get2.9J0UCU/include/http_protocol.h
*** /tmp/patch.inc.get1.AvnxJA/include/http_protocol.h	2013-04-28 19:22:12.347306069 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/http_protocol.h	2013-04-28 19:22:13.455311562 +0200
*************** AP_DECLARE(apr_time_t) ap_rationalize_mt
*** 129,135 ****
  /**
   * Build the content-type that should be sent to the client from the
   * content-type specified.  The following rules are followed:
!  *    - if type is NULL, type is set to ap_default_type(r)
   *    - if charset adding is disabled, stop processing and return type.
   *    - then, if there are no parameters on type, add the default charset
   *    - return type
--- 129,135 ----
  /**
   * Build the content-type that should be sent to the client from the
   * content-type specified.  The following rules are followed:
!  *    - if type is NULL or "", return NULL (do not set content-type).
   *    - if charset adding is disabled, stop processing and return type.
   *    - then, if there are no parameters on type, add the default charset
   *    - return type
*************** AP_DECLARE(apr_time_t) ap_rationalize_mt
*** 140,152 ****
  AP_DECLARE(const char *) ap_make_content_type(request_rec *r,
                                                const char *type);
  
- #ifdef CORE_PRIVATE
  /**
   * Precompile metadata structures used by ap_make_content_type()
   * @param pool The pool to use for allocations
   */
  AP_DECLARE(void) ap_setup_make_content_type(apr_pool_t *pool);
- #endif /* CORE_PRIVATE */
  
  /**
   * Construct an entity tag from the resource information.  If it's a real
--- 140,150 ----
*************** AP_DECLARE(void) ap_copy_method_list(ap_
*** 267,273 ****
   * return true if found.
   *
   * @param   method  String containing the name of the method to check.
!  * @param   l       Pointer to a method list, such as cmd->methods_limited.
   * @return  1 if method is in the list, otherwise 0
   */
  AP_DECLARE(int) ap_method_in_list(ap_method_list_t *l, const char *method);
--- 265,271 ----
   * return true if found.
   *
   * @param   method  String containing the name of the method to check.
!  * @param   l       Pointer to a method list, such as r->allowed_methods.
   * @return  1 if method is in the list, otherwise 0
   */
  AP_DECLARE(int) ap_method_in_list(ap_method_list_t *l, const char *method);
*************** AP_DECLARE(int) ap_method_in_list(ap_met
*** 277,283 ****
   * already listed.
   *
   * @param   method  String containing the name of the method to check.
!  * @param   l       Pointer to a method list, such as cmd->methods_limited.
   * @return  None.
   */
  AP_DECLARE(void) ap_method_list_add(ap_method_list_t *l, const char *method);
--- 275,281 ----
   * already listed.
   *
   * @param   method  String containing the name of the method to check.
!  * @param   l       Pointer to a method list, such as r->allowed_methods.
   * @return  None.
   */
  AP_DECLARE(void) ap_method_list_add(ap_method_list_t *l, const char *method);
*************** AP_DECLARE(void) ap_method_list_add(ap_m
*** 285,291 ****
  /**
   * Remove an HTTP method name from an ap_method_list_t structure.
   *
!  * @param   l       Pointer to a method list, such as cmd->methods_limited.
   * @param   method  String containing the name of the method to remove.
   * @return  None.
   */
--- 283,289 ----
  /**
   * Remove an HTTP method name from an ap_method_list_t structure.
   *
!  * @param   l       Pointer to a method list, such as r->allowed_methods.
   * @param   method  String containing the name of the method to remove.
   * @return  None.
   */
*************** AP_DECLARE(void) ap_method_list_remove(a
*** 295,301 ****
  /**
   * Reset a method list to be completely empty.
   *
!  * @param   l       Pointer to a method list, such as cmd->methods_limited.
   * @return  None.
   */
  AP_DECLARE(void) ap_clear_method_list(ap_method_list_t *l);
--- 293,299 ----
  /**
   * Reset a method list to be completely empty.
   *
!  * @param   l       Pointer to a method list, such as r->allowed_methods.
   * @return  None.
   */
  AP_DECLARE(void) ap_clear_method_list(ap_method_list_t *l);
*************** AP_DECLARE(void) ap_clear_method_list(ap
*** 309,321 ****
   */
  AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct);
  
- /**
-  * Set the Accept-Ranges header for this response
-  * @param r The current request
-  */
- AP_DECLARE(void) ap_set_accept_ranges(request_rec *r);
- 
- 
  /* Hmmm... could macrofy these for now, and maybe forever, though the
   * definitions of the macros would get a whole lot hairier.
   */
--- 307,312 ----
*************** AP_DECLARE_NONSTD(int) ap_rprintf(reques
*** 375,381 ****
  /**
   * Flush all of the data for the current request to the client
   * @param r The current request
!  * @return 0 on success, -1 if an error occurred
   */
  AP_DECLARE(int) ap_rflush(request_rec *r);
  
--- 366,372 ----
  /**
   * Flush all of the data for the current request to the client
   * @param r The current request
!  * @return The number of bytes sent
   */
  AP_DECLARE(int) ap_rflush(request_rec *r);
  
*************** AP_DECLARE(void) ap_finalize_sub_req_pro
*** 678,684 ****
   * @param send_headers Whether to send&clear headers in r->headers_out
   */
  AP_DECLARE(void) ap_send_interim_response(request_rec *r, int send_headers);
!                                                                                 
  #ifdef __cplusplus
  }
  #endif
--- 669,675 ----
   * @param send_headers Whether to send&clear headers in r->headers_out
   */
  AP_DECLARE(void) ap_send_interim_response(request_rec *r, int send_headers);
! 
  #ifdef __cplusplus
  }
  #endif
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/http_request.h /tmp/patch.inc.get2.9J0UCU/include/http_request.h
*** /tmp/patch.inc.get1.AvnxJA/include/http_request.h	2013-04-28 19:22:12.347306069 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/http_request.h	2013-04-28 19:22:13.463311601 +0200
***************
*** 18,23 ****
--- 18,29 ----
   * @file http_request.h
   * @brief Apache Request library
   *
+  * @defgroup APACHE_CORE_REQ Apache Request Processing
+  * @ingroup  APACHE_CORE
+  * @{
+  */
+ 
+ /*
   * request.c is the code which handles the main line of request
   * processing, once a request has been read in (finding the right per-
   * directory configuration, building it if necessary, and calling all
***************
*** 42,47 ****
--- 48,54 ----
  #define APACHE_HTTP_REQUEST_H
  
  #include "apr_hooks.h"
+ #include "apr_optional.h"
  #include "util_filter.h"
  
  #ifdef __cplusplus
*************** AP_DECLARE(void) ap_internal_fast_redire
*** 181,187 ****
   * @return 1 if authentication is required, 0 otherwise
   */
  AP_DECLARE(int) ap_some_auth_required(request_rec *r);
!  
  /**
   * Determine if the current request is the main request or a subrequest
   * @param r The current request
--- 188,260 ----
   * @return 1 if authentication is required, 0 otherwise
   */
  AP_DECLARE(int) ap_some_auth_required(request_rec *r);
! 
! /**
!  * @defgroup APACHE_CORE_REQ_AUTH Access Control for Sub-Requests and
!  *                                Internal Redirects
!  * @ingroup  APACHE_CORE_REQ
!  * @{
!  */
! 
! #define AP_AUTH_INTERNAL_PER_URI  0  /**< Run access control hooks on all
!                                           internal requests with URIs
!                                           distinct from that of initial
!                                           request */
! #define AP_AUTH_INTERNAL_PER_CONF 1  /**< Run access control hooks only on
!                                           internal requests with
!                                           configurations distinct from
!                                           that of initial request */
! #define AP_AUTH_INTERNAL_MASK     0x000F  /**< mask to extract internal request
!                                                processing mode */
! 
! /**
!  * Clear flag which determines when access control hooks will be run for
!  * internal requests.
!  */
! AP_DECLARE(void) ap_clear_auth_internal(void);
! 
! /**
!  * Determine whether access control hooks will be run for all internal
!  * requests with URIs distinct from that of the initial request, or only
!  * those for which different configurations apply than those which applied
!  * to the initial request.  To accomodate legacy external modules which
!  * may expect access control hooks to be run for all internal requests
!  * with distinct URIs, this is the default behaviour unless all access
!  * control hooks and authentication and authorization providers are
!  * registered with AP_AUTH_INTERNAL_PER_CONF.
!  * @param ptemp Pool used for temporary allocations
!  */
! AP_DECLARE(void) ap_setup_auth_internal(apr_pool_t *ptemp);
! 
! /**
!  * Register an authentication or authorization provider with the global
!  * provider pool.
!  * @param pool The pool to create any storage from
!  * @param provider_group The group to store the provider in
!  * @param provider_name The name for this provider
!  * @param provider_version The version for this provider
!  * @param provider Opaque structure for this provider
!  * @param type Internal request processing mode, either
!  *             AP_AUTH_INTERNAL_PER_URI or AP_AUTH_INTERNAL_PER_CONF
!  * @return APR_SUCCESS if all went well
!  */
! AP_DECLARE(apr_status_t) ap_register_auth_provider(apr_pool_t *pool,
!                                                    const char *provider_group,
!                                                    const char *provider_name,
!                                                    const char *provider_version,
!                                                    const void *provider,
!                                                    int type);
! 
! /** @} */
! 
! /* Optional functions coming from mod_authn_core and mod_authz_core
!  * that list all registered authn/z providers.
!  */
! APR_DECLARE_OPTIONAL_FN(apr_array_header_t *, authn_ap_list_provider_names,
!                         (apr_pool_t *ptemp));
! APR_DECLARE_OPTIONAL_FN(apr_array_header_t *, authz_ap_list_provider_names,
!                         (apr_pool_t *ptemp));
! 
  /**
   * Determine if the current request is the main request or a subrequest
   * @param r The current request
*************** AP_DECLARE(void) ap_allow_standard_metho
*** 235,246 ****
  #define MERGE_ALLOW 0
  #define REPLACE_ALLOW 1
  
- #ifdef CORE_PRIVATE
  /**
!  * Function called by main.c to handle first-level request 
   * @param r The current request
   */
! void ap_process_request(request_rec *);
  
  /**
   * Kill the current request
--- 308,330 ----
  #define MERGE_ALLOW 0
  #define REPLACE_ALLOW 1
  
  /**
!  * Process a top-level request from a client, and synchronously write
!  * the response to the client
   * @param r The current request
   */
! void ap_process_request(request_rec *r);
! 
! /* For post-processing after a handler has finished with a request. (Commonly used after it was suspended) */
! void ap_process_request_after_handler(request_rec *r);
! 
! /**
!  * Process a top-level request from a client, allowing some or all of
!  * the response to remain buffered in the core output filter for later,
!  * asynchronous write completion
!  * @param r The current request
!  */
! void ap_process_async_request(request_rec *r);
  
  /**
   * Kill the current request
*************** void ap_process_request(request_rec *);
*** 248,254 ****
   * @param r The current request
   */
  AP_DECLARE(void) ap_die(int type, request_rec *r);
- #endif
  
  /* Hooks */
  
--- 332,337 ----
*************** AP_DECLARE_HOOK(int,map_to_storage,(requ
*** 291,301 ****
   * r->ap_auth_type). This hook is only run when Apache determines that
   * authentication/authorization is required for this resource (as determined
   * by the 'Require' directive). It runs after the access_checker hook, and
!  * before the auth_checker hook.
   *
   * @param r The current request
   * @return OK, DECLINED, or HTTP_...
   * @ingroup hooks
   */
  AP_DECLARE_HOOK(int,check_user_id,(request_rec *r))
  
--- 374,386 ----
   * r->ap_auth_type). This hook is only run when Apache determines that
   * authentication/authorization is required for this resource (as determined
   * by the 'Require' directive). It runs after the access_checker hook, and
!  * before the auth_checker hook. This hook should be registered with
!  * ap_hook_check_authn().
   *
   * @param r The current request
   * @return OK, DECLINED, or HTTP_...
   * @ingroup hooks
+  * @see ap_hook_check_authn
   */
  AP_DECLARE_HOOK(int,check_user_id,(request_rec *r))
  
*************** AP_DECLARE_HOOK(int,type_checker,(reques
*** 322,332 ****
   * This hook is used to apply additional access control to this resource.
   * It runs *before* a user is authenticated, so this hook is really to
   * apply additional restrictions independent of a user. It also runs
!  * independent of 'Require' directive usage.
   *
   * @param r the current request
   * @return OK, DECLINED, or HTTP_...
   * @ingroup hooks
   */
  AP_DECLARE_HOOK(int,access_checker,(request_rec *r))
  
--- 407,419 ----
   * This hook is used to apply additional access control to this resource.
   * It runs *before* a user is authenticated, so this hook is really to
   * apply additional restrictions independent of a user. It also runs
!  * independent of 'Require' directive usage. This hook should be registered
!  * with ap_hook_check_access().
   *
   * @param r the current request
   * @return OK, DECLINED, or HTTP_...
   * @ingroup hooks
+  * @see ap_hook_check_access
   */
  AP_DECLARE_HOOK(int,access_checker,(request_rec *r))
  
*************** AP_DECLARE_HOOK(int,access_checker,(requ
*** 335,349 ****
   * is available for the authenticated user (r->user and r->ap_auth_type).
   * It runs after the access_checker and check_user_id hooks. Note that
   * it will *only* be called if Apache determines that access control has
!  * been applied to this resource (through a 'Require' directive).
   *
   * @param r the current request
   * @return OK, DECLINED, or HTTP_...
   * @ingroup hooks
   */
  AP_DECLARE_HOOK(int,auth_checker,(request_rec *r))
  
  /**
   * This hook allows modules to insert filters for the current request
   * @param r the current request
   * @ingroup hooks
--- 422,492 ----
   * is available for the authenticated user (r->user and r->ap_auth_type).
   * It runs after the access_checker and check_user_id hooks. Note that
   * it will *only* be called if Apache determines that access control has
!  * been applied to this resource (through a 'Require' directive). This
!  * hook should be registered with ap_hook_check_authz().
   *
   * @param r the current request
   * @return OK, DECLINED, or HTTP_...
   * @ingroup hooks
+  * @see ap_hook_check_authz
   */
  AP_DECLARE_HOOK(int,auth_checker,(request_rec *r))
  
  /**
+  * Register a hook function that will apply additional access control to
+  * the current request.
+  * @param pf An access_checker hook function
+  * @param aszPre A NULL-terminated array of strings that name modules whose
+  *               hooks should precede this one
+  * @param aszSucc A NULL-terminated array of strings that name modules whose
+  *                hooks should succeed this one
+  * @param nOrder An integer determining order before honouring aszPre and
+  *               aszSucc (for example, HOOK_MIDDLE)
+  * @param type Internal request processing mode, either
+  *             AP_AUTH_INTERNAL_PER_URI or AP_AUTH_INTERNAL_PER_CONF
+  */
+ AP_DECLARE(void) ap_hook_check_access(ap_HOOK_access_checker_t *pf,
+                                       const char * const *aszPre,
+                                       const char * const *aszSucc,
+                                       int nOrder, int type);
+ 
+ /**
+  * Register a hook function that will analyze the request headers,
+  * authenticate the user, and set the user information in the request record.
+  * @param pf A check_user_id hook function
+  * @param aszPre A NULL-terminated array of strings that name modules whose
+  *               hooks should precede this one
+  * @param aszSucc A NULL-terminated array of strings that name modules whose
+  *                hooks should succeed this one
+  * @param nOrder An integer determining order before honouring aszPre and
+  *               aszSucc (for example, HOOK_MIDDLE)
+  * @param type Internal request processing mode, either
+  *             AP_AUTH_INTERNAL_PER_URI or AP_AUTH_INTERNAL_PER_CONF
+  */
+ AP_DECLARE(void) ap_hook_check_authn(ap_HOOK_check_user_id_t *pf,
+                                      const char * const *aszPre,
+                                      const char * const *aszSucc,
+                                      int nOrder, int type);
+ 
+ /**
+  * Register a hook function that determine if the resource being requested
+  * is available for the currently authenticated user.
+  * @param pf An auth_checker hook function
+  * @param aszPre A NULL-terminated array of strings that name modules whose
+  *               hooks should precede this one
+  * @param aszSucc A NULL-terminated array of strings that name modules whose
+  *                hooks should succeed this one
+  * @param nOrder An integer determining order before honouring aszPre and
+  *               aszSucc (for example, HOOK_MIDDLE)
+  * @param type Internal request processing mode, either
+  *             AP_AUTH_INTERNAL_PER_URI or AP_AUTH_INTERNAL_PER_CONF
+  */
+ AP_DECLARE(void) ap_hook_check_authz(ap_HOOK_auth_checker_t *pf,
+                                      const char * const *aszPre,
+                                      const char * const *aszSucc,
+                                      int nOrder, int type);
+ 
+ /**
   * This hook allows modules to insert filters for the current request
   * @param r the current request
   * @ingroup hooks
*************** AP_DECLARE(int) ap_location_walk(request
*** 354,361 ****
--- 497,535 ----
  AP_DECLARE(int) ap_directory_walk(request_rec *r);
  AP_DECLARE(int) ap_file_walk(request_rec *r);
  
+ /** End Of REQUEST (EOR) bucket */
+ AP_DECLARE_DATA extern const apr_bucket_type_t ap_bucket_type_eor;
+ 
+ /**
+  * Determine if a bucket is an End Of REQUEST (EOR) bucket
+  * @param e The bucket to inspect
+  * @return true or false
+  */
+ #define AP_BUCKET_IS_EOR(e)         (e->type == &ap_bucket_type_eor)
+ 
+ /**
+  * Make the bucket passed in an End Of REQUEST (EOR) bucket
+  * @param b The bucket to make into an EOR bucket
+  * @param r The request to destroy when this bucket is destroyed
+  * @return The new bucket, or NULL if allocation failed
+  */
+ AP_DECLARE(apr_bucket *) ap_bucket_eor_make(apr_bucket *b, request_rec *r);
+ 
+ /**
+  * Create a bucket referring to an End Of REQUEST (EOR). This bucket
+  * holds a pointer to the request_rec, so that the request can be
+  * destroyed right after all of the output has been sent to the client.
+  *
+  * @param list The freelist from which this bucket should be allocated
+  * @param r The request to destroy when this bucket is destroyed
+  * @return The new bucket, or NULL if allocation failed
+  */
+ AP_DECLARE(apr_bucket *) ap_bucket_eor_create(apr_bucket_alloc_t *list,
+                                               request_rec *r);
+ 
  #ifdef __cplusplus
  }
  #endif
  
  #endif	/* !APACHE_HTTP_REQUEST_H */
+ /** @} */
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/http_vhost.h /tmp/patch.inc.get2.9J0UCU/include/http_vhost.h
*** /tmp/patch.inc.get1.AvnxJA/include/http_vhost.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/http_vhost.h	2013-04-28 19:22:13.455311562 +0200
*************** const char *ap_parse_vhost_addrs(apr_poo
*** 58,65 ****
   * @param dummy NOT USED
   * @param arg a host of the form "<address>[:port]"
   */
! const char *ap_set_name_virtual_host (cmd_parms *cmd, void *dummy,
! 				      const char *arg);
  
  /**
   * Callback function for every Name Based Virtual Host.
--- 58,66 ----
   * @param dummy NOT USED
   * @param arg a host of the form "<address>[:port]"
   */
! AP_DECLARE_NONSTD(const char *)ap_set_name_virtual_host(cmd_parms *cmd,
!                                                         void *dummy,
!                                                         const char *arg);
  
  /**
   * Callback function for every Name Based Virtual Host.
Only in /tmp/patch.inc.get2.9J0UCU/include: mod_auth.h
Only in /tmp/patch.inc.get2.9J0UCU/include: mod_core.h
Only in /tmp/patch.inc.get2.9J0UCU/include: mod_request.h
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/mpm_common.h /tmp/patch.inc.get2.9J0UCU/include/mpm_common.h
*** /tmp/patch.inc.get1.AvnxJA/include/mpm_common.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/mpm_common.h	2013-04-28 19:22:13.455311562 +0200
***************
*** 38,49 ****
  #define APACHE_MPM_COMMON_H
  
  #include "ap_config.h"
  
  #if APR_HAVE_NETINET_TCP_H
  #include <netinet/tcp.h>    /* for TCP_NODELAY */
  #endif
  
! #include "mpm.h"
  
  #ifdef __cplusplus
  extern "C" {
--- 38,50 ----
  #define APACHE_MPM_COMMON_H
  
  #include "ap_config.h"
+ #include "ap_mpm.h"
  
  #if APR_HAVE_NETINET_TCP_H
  #include <netinet/tcp.h>    /* for TCP_NODELAY */
  #endif
  
! #include "apr_proc_mutex.h"
  
  #ifdef __cplusplus
  extern "C" {
*************** extern "C" {
*** 82,148 ****
  /**
   * Make sure all child processes that have been spawned by the parent process
   * have died.  This includes process registered as "other_children".
-  * @warning This is only defined if the MPM defines 
-  *          AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
   * @param terminate Either 1 or 0.  If 1, send the child processes SIGTERM
   *        each time through the loop.  If 0, give the process time to die
   *        on its own before signalling it.
!  * @tip This function requires that some macros are defined by the MPM: <pre>
!  *  MPM_CHILD_PID -- Get the pid from the specified spot in the scoreboard
!  *  MPM_NOTE_CHILD_KILLED -- Note the child died in the scoreboard
   * </pre>
!  * @tip The MPM child processes which are reclaimed are those listed
   * in the scoreboard as well as those currently registered via
   * ap_register_extra_mpm_process().
   */
- #ifdef AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
  void ap_reclaim_child_processes(int terminate);
- #endif
  
  /**
   * Catch any child processes that have been spawned by the parent process
   * which have exited. This includes processes registered as "other_children".
!  * @warning This is only defined if the MPM defines 
!  *          AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
!  * @tip This function requires that some macros are defined by the MPM: <pre>
!  *  MPM_CHILD_PID -- Get the pid from the specified spot in the scoreboard
!  *  MPM_NOTE_CHILD_KILLED -- Note the child died in the scoreboard
   * </pre>
!  * @tip The MPM child processes which are relieved are those listed
   * in the scoreboard as well as those currently registered via
   * ap_register_extra_mpm_process().
   */
- #ifdef AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
  void ap_relieve_child_processes(void);
- #endif
  
  /**
   * Tell ap_reclaim_child_processes() and ap_relieve_child_processes() about 
   * an MPM child process which has no entry in the scoreboard.
-  * @warning This is only defined if the MPM defines
-  *          AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
   * @param pid The process id of an MPM child process which should be
   * reclaimed when ap_reclaim_child_processes() is called.
!  * @tip If an extra MPM child process terminates prior to calling
   * ap_reclaim_child_processes(), remove it from the list of such processes
   * by calling ap_unregister_extra_mpm_process().
   */
- #ifdef AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
  void ap_register_extra_mpm_process(pid_t pid);
- #endif
  
  /**
   * Unregister an MPM child process which was previously registered by a
   * call to ap_register_extra_mpm_process().
-  * @warning This is only defined if the MPM defines
-  *          AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
   * @param pid The process id of an MPM child process which no longer needs to
   * be reclaimed.
   * @return 1 if the process was found and removed, 0 otherwise
   */
- #ifdef AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
  int ap_unregister_extra_mpm_process(pid_t pid);
- #endif
  
  /**
   * Safely signal an MPM child process, if the process is in the
--- 83,135 ----
  /**
   * Make sure all child processes that have been spawned by the parent process
   * have died.  This includes process registered as "other_children".
   * @param terminate Either 1 or 0.  If 1, send the child processes SIGTERM
   *        each time through the loop.  If 0, give the process time to die
   *        on its own before signalling it.
!  * @note This function requires that a hook is implemented by the MPM: <pre>
!  *  mpm_note_child_killed -- Note the child died in the scoreboard
   * </pre>
!  *
!  * @note The MPM child processes which are reclaimed are those listed
   * in the scoreboard as well as those currently registered via
   * ap_register_extra_mpm_process().
   */
  void ap_reclaim_child_processes(int terminate);
  
  /**
   * Catch any child processes that have been spawned by the parent process
   * which have exited. This includes processes registered as "other_children".
!  *
!  * @note This function requires that a hook is implemented by the MPM: <pre>
!  *  mpm_note_child_killed -- Note the child died in the scoreboard
   * </pre>
!  *
!  * @note The MPM child processes which are relieved are those listed
   * in the scoreboard as well as those currently registered via
   * ap_register_extra_mpm_process().
   */
  void ap_relieve_child_processes(void);
  
  /**
   * Tell ap_reclaim_child_processes() and ap_relieve_child_processes() about 
   * an MPM child process which has no entry in the scoreboard.
   * @param pid The process id of an MPM child process which should be
   * reclaimed when ap_reclaim_child_processes() is called.
!  *
!  * @note If an extra MPM child process terminates prior to calling
   * ap_reclaim_child_processes(), remove it from the list of such processes
   * by calling ap_unregister_extra_mpm_process().
   */
  void ap_register_extra_mpm_process(pid_t pid);
  
  /**
   * Unregister an MPM child process which was previously registered by a
   * call to ap_register_extra_mpm_process().
   * @param pid The process id of an MPM child process which no longer needs to
   * be reclaimed.
   * @return 1 if the process was found and removed, 0 otherwise
   */
  int ap_unregister_extra_mpm_process(pid_t pid);
  
  /**
   * Safely signal an MPM child process, if the process is in the
*************** int ap_unregister_extra_mpm_process(pid_
*** 153,187 ****
   * APR_EINVAL is returned if passed either an invalid (< 1) pid, or if
   * the pid is not in the current process group
   */
- #ifdef AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
  apr_status_t ap_mpm_safe_kill(pid_t pid, int sig);
- #endif
  
  /**
   * Determine if any child process has died.  If no child process died, then
   * this process sleeps for the amount of time specified by the MPM defined
   * macro SCOREBOARD_MAINTENANCE_INTERVAL.
   * @param status The return code if a process has died
   * @param ret The process id of the process that died
   * @param p The pool to allocate out of
   */
- #ifdef AP_MPM_WANT_WAIT_OR_TIMEOUT
  void ap_wait_or_timeout(apr_exit_why_e *status, int *exitcode, apr_proc_t *ret, 
!                         apr_pool_t *p);
! #endif
  
  /**
   * Log why a child died to the error log, if the child died without the
   * parent signalling it.
   * @param pid The child that has died
   * @param status The status returned from ap_wait_or_timeout
   * @return 0 on success, APEXIT_CHILDFATAL if MPM should terminate
   */
- #ifdef AP_MPM_WANT_PROCESS_CHILD_STATUS
  int ap_process_child_status(apr_proc_t *pid, apr_exit_why_e why, int status);
- #endif
  
! #if defined(TCP_NODELAY) && !defined(MPE) && !defined(TPF)
  /**
   * Turn off the nagle algorithm for the specified socket.  The nagle algorithm
   * says that we should delay sending partial packets in the hopes of getting
--- 140,172 ----
   * APR_EINVAL is returned if passed either an invalid (< 1) pid, or if
   * the pid is not in the current process group
   */
  apr_status_t ap_mpm_safe_kill(pid_t pid, int sig);
  
  /**
   * Determine if any child process has died.  If no child process died, then
   * this process sleeps for the amount of time specified by the MPM defined
   * macro SCOREBOARD_MAINTENANCE_INTERVAL.
   * @param status The return code if a process has died
+  * @param exitcode The returned exit status of the child, if a child process 
+  *                 dies, or the signal that caused the child to die.
   * @param ret The process id of the process that died
   * @param p The pool to allocate out of
+  * @param s The server_rec to pass
   */
  void ap_wait_or_timeout(apr_exit_why_e *status, int *exitcode, apr_proc_t *ret, 
!                         apr_pool_t *p, server_rec *s);
  
  /**
   * Log why a child died to the error log, if the child died without the
   * parent signalling it.
   * @param pid The child that has died
+  * @param why The return code of the child process
   * @param status The status returned from ap_wait_or_timeout
   * @return 0 on success, APEXIT_CHILDFATAL if MPM should terminate
   */
  int ap_process_child_status(apr_proc_t *pid, apr_exit_why_e why, int status);
  
! #if defined(TCP_NODELAY)
  /**
   * Turn off the nagle algorithm for the specified socket.  The nagle algorithm
   * says that we should delay sending partial packets in the hopes of getting
*************** void ap_sock_disable_nagle(apr_socket_t
*** 199,205 ****
   * Convert a username to a numeric ID
   * @param name The name to convert
   * @return The user id corresponding to a name
!  * @deffunc uid_t ap_uname2id(const char *name)
   */
  AP_DECLARE(uid_t) ap_uname2id(const char *name);
  #endif
--- 184,190 ----
   * Convert a username to a numeric ID
   * @param name The name to convert
   * @return The user id corresponding to a name
!  * @fn uid_t ap_uname2id(const char *name)
   */
  AP_DECLARE(uid_t) ap_uname2id(const char *name);
  #endif
*************** AP_DECLARE(uid_t) ap_uname2id(const char
*** 209,236 ****
   * Convert a group name to a numeric ID
   * @param name The name to convert
   * @return The group id corresponding to a name
!  * @deffunc gid_t ap_gname2id(const char *name)
   */
  AP_DECLARE(gid_t) ap_gname2id(const char *name);
  #endif
  
- #define AP_MPM_HARD_LIMITS_FILE APACHE_MPM_DIR "/mpm_default.h"
- 
- #ifndef HAVE_INITGROUPS
- /**
-  * The initgroups() function initializes the group access list by reading the
-  * group database /etc/group and using all groups of which user is a member.
-  * The additional group basegid is also added to the list. 
-  * @param name The user name - must be non-NULL
-  * @param basegid The basegid to add
-  * @return returns 0 on success
-  * @fn int initgroups(const char *name, gid_t basegid)
-  */
- int initgroups(const char *name, gid_t basegid);
- #endif
- 
- #ifdef AP_MPM_USES_POD
- 
  typedef struct ap_pod_t ap_pod_t;
  
  struct ap_pod_t {
--- 194,204 ----
   * Convert a group name to a numeric ID
   * @param name The name to convert
   * @return The group id corresponding to a name
!  * @fn gid_t ap_gname2id(const char *name)
   */
  AP_DECLARE(gid_t) ap_gname2id(const char *name);
  #endif
  
  typedef struct ap_pod_t ap_pod_t;
  
  struct ap_pod_t {
*************** struct ap_pod_t {
*** 243,248 ****
--- 211,217 ----
   * Open the pipe-of-death.  The pipe of death is used to tell all child
   * processes that it is time to die gracefully.
   * @param p The pool to use for allocating the pipe
+  * @param pod the pipe-of-death that is created.
   */
  AP_DECLARE(apr_status_t) ap_mpm_pod_open(apr_pool_t *p, ap_pod_t **pod);
  
*************** AP_DECLARE(apr_status_t) ap_mpm_pod_chec
*** 253,276 ****
  
  /**
   * Close the pipe-of-death
   */
  AP_DECLARE(apr_status_t) ap_mpm_pod_close(ap_pod_t *pod);
  
  /**
   * Write data to the pipe-of-death, signalling that one child process
   * should die.
!  * @param p The pool to use when allocating any required structures.
   */
  AP_DECLARE(apr_status_t) ap_mpm_pod_signal(ap_pod_t *pod);
  
  /**
   * Write data to the pipe-of-death, signalling that all child process
   * should die.
!  * @param p The pool to use when allocating any required structures.
   * @param num The number of child processes to kill
   */
  AP_DECLARE(void) ap_mpm_pod_killpg(ap_pod_t *pod, int num);
- #endif
  
  /*
   * These data members are common to all mpms. Each new mpm
--- 222,246 ----
  
  /**
   * Close the pipe-of-death
+  *
+  * @param pod the pipe-of-death to close.
   */
  AP_DECLARE(apr_status_t) ap_mpm_pod_close(ap_pod_t *pod);
  
  /**
   * Write data to the pipe-of-death, signalling that one child process
   * should die.
!  * @param pod the pipe-of-death to write to.
   */
  AP_DECLARE(apr_status_t) ap_mpm_pod_signal(ap_pod_t *pod);
  
  /**
   * Write data to the pipe-of-death, signalling that all child process
   * should die.
!  * @param pod The pipe-of-death to write to.
   * @param num The number of child processes to kill
   */
  AP_DECLARE(void) ap_mpm_pod_killpg(ap_pod_t *pod, int num);
  
  /*
   * These data members are common to all mpms. Each new mpm
*************** AP_DECLARE(void) ap_mpm_pod_killpg(ap_po
*** 283,344 ****
   * The maximum number of requests each child thread or
   * process handles before dying off
   */
- #ifdef AP_MPM_WANT_SET_MAX_REQUESTS
  extern int ap_max_requests_per_child;
  const char *ap_mpm_set_max_requests(cmd_parms *cmd, void *dummy,
                                      const char *arg);
- #endif
  
  /**
   * The filename used to store the process id.
   */
- #ifdef AP_MPM_WANT_SET_PIDFILE
  extern const char *ap_pid_fname;
  const char *ap_mpm_set_pidfile(cmd_parms *cmd, void *dummy,
                                 const char *arg);
- #endif
- 
- /**
-  * The name of lockfile used when Apache needs to lock the accept() call.
-  */
- #ifdef AP_MPM_WANT_SET_LOCKFILE
- extern const char *ap_lock_fname;
- const char *ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
-                                 const char *arg);
- #endif
- 
- /**
-  * The system mutex implementation to use for the accept mutex.
-  */
- #ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
- extern apr_lockmech_e ap_accept_lock_mech;
- extern const char ap_valid_accept_mutex_string[];
- const char *ap_mpm_set_accept_lock_mech(cmd_parms *cmd, void *dummy,
-                                         const char *arg);
- #endif
  
  /*
   * Set the scorboard file.
   */
- #ifdef AP_MPM_WANT_SET_SCOREBOARD
  const char *ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
                                    const char *arg);
- #endif
  
  /*
   * The directory that the server changes directory to dump core.
   */
- #ifdef AP_MPM_WANT_SET_COREDUMPDIR
  extern char ap_coredump_dir[MAX_STRING_LEN];
  extern int ap_coredumpdir_configured;
  const char *ap_mpm_set_coredumpdir(cmd_parms *cmd, void *dummy,
                                     const char *arg);
- #endif
  
  /**
   * Set the timeout period for a graceful shutdown.
   */
- #ifdef AP_MPM_WANT_SET_GRACEFUL_SHUTDOWN
  extern int ap_graceful_shutdown_timeout;
  const char *ap_mpm_set_graceful_shutdown(cmd_parms *cmd, void *dummy,
                                           const char *arg);
--- 253,286 ----
*************** const char *ap_mpm_set_graceful_shutdown
*** 346,382 ****
  AP_INIT_TAKE1("GracefulShutdownTimeout", ap_mpm_set_graceful_shutdown, NULL, \
                RSRC_CONF, "Maximum time in seconds to wait for child "        \
                "processes to complete transactions during shutdown")
- #endif
  
  
- #ifdef AP_MPM_WANT_SIGNAL_SERVER
  int ap_signal_server(int *, apr_pool_t *);
  void ap_mpm_rewrite_args(process_rec *);
- #endif
  
- #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
  extern apr_uint32_t ap_max_mem_free;
  extern const char *ap_mpm_set_max_mem_free(cmd_parms *cmd, void *dummy,
                                             const char *arg);
- #endif
  
- #ifdef AP_MPM_WANT_SET_STACKSIZE
  extern apr_size_t ap_thread_stacksize;
  extern const char *ap_mpm_set_thread_stacksize(cmd_parms *cmd, void *dummy,
                                                 const char *arg);
- #endif
  
- #ifdef AP_MPM_WANT_FATAL_SIGNAL_HANDLER
  extern apr_status_t ap_fatal_signal_setup(server_rec *s, apr_pool_t *pconf);
  extern apr_status_t ap_fatal_signal_child_setup(server_rec *s);
- #endif
  
  #if AP_ENABLE_EXCEPTION_HOOK
  extern const char *ap_mpm_set_exception_hook(cmd_parms *cmd, void *dummy,
                                               const char *arg);
  #endif
  
! AP_DECLARE_HOOK(int,monitor,(apr_pool_t *p))
  
  #ifdef __cplusplus
  }
--- 288,342 ----
  AP_INIT_TAKE1("GracefulShutdownTimeout", ap_mpm_set_graceful_shutdown, NULL, \
                RSRC_CONF, "Maximum time in seconds to wait for child "        \
                "processes to complete transactions during shutdown")
  
  
  int ap_signal_server(int *, apr_pool_t *);
  void ap_mpm_rewrite_args(process_rec *);
  
  extern apr_uint32_t ap_max_mem_free;
  extern const char *ap_mpm_set_max_mem_free(cmd_parms *cmd, void *dummy,
                                             const char *arg);
  
  extern apr_size_t ap_thread_stacksize;
  extern const char *ap_mpm_set_thread_stacksize(cmd_parms *cmd, void *dummy,
                                                 const char *arg);
  
  extern apr_status_t ap_fatal_signal_setup(server_rec *s, apr_pool_t *pconf);
  extern apr_status_t ap_fatal_signal_child_setup(server_rec *s);
  
  #if AP_ENABLE_EXCEPTION_HOOK
  extern const char *ap_mpm_set_exception_hook(cmd_parms *cmd, void *dummy,
                                               const char *arg);
  #endif
  
! AP_DECLARE(apr_status_t) ap_mpm_note_child_killed(int childnum);
! 
! AP_DECLARE_HOOK(int,monitor,(apr_pool_t *p, server_rec *s))
! 
! /* register modules that undertake to manage system security */
! AP_DECLARE(int) ap_sys_privileges_handlers(int inc);
! AP_DECLARE_HOOK(int, drop_privileges, (apr_pool_t * pchild, server_rec * s))
! 
! /* implement the ap_mpm_query() function
!  * The MPM should return OK+APR_ENOTIMPL for any unimplemented query codes;
!  * modules which intercede for specific query codes should DECLINE for others.
!  */
! AP_DECLARE_HOOK(int, mpm_query, (int query_code, int *result, apr_status_t *rv))
! 
! /* child specified by index has been killed */
! AP_DECLARE_HOOK(apr_status_t, mpm_note_child_killed, (int childnum))
! 
! /* register the specified callback */
! AP_DECLARE_HOOK(apr_status_t, mpm_register_timed_callback,
!                 (apr_time_t t, ap_mpm_callback_fn_t *cbfn, void *baton))
! 
! /* get MPM name (e.g., "prefork" or "event") */
! AP_DECLARE_HOOK(const char *,mpm_get_name,(void))
! 
! /* mutex type string for accept mutex, if any; MPMs should use the
!  * same mutex type for ease of configuration
!  */
! #define ap_accept_mutex_type "mpm-accept"
  
  #ifdef __cplusplus
  }
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/scoreboard.h /tmp/patch.inc.get2.9J0UCU/include/scoreboard.h
*** /tmp/patch.inc.get1.AvnxJA/include/scoreboard.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/scoreboard.h	2013-04-28 19:22:13.455311562 +0200
*************** extern "C" {
*** 29,36 ****
  #ifdef HAVE_SYS_TIMES_H
  #include <sys/time.h>
  #include <sys/times.h>
- #elif defined(TPF)
- #include <time.h>
  #endif
  
  #include "ap_config.h"
--- 29,34 ----
*************** typedef enum {
*** 87,104 ****
      SB_SHARED = 2
  } ap_scoreboard_e;
  
- #define SB_WORKING  0  /* The server is busy and the child is useful. */
- #define SB_IDLE_DIE 1  /* The server is idle and the child is superfluous. */
-                        /*   The child should check for this and exit gracefully. */
- 
  /* stuff which is worker specific */
- /***********************WARNING***************************************/
- /* These are things that are used by mod_status. Do not put anything */
- /*   in here that you cannot live without. This structure will not   */
- /*   be available if mod_status is not loaded.                       */
- /*********************************************************************/
  typedef struct worker_score worker_score;
- 
  struct worker_score {
      int thread_num;
  #if APR_HAS_THREADS
--- 85,92 ----
*************** typedef struct {
*** 142,151 ****
  
  /* stuff which the parent generally writes and the children rarely read */
  typedef struct process_score process_score;
! struct process_score{
      pid_t pid;
      ap_generation_t generation;	/* generation of this child */
-     ap_scoreboard_e sb_type;
      int quiescing;          /* the process whose pid is stored above is
                               * going down gracefully
                               */
--- 130,138 ----
  
  /* stuff which the parent generally writes and the children rarely read */
  typedef struct process_score process_score;
! struct process_score {
      pid_t pid;
      ap_generation_t generation;	/* generation of this child */
      int quiescing;          /* the process whose pid is stored above is
                               * going down gracefully
                               */
*************** struct process_score{
*** 153,160 ****
  
  /* stuff which is lb specific */
  typedef struct lb_score lb_score;
! struct lb_score{
!     /* TODO: make a real stuct from this */
      unsigned char data[1024];
  };
  
--- 140,146 ----
  
  /* stuff which is lb specific */
  typedef struct lb_score lb_score;
! struct lb_score {
      unsigned char data[1024];
  };
  
*************** apr_status_t ap_cleanup_scoreboard(void
*** 183,195 ****
  AP_DECLARE(void) ap_create_sb_handle(ap_sb_handle_t **new_sbh, apr_pool_t *p,
                                       int child_num, int thread_num);
      
! int find_child_by_pid(apr_proc_t *pid);
  AP_DECLARE(int) ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r);
  AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num, int thread_num,
                                                      int status, request_rec *r);
! void ap_time_process_request(ap_sb_handle_t *sbh, int status);
  
! AP_DECLARE(worker_score *) ap_get_scoreboard_worker(int x, int y);
  AP_DECLARE(process_score *) ap_get_scoreboard_process(int x);
  AP_DECLARE(global_score *) ap_get_scoreboard_global(void);
  AP_DECLARE(lb_score *) ap_get_scoreboard_lb(int lb_num);
--- 169,184 ----
  AP_DECLARE(void) ap_create_sb_handle(ap_sb_handle_t **new_sbh, apr_pool_t *p,
                                       int child_num, int thread_num);
      
! AP_DECLARE(int) ap_find_child_by_pid(apr_proc_t *pid);
  AP_DECLARE(int) ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r);
  AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num, int thread_num,
                                                      int status, request_rec *r);
! AP_DECLARE(int) ap_update_child_status_from_conn(ap_sb_handle_t *sbh, int status, conn_rec *c);
! AP_DECLARE(void) ap_time_process_request(ap_sb_handle_t *sbh, int status);
  
! AP_DECLARE(worker_score *) ap_get_scoreboard_worker(ap_sb_handle_t *sbh);
! AP_DECLARE(worker_score *) ap_get_scoreboard_worker_from_indexes(int child_num,
!                                                                 int thread_num);
  AP_DECLARE(process_score *) ap_get_scoreboard_process(int x);
  AP_DECLARE(global_score *) ap_get_scoreboard_global(void);
  AP_DECLARE(lb_score *) ap_get_scoreboard_lb(int lb_num);
*************** AP_DECLARE_DATA extern const char *ap_sc
*** 199,206 ****
  AP_DECLARE_DATA extern int ap_extended_status;
  AP_DECLARE_DATA extern int ap_mod_status_reqtail;
  
- AP_DECLARE_DATA extern ap_generation_t volatile ap_my_generation;
- 
  /* Hooks */
  /**
    * Hook for post scoreboard creation, pre mpm.
--- 188,193 ----
*************** AP_DECLARE_HOOK(int, pre_mpm, (apr_pool_
*** 217,222 ****
--- 204,215 ----
    */  
  APR_DECLARE_OPTIONAL_FN(int, ap_proxy_lb_workers,
                          (void));
+ /**
+   * proxy load balancer
+   * @return the size of lb_workers.
+   */  
+ APR_DECLARE_OPTIONAL_FN(int, ap_proxy_lb_worker_size,
+                         (void));
  
  /* for time_process_request() in http_main.c */
  #define START_PREQUEST 1
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/util_cfgtree.h /tmp/patch.inc.get2.9J0UCU/include/util_cfgtree.h
*** /tmp/patch.inc.get1.AvnxJA/include/util_cfgtree.h	2013-04-28 19:22:12.347306069 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/util_cfgtree.h	2013-04-28 19:22:13.463311601 +0200
*************** typedef struct ap_directive_t ap_directi
*** 39,47 ****
   *
   * The config tree only stores
   * the directives that will be active in the running server.  Directives
!  * that contain other directions, such as <Directory ...> cause a sub-level
   * to be created, where the included directives are stored.  The closing
!  * directive (</Directory>) is not stored in the tree.
   */
  struct ap_directive_t {
      /** The current directive */
--- 39,47 ----
   *
   * The config tree only stores
   * the directives that will be active in the running server.  Directives
!  * that contain other directions, such as &lt;Directory ...&gt; cause a sub-level
   * to be created, where the included directives are stored.  The closing
!  * directive (&lt;/Directory&gt;) is not stored in the tree.
   */
  struct ap_directive_t {
      /** The current directive */
*************** struct ap_directive_t {
*** 49,62 ****
      /** The arguments for the current directive, stored as a space 
       *  separated list */
      const char *args;
!     /** The next directive node in the tree
!      *  @defvar ap_directive_t *next */
      struct ap_directive_t *next;
!     /** The first child node of this directive 
!      *  @defvar ap_directive_t *first_child */
      struct ap_directive_t *first_child;
!     /** The parent node of this directive 
!      *  @defvar ap_directive_t *parent */
      struct ap_directive_t *parent;
  
      /** directive's module can store add'l data here */
--- 49,59 ----
      /** The arguments for the current directive, stored as a space 
       *  separated list */
      const char *args;
!     /** The next directive node in the tree */
      struct ap_directive_t *next;
!     /** The first child node of this directive */
      struct ap_directive_t *first_child;
!     /** The parent node of this directive */
      struct ap_directive_t *parent;
  
      /** directive's module can store add'l data here */
*************** struct ap_directive_t {
*** 71,77 ****
  
  /**
   * The root of the configuration tree
-  * @defvar ap_directive_t *conftree
   */
  AP_DECLARE_DATA extern ap_directive_t *ap_conftree;
  
--- 68,73 ----
Only in /tmp/patch.inc.get2.9J0UCU/include: util_cookies.h
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/util_filter.h /tmp/patch.inc.get2.9J0UCU/include/util_filter.h
*** /tmp/patch.inc.get1.AvnxJA/include/util_filter.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/util_filter.h	2013-04-28 19:22:13.455311562 +0200
***************
*** 35,49 ****
  extern "C" {
  #endif
  
- /** Returned by the bottom-most filter if no data was written.
-  *  @see ap_pass_brigade(). */
- #define AP_NOBODY_WROTE         -1
- /** Returned by the bottom-most filter if no data was read.
-  *  @see ap_get_brigade(). */
- #define AP_NOBODY_READ          -2
- /** Returned when?? @bug find out when! */
- #define AP_FILTER_ERROR         -3
- 
  /**
   * @brief input filtering modes
   */
--- 35,40 ----
*************** typedef struct ap_filter_t ap_filter_t;
*** 104,111 ****
   * @name Filter callbacks
   *
   * This function type is used for filter callbacks. It will be passed a
!  * pointer to "this" filter, and a "bucket" containing the content to be
!  * filtered.
   *
   * In filter->ctx, the callback will find its context. This context is
   * provided here, so that a filter may be installed multiple times, each
--- 95,102 ----
   * @name Filter callbacks
   *
   * This function type is used for filter callbacks. It will be passed a
!  * pointer to "this" filter, and a "bucket brigade" containing the content
!  * to be filtered.
   *
   * In filter->ctx, the callback will find its context. This context is
   * provided here, so that a filter may be installed multiple times, each
*************** typedef struct ap_filter_t ap_filter_t;
*** 121,130 ****
   * or output filter chains and before any data is generated to allow the
   * filter to prepare for processing.
   *
!  * The *bucket structure (and all those referenced by ->next and ->prev)
!  * should be considered "const". The filter is allowed to modify the
!  * next/prev to insert/remove/replace elements in the bucket list, but
!  * the types and values of the individual buckets should not be altered.
   *
   * For the input and output filters, the return value of a filter should be
   * an APR status value.  For the init function, the return value should
--- 112,126 ----
   * or output filter chains and before any data is generated to allow the
   * filter to prepare for processing.
   *
!  * The bucket brigade always belongs to the caller, but the filter
!  * is free to use the buckets within it as it sees fit. Normally,
!  * the brigade will be returned empty. Buckets *may not* be retained
!  * between successive calls to the filter unless they have been
!  * "set aside" with a call apr_bucket_setaside. Typically this will
!  * be done with ap_save_brigade(). Buckets removed from the brigade
!  * become the responsibility of the filter, which must arrange for
!  * them to be deleted, either by doing so directly or by inserting
!  * them in a brigade which will subsequently be destroyed.
   *
   * For the input and output filters, the return value of a filter should be
   * an APR status value.  For the init function, the return value should
*************** struct ap_filter_rec_t {
*** 221,233 ****
      /** The function to call when this filter is invoked. */
      ap_filter_func filter_func;
  
!     /** The function to call directly before the handlers are invoked
!      * for a request.  The init function is called once directly
!      * before running the handlers for a request or subrequest.  The
!      * init function is never called for a connection filter (with
!      * ftype >= AP_FTYPE_CONNECTION).  Any use of this function for
!      * filters for protocols other than HTTP is specified by the
!      * module supported that protocol.
       */
      ap_init_filter_func filter_init_func;
  
--- 217,226 ----
      /** The function to call when this filter is invoked. */
      ap_filter_func filter_func;
  
!     /** The function to call before the handlers are invoked. Notice
!      * that this function is called only for filters participating in
!      * the http protocol. Filters for other protocols are to be
!      * initialized by the protocols themselves.
       */
      ap_init_filter_func filter_init_func;
  
*************** struct ap_filter_t {
*** 277,283 ****
      request_rec *r;
  
      /** The conn_rec associated with the current filter.  This is analogous
!      *  to the request_rec, except that it is used for input filtering.
       */
      conn_rec *c;
  };
--- 270,276 ----
      request_rec *r;
  
      /** The conn_rec associated with the current filter.  This is analogous
!      *  to the request_rec, except that it is used for connection filters.
       */
      conn_rec *c;
  };
*************** AP_DECLARE(apr_status_t) ap_get_brigade(
*** 305,313 ****
   * Pass the current bucket brigade down to the next filter on the filter
   * stack.  The filter returns an apr_status_t value.  If the bottom-most 
   * filter doesn't write to the network, then ::AP_NOBODY_WROTE is returned.
-  * The caller relinquishes ownership of the brigade.
   * @param filter The next filter in the chain
   * @param bucket The current bucket brigade
   */
  AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,
                                           apr_bucket_brigade *bucket);
--- 298,310 ----
   * Pass the current bucket brigade down to the next filter on the filter
   * stack.  The filter returns an apr_status_t value.  If the bottom-most 
   * filter doesn't write to the network, then ::AP_NOBODY_WROTE is returned.
   * @param filter The next filter in the chain
   * @param bucket The current bucket brigade
+  *
+  * @remark Ownership of the brigade is retained by the caller. On return,
+  *         the contents of the brigade are UNDEFINED, and the caller must
+  *         either call apr_brigade_cleanup or apr_brigade_destroy on
+  *         the brigade.
   */
  AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,
                                           apr_bucket_brigade *bucket);
*************** AP_DECLARE(ap_filter_rec_t *) ap_registe
*** 331,358 ****
                                            ap_init_filter_func filter_init,
                                            ap_filter_type ftype);
  
! /**
!  * This function is used to register an output filter with the system. 
!  * After this registration is performed, then a filter may be added 
!  * into the filter chain by using ap_add_output_filter() and simply 
!  * specifying the name.  It may also be used as a provider under mod_filter.
!  * This is (equivalent to) ap_register_output_filter_protocol with
!  * proto_flags=0, and is retained for back-compatibility with 2.0 modules.
!  *
!  * @param name The name to attach to the filter function
!  * @param filter_func The filter function to name
!  * @param filter_init The function to call before the filter handlers 
!  *                    are invoked
!  * @param ftype The type of filter function, either ::AP_FTYPE_CONTENT or
!  *              ::AP_FTYPE_CONNECTION
!  * @see ap_add_output_filter()
!  */
  AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter(const char *name,
                                              ap_out_filter_func filter_func,
                                              ap_init_filter_func filter_init,
                                              ap_filter_type ftype);
  
! /* For httpd-2.2 I suggest replacing the above with
  #define ap_register_output_filter(name,ffunc,init,ftype) \
               ap_register_output_filter_protocol(name,ffunc,init,ftype,0)
  */
--- 328,340 ----
                                            ap_init_filter_func filter_init,
                                            ap_filter_type ftype);
  
! /** @deprecated @see ap_register_output_filter_protocol */
  AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter(const char *name,
                                              ap_out_filter_func filter_func,
                                              ap_init_filter_func filter_init,
                                              ap_filter_type ftype);
  
! /* For httpd-?.? I suggest replacing the above with
  #define ap_register_output_filter(name,ffunc,init,ftype) \
               ap_register_output_filter_protocol(name,ffunc,init,ftype,0)
  */
*************** AP_DECLARE(ap_filter_rec_t *) ap_registe
*** 360,367 ****
  /**
   * This function is used to register an output filter with the system. 
   * After this registration is performed, then a filter may be added 
!  * into the filter chain by using ap_add_output_filter() and simply 
!  * specifying the name.  It may also be used as a provider under mod_filter.
   *
   * @param name The name to attach to the filter function
   * @param filter_func The filter function to name
--- 342,349 ----
  /**
   * This function is used to register an output filter with the system. 
   * After this registration is performed, then a filter may be added 
!  * directly to the filter chain by using ap_add_output_filter() and
!  * simply specifying the name, or as a provider under mod_filter.
   *
   * @param name The name to attach to the filter function
   * @param filter_func The filter function to name
*************** AP_DECLARE(ap_filter_rec_t *) ap_registe
*** 370,375 ****
--- 352,358 ----
   * @param ftype The type of filter function, either ::AP_FTYPE_CONTENT or
   *              ::AP_FTYPE_CONNECTION
   * @param proto_flags Protocol flags: logical OR of AP_FILTER_PROTO_* bits
+  * @return the filter rec
   * @see ap_add_output_filter()
   */
  AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter_protocol(
*************** AP_DECLARE(ap_filter_rec_t *) ap_get_inp
*** 428,433 ****
--- 411,420 ----
   * @param ctx Context data to set in the filter
   * @param r The request to add this filter for (or NULL if it isn't associated with a request)
   * @param c The connection to add this filter for
+  * @note If adding a connection-level output filter (i.e. where the type
+  * is >= AP_FTYPE_CONNECTION) during processing of a request, the request
+  * object r must be passed in to ensure the filter chains are modified
+  * correctly.  f->r will still be initialized as NULL in the new filter.
   */
  AP_DECLARE(ap_filter_t *) ap_add_output_filter(const char *name, void *ctx, 
                                                 request_rec *r, conn_rec *c);
*************** AP_DECLARE(ap_filter_t *) ap_add_output_
*** 437,444 ****
   * (as returned by ap_register_output_filter()) rather than a filter name
   *
   * @param f The filter handle to add
   * @param r The request to add this filter for (or NULL if it isn't associated with a request)
!  * @param c The connection to add the fillter for
   */
  AP_DECLARE(ap_filter_t *) ap_add_output_filter_handle(ap_filter_rec_t *f,
                                                        void *ctx,
--- 424,436 ----
   * (as returned by ap_register_output_filter()) rather than a filter name
   *
   * @param f The filter handle to add
+  * @param ctx Context data to set in the filter
   * @param r The request to add this filter for (or NULL if it isn't associated with a request)
!  * @param c The connection to add the filter for
!  * @note If adding a connection-level output filter (i.e. where the type
!  * is >= AP_FTYPE_CONNECTION) during processing of a request, the request
!  * object r must be passed in to ensure the filter chains are modified
!  * correctly.  f->r will still be initialized as NULL in the new filter.
   */
  AP_DECLARE(ap_filter_t *) ap_add_output_filter_handle(ap_filter_rec_t *f,
                                                        void *ctx,
*************** AP_DECLARE(apr_status_t) ap_fflush(ap_fi
*** 549,555 ****
   */
  AP_DECLARE_NONSTD(apr_status_t) ap_fputstrs(ap_filter_t *f,
                                              apr_bucket_brigade *bb,
!                                             ...);
  
  /**
   * Output data to the filter in printf format
--- 541,551 ----
   */
  AP_DECLARE_NONSTD(apr_status_t) ap_fputstrs(ap_filter_t *f,
                                              apr_bucket_brigade *bb,
!                                             ...)
! #if defined(__GNUC__) && __GNUC__ >= 4
!     __attribute__((sentinel))
! #endif
! ;
  
  /**
   * Output data to the filter in printf format
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/util_ldap.h /tmp/patch.inc.get2.9J0UCU/include/util_ldap.h
*** /tmp/patch.inc.get1.AvnxJA/include/util_ldap.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/util_ldap.h	2013-04-28 19:22:13.455311562 +0200
***************
*** 29,36 ****
  #include "apr_tables.h"
  #include "apr_time.h"
  #include "apr_ldap.h"
  
! #if defined(LDAP_UNAVAILABLE) || APR_HAS_MICROSOFT_LDAPSDK
  #define AP_LDAP_IS_SERVER_DOWN(s)                ((s) == LDAP_SERVER_DOWN \
                  ||(s) == LDAP_UNAVAILABLE)
  #else
--- 29,37 ----
  #include "apr_tables.h"
  #include "apr_time.h"
  #include "apr_ldap.h"
+ #include "apr_ldap_rebind.h"
  
! #if APR_HAS_MICROSOFT_LDAPSDK
  #define AP_LDAP_IS_SERVER_DOWN(s)                ((s) == LDAP_SERVER_DOWN \
                  ||(s) == LDAP_UNAVAILABLE)
  #else
*************** typedef struct util_ldap_connection_t {
*** 114,121 ****
--- 115,132 ----
      const char *reason;                 /* Reason for an error failure */
  
      struct util_ldap_connection_t *next;
+     struct util_ldap_state_t *st;        /* The LDAP vhost config this connection belongs to */
+     int keep;                            /* Will this connection be kept when it's unlocked */
+ 
+     int ChaseReferrals;                 /* [on|off] (default = AP_LDAP_CHASEREFERRALS_ON)*/
+     int ReferralHopLimit;               /* # of referral hops to follow (default = AP_LDAP_DEFAULT_HOPLIMIT) */
  } util_ldap_connection_t;
  
+ typedef struct util_ldap_config_t {
+     int ChaseReferrals;
+     int ReferralHopLimit;
+ } util_ldap_config_t;
+ 
  /* LDAP cache state information */ 
  typedef struct util_ldap_state_t {
      apr_pool_t *pool;           /* pool from which this state is allocated */
*************** typedef struct util_ldap_state_t {
*** 145,156 ****
  
      /* cache ald */
      void *util_ldap_cache;
-     char *lock_file;           /* filename for shm lock mutex */
      long  connectionTimeout;
      int   verify_svr_cert;
  
  } util_ldap_state_t;
  
  
  /**
   * Open a connection to an LDAP server
--- 156,171 ----
  
      /* cache ald */
      void *util_ldap_cache;
      long  connectionTimeout;
      int   verify_svr_cert;
+     int debug_level;                    /* SDK debug level */
  
  } util_ldap_state_t;
  
+ /* Used to store arrays of attribute labels/values. */
+ struct mod_auth_ldap_groupattr_entry_t {
+     char *name;
+ };
  
  /**
   * Open a connection to an LDAP server
*************** typedef struct util_ldap_state_t {
*** 161,167 ****
   *      connect if already connected (ldc->ldap != NULL). Does not bind
   *      if already bound.
   * @return If successful LDAP_SUCCESS is returned.
!  * @deffunc int util_ldap_connection_open(request_rec *r,
   *                                        util_ldap_connection_t *ldc)
   */
  APR_DECLARE_OPTIONAL_FN(int,uldap_connection_open,(request_rec *r, 
--- 176,182 ----
   *      connect if already connected (ldc->ldap != NULL). Does not bind
   *      if already bound.
   * @return If successful LDAP_SUCCESS is returned.
!  * @fn int util_ldap_connection_open(request_rec *r,
   *                                        util_ldap_connection_t *ldc)
   */
  APR_DECLARE_OPTIONAL_FN(int,uldap_connection_open,(request_rec *r, 
*************** APR_DECLARE_OPTIONAL_FN(int,uldap_connec
*** 174,180 ****
   * @tip This function unbinds from the LDAP server, and clears ldc->ldap.
   *      It is possible to rebind to this server again using the same ldc
   *      structure, using apr_ldap_open_connection().
!  * @deffunc util_ldap_close_connection(util_ldap_connection_t *ldc)
   */
  APR_DECLARE_OPTIONAL_FN(void,uldap_connection_close,(util_ldap_connection_t *ldc));
  
--- 189,195 ----
   * @tip This function unbinds from the LDAP server, and clears ldc->ldap.
   *      It is possible to rebind to this server again using the same ldc
   *      structure, using apr_ldap_open_connection().
!  * @fn util_ldap_close_connection(util_ldap_connection_t *ldc)
   */
  APR_DECLARE_OPTIONAL_FN(void,uldap_connection_close,(util_ldap_connection_t *ldc));
  
*************** APR_DECLARE_OPTIONAL_FN(void,uldap_conne
*** 185,191 ****
   * @tip This function unbinds the LDAP connection, and disconnects from
   *      the server. It is used during error conditions, to bring the LDAP
   *      connection back to a known state.
!  * @deffunc apr_status_t util_ldap_connection_unbind(util_ldap_connection_t *ldc)
   */
  APR_DECLARE_OPTIONAL_FN(apr_status_t,uldap_connection_unbind,(void *param));
  
--- 200,206 ----
   * @tip This function unbinds the LDAP connection, and disconnects from
   *      the server. It is used during error conditions, to bring the LDAP
   *      connection back to a known state.
!  * @fn apr_status_t util_ldap_connection_unbind(util_ldap_connection_t *ldc)
   */
  APR_DECLARE_OPTIONAL_FN(apr_status_t,uldap_connection_unbind,(void *param));
  
*************** APR_DECLARE_OPTIONAL_FN(apr_status_t,uld
*** 193,201 ****
   * Cleanup a connection to an LDAP server
   * @param ldc A structure containing the expanded details of the server
   *            that was connected.
!  * @tip This function is registered with the pool cleanup to close down the
!  *      LDAP connections when the server is finished with them.
!  * @deffunc apr_status_t util_ldap_connection_cleanup(util_ldap_connection_t *ldc)
   */
  APR_DECLARE_OPTIONAL_FN(apr_status_t,uldap_connection_cleanup,(void *param));
  
--- 208,215 ----
   * Cleanup a connection to an LDAP server
   * @param ldc A structure containing the expanded details of the server
   *            that was connected.
!  * @tip This functions unbinds and closes the connection to the LDAP server
!  * @fn apr_status_t util_ldap_connection_cleanup(util_ldap_connection_t *ldc)
   */
  APR_DECLARE_OPTIONAL_FN(apr_status_t,uldap_connection_cleanup,(void *param));
  
*************** APR_DECLARE_OPTIONAL_FN(apr_status_t,uld
*** 212,218 ****
   *      lock that particular connection, so that another thread does not try and
   *      use this connection while it is busy. Once you are finished with a connection,
   *      apr_ldap_connection_close() must be called to release this connection.
!  * @deffunc util_ldap_connection_t *util_ldap_connection_find(request_rec *r, const char *host, int port,
   *                                                           const char *binddn, const char *bindpw, deref_options deref,
   *                                                           int netscapessl, int starttls)
   */
--- 226,232 ----
   *      lock that particular connection, so that another thread does not try and
   *      use this connection while it is busy. Once you are finished with a connection,
   *      apr_ldap_connection_close() must be called to release this connection.
!  * @fn util_ldap_connection_t *util_ldap_connection_find(request_rec *r, const char *host, int port,
   *                                                           const char *binddn, const char *bindpw, deref_options deref,
   *                                                           int netscapessl, int starttls)
   */
*************** APR_DECLARE_OPTIONAL_FN(util_ldap_connec
*** 234,240 ****
   * @tip Two DNs can be equal and still fail a string comparison. Eg "dc=example,dc=com"
   *      and "dc=example, dc=com". Use the compare_dn_on_server unless there are serious
   *      performance issues.
!  * @deffunc int util_ldap_cache_comparedn(request_rec *r, util_ldap_connection_t *ldc,
   *                                        const char *url, const char *dn, const char *reqdn,
   *                                        int compare_dn_on_server)
   */
--- 248,254 ----
   * @tip Two DNs can be equal and still fail a string comparison. Eg "dc=example,dc=com"
   *      and "dc=example, dc=com". Use the compare_dn_on_server unless there are serious
   *      performance issues.
!  * @fn int util_ldap_cache_comparedn(request_rec *r, util_ldap_connection_t *ldc,
   *                                        const char *url, const char *dn, const char *reqdn,
   *                                        int compare_dn_on_server)
   */
*************** APR_DECLARE_OPTIONAL_FN(int,uldap_cache_
*** 251,264 ****
   * @param attrib The attribute within the object we are comparing for.
   * @param value The value of the attribute we are trying to compare for. 
   * @tip Use this function to determine whether an attribute/value pair exists within an
!  *      object. Typically this would be used to determine LDAP group membership.
!  * @deffunc int util_ldap_cache_compare(request_rec *r, util_ldap_connection_t *ldc,
   *                                      const char *url, const char *dn, const char *attrib, const char *value)
   */
  APR_DECLARE_OPTIONAL_FN(int,uldap_cache_compare,(request_rec *r, util_ldap_connection_t *ldc,
                              const char *url, const char *dn, const char *attrib, const char *value));
  
  /**
   * Checks a username/password combination by binding to the LDAP server
   * @param r The request record
   * @param ldc The LDAP connection being used.
--- 265,309 ----
   * @param attrib The attribute within the object we are comparing for.
   * @param value The value of the attribute we are trying to compare for. 
   * @tip Use this function to determine whether an attribute/value pair exists within an
!  *      object. Typically this would be used to determine LDAP top-level group
!  *      membership.
!  * @fn int util_ldap_cache_compare(request_rec *r, util_ldap_connection_t *ldc,
   *                                      const char *url, const char *dn, const char *attrib, const char *value)
   */
  APR_DECLARE_OPTIONAL_FN(int,uldap_cache_compare,(request_rec *r, util_ldap_connection_t *ldc,
                              const char *url, const char *dn, const char *attrib, const char *value));
  
  /**
+  * An LDAP function that checks if the specified user is a member of a subgroup.
+  * @param r The request record
+  * @param ldc The LDAP connection being used.
+  * @param url The URL of the LDAP connection - used for deciding which cache to use.
+  * @param dn The DN of the object in which we find subgroups to search within.
+  * @param attrib The attribute within group objects that identify users.
+  * @param value The user attribute value we are trying to compare for.
+  * @param subgroupAttrs The attributes within group objects that identify subgroups.
+  *                      Array of strings.
+  * @param subgroupclasses The objectClass values used to identify groups (and
+  *                      subgroups). apr_array_header_t *.
+  * @param cur_subgroup_depth Current recursive depth during subgroup processing.
+  * @param max_subgroup_depth Maximum depth of recursion allowed during subgroup
+  *                           processing.
+  * @tip Use this function to determine whether an attribute/value pair exists within a
+  *      starting group object or one of its nested subgroups. Typically this would be
+  *      used to determine LDAP nested group membership.
+  * @deffunc int util_ldap_cache_check_subgroups(request_rec *r, util_ldap_connection_t
+  *                                      *ldc, const char *url, const char *dn,
+  *                                      const char *attrib, const char value,
+  *                                      char **subgroupAttrs, apr_array_header_t
+  *                                      *subgroupclasses, int cur_subgroup_depth, int
+  *                                      max_subgroup_depth )
+  */
+ APR_DECLARE_OPTIONAL_FN(int,uldap_cache_check_subgroups,(request_rec *r, util_ldap_connection_t *ldc,
+                                        const char *url, const char *dn, const char *attrib, const char *value,
+                                        char **subgroupAttrs, apr_array_header_t *subgroupclasses,
+                                        int cur_subgroup_depth, int max_subgroup_depth));
+ 
+ /**
   * Checks a username/password combination by binding to the LDAP server
   * @param r The request record
   * @param ldc The LDAP connection being used.
*************** APR_DECLARE_OPTIONAL_FN(int,uldap_cache_
*** 273,279 ****
   * @param retvals The values corresponding to the attributes requested in the attrs array.
   * @tip The filter supplied will be searched for. If a single entry is returned, an attempt
   *      is made to bind as that user. If this bind succeeds, the user is not validated.
!  * @deffunc int util_ldap_cache_checkuserid(request_rec *r, util_ldap_connection_t *ldc,
   *                                          char *url, const char *basedn, int scope, char **attrs,
   *                                          char *filter, char *bindpw, char **binddn, char ***retvals)
   */
--- 318,324 ----
   * @param retvals The values corresponding to the attributes requested in the attrs array.
   * @tip The filter supplied will be searched for. If a single entry is returned, an attempt
   *      is made to bind as that user. If this bind succeeds, the user is not validated.
!  * @fn int util_ldap_cache_checkuserid(request_rec *r, util_ldap_connection_t *ldc,
   *                                          char *url, const char *basedn, int scope, char **attrs,
   *                                          char *filter, char *bindpw, char **binddn, char ***retvals)
   */
*************** APR_DECLARE_OPTIONAL_FN(int,uldap_cache_
*** 295,301 ****
   * @param retvals The values corresponding to the attributes requested in the attrs array.
   * @tip The filter supplied will be searched for. If a single entry is returned, an attempt
   *      is made to bind as that user. If this bind succeeds, the user is not validated.
!  * @deffunc int util_ldap_cache_getuserdn(request_rec *r, util_ldap_connection_t *ldc,
   *                                          char *url, const char *basedn, int scope, char **attrs,
   *                                          char *filter, char **binddn, char ***retvals)
   */
--- 340,346 ----
   * @param retvals The values corresponding to the attributes requested in the attrs array.
   * @tip The filter supplied will be searched for. If a single entry is returned, an attempt
   *      is made to bind as that user. If this bind succeeds, the user is not validated.
!  * @fn int util_ldap_cache_getuserdn(request_rec *r, util_ldap_connection_t *ldc,
   *                                          char *url, const char *basedn, int scope, char **attrs,
   *                                          char *filter, char **binddn, char ***retvals)
   */
*************** APR_DECLARE_OPTIONAL_FN(int,uldap_cache_
*** 305,311 ****
  
  /**
   * Checks if SSL support is available in mod_ldap
!  * @deffunc int util_ldap_ssl_supported(request_rec *r)
   */
  APR_DECLARE_OPTIONAL_FN(int,uldap_ssl_supported,(request_rec *r));
  
--- 350,356 ----
  
  /**
   * Checks if SSL support is available in mod_ldap
!  * @fn int util_ldap_ssl_supported(request_rec *r)
   */
  APR_DECLARE_OPTIONAL_FN(int,uldap_ssl_supported,(request_rec *r));
  
*************** APR_DECLARE_OPTIONAL_FN(int,uldap_ssl_su
*** 317,323 ****
   * @param reqsize The size of the shared memory segement to request. A size
   *                of zero requests the max size possible from
   *                apr_shmem_init()
!  * @deffunc void util_ldap_cache_init(apr_pool_t *p, util_ldap_state_t *st)
   * @return The status code returned is the status code of the
   *         apr_smmem_init() call. Regardless of the status, the cache
   *         will be set up at least for in-process or in-thread operation.
--- 362,368 ----
   * @param reqsize The size of the shared memory segement to request. A size
   *                of zero requests the max size possible from
   *                apr_shmem_init()
!  * @fn void util_ldap_cache_init(apr_pool_t *p, util_ldap_state_t *st)
   * @return The status code returned is the status code of the
   *         apr_smmem_init() call. Regardless of the status, the cache
   *         will be set up at least for in-process or in-thread operation.
*************** apr_status_t util_ldap_cache_init(apr_po
*** 331,337 ****
   * @param The pool to allocate the returned string from
   * @tip This function returns a string allocated from the provided pool that describes
   *      various stats about the cache.
!  * @deffunc char *util_ald_cache_display(apr_pool_t *pool, util_ldap_state_t *st)
   */
  char *util_ald_cache_display(request_rec *r, util_ldap_state_t *st);
  #ifdef __cplusplus
--- 376,382 ----
   * @param The pool to allocate the returned string from
   * @tip This function returns a string allocated from the provided pool that describes
   *      various stats about the cache.
!  * @fn char *util_ald_cache_display(apr_pool_t *pool, util_ldap_state_t *st)
   */
  char *util_ald_cache_display(request_rec *r, util_ldap_state_t *st);
  #ifdef __cplusplus
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/util_md5.h /tmp/patch.inc.get2.9J0UCU/include/util_md5.h
*** /tmp/patch.inc.get1.AvnxJA/include/util_md5.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/util_md5.h	2013-04-28 19:22:13.455311562 +0200
*************** extern "C" {
*** 37,43 ****
   * @param a Pool to allocate out of
   * @param string String to get the checksum of
   * @return The checksum
!  * @deffunc char *ap_md5(apr_pool_t *a, const unsigned char *string)
   */
  AP_DECLARE(char *) ap_md5(apr_pool_t *a, const unsigned char *string);
  
--- 37,43 ----
   * @param a Pool to allocate out of
   * @param string String to get the checksum of
   * @return The checksum
!  * @fn char *ap_md5(apr_pool_t *a, const unsigned char *string)
   */
  AP_DECLARE(char *) ap_md5(apr_pool_t *a, const unsigned char *string);
  
*************** AP_DECLARE(char *) ap_md5(apr_pool_t *a,
*** 47,53 ****
   * @param buf Buffer to generate checksum for
   * @param len The length of the buffer
   * @return The checksum
!  * @deffunc char *ap_md5_binary(apr_pool_t *a, const unsigned char *buf, int len)
   */
  AP_DECLARE(char *) ap_md5_binary(apr_pool_t *a, const unsigned char *buf, int len);
  
--- 47,53 ----
   * @param buf Buffer to generate checksum for
   * @param len The length of the buffer
   * @return The checksum
!  * @fn char *ap_md5_binary(apr_pool_t *a, const unsigned char *buf, int len)
   */
  AP_DECLARE(char *) ap_md5_binary(apr_pool_t *a, const unsigned char *buf, int len);
  
*************** AP_DECLARE(char *) ap_md5_binary(apr_poo
*** 56,62 ****
   * @param p The pool to allocate out of
   * @param context The context to convert
   * @return The converted encoding
!  * @deffunc char *ap_md5contextTo64(apr_pool_t *p, apr_md5_ctx_t *context)
   */
  AP_DECLARE(char *) ap_md5contextTo64(apr_pool_t *p, apr_md5_ctx_t *context);
  
--- 56,62 ----
   * @param p The pool to allocate out of
   * @param context The context to convert
   * @return The converted encoding
!  * @fn char *ap_md5contextTo64(apr_pool_t *p, apr_md5_ctx_t *context)
   */
  AP_DECLARE(char *) ap_md5contextTo64(apr_pool_t *p, apr_md5_ctx_t *context);
  
*************** AP_DECLARE(char *) ap_md5contextTo64(apr
*** 64,70 ****
   * Create an MD5 Digest for a given file
   * @param p The pool to allocate out of
   * @param infile The file to create the digest for
!  * @deffunc char *ap_md5digest(apr_pool_t *p, apr_file_t *infile)
   */
  AP_DECLARE(char *) ap_md5digest(apr_pool_t *p, apr_file_t *infile);
  
--- 64,70 ----
   * Create an MD5 Digest for a given file
   * @param p The pool to allocate out of
   * @param infile The file to create the digest for
!  * @fn char *ap_md5digest(apr_pool_t *p, apr_file_t *infile)
   */
  AP_DECLARE(char *) ap_md5digest(apr_pool_t *p, apr_file_t *infile);
  
Only in /tmp/patch.inc.get2.9J0UCU/include: util_mutex.h
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/util_script.h /tmp/patch.inc.get2.9J0UCU/include/util_script.h
*** /tmp/patch.inc.get1.AvnxJA/include/util_script.h	2013-04-28 19:22:12.339306024 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/util_script.h	2013-04-28 19:22:13.455311562 +0200
*************** extern "C" {
*** 46,52 ****
   * @param t Apache table of key-value pairs
   * @return An array containing the same key-value pairs suitable for
   *         use with an exec call.
!  * @deffunc char **ap_create_environment(apr_pool_t *p, apr_table_t *t)
   */
  AP_DECLARE(char **) ap_create_environment(apr_pool_t *p, apr_table_t *t);
  
--- 46,52 ----
   * @param t Apache table of key-value pairs
   * @return An array containing the same key-value pairs suitable for
   *         use with an exec call.
!  * @fn char **ap_create_environment(apr_pool_t *p, apr_table_t *t)
   */
  AP_DECLARE(char **) ap_create_environment(apr_pool_t *p, apr_table_t *t);
  
*************** AP_DECLARE(char **) ap_create_environmen
*** 57,63 ****
   * @param uri The uri we are currently parsing
   * @param path_info The current path info
   * @return The length of the path info
!  * @deffunc int ap_find_path_info(const char *uri, const char *path_info)
   */
  AP_DECLARE(int) ap_find_path_info(const char *uri, const char *path_info);
  
--- 57,63 ----
   * @param uri The uri we are currently parsing
   * @param path_info The current path info
   * @return The length of the path info
!  * @fn int ap_find_path_info(const char *uri, const char *path_info)
   */
  AP_DECLARE(int) ap_find_path_info(const char *uri, const char *path_info);
  
*************** AP_DECLARE(int) ap_find_path_info(const
*** 65,78 ****
   * Add CGI environment variables required by HTTP/1.1 to the request's 
   * environment table
   * @param r the current request
!  * @deffunc void ap_add_cgi_vars(request_rec *r)
   */
  AP_DECLARE(void) ap_add_cgi_vars(request_rec *r);
  
  /**
   * Add common CGI environment variables to the requests environment table
   * @param r The current request
!  * @deffunc void ap_add_common_vars(request_rec *r)
   */
  AP_DECLARE(void) ap_add_common_vars(request_rec *r);
  
--- 65,78 ----
   * Add CGI environment variables required by HTTP/1.1 to the request's 
   * environment table
   * @param r the current request
!  * @fn void ap_add_cgi_vars(request_rec *r)
   */
  AP_DECLARE(void) ap_add_cgi_vars(request_rec *r);
  
  /**
   * Add common CGI environment variables to the requests environment table
   * @param r The current request
!  * @fn void ap_add_common_vars(request_rec *r)
   */
  AP_DECLARE(void) ap_add_common_vars(request_rec *r);
  
*************** AP_DECLARE(void) ap_add_common_vars(requ
*** 85,91 ****
   * @param buffer Empty when calling the function.  On output, if there was an
   *               error, the string that cause the error is stored here. 
   * @return HTTP_OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise
!  * @deffunc int ap_scan_script_header_err(request_rec *r, apr_file_t *f, char *buffer)
   */ 
  AP_DECLARE(int) ap_scan_script_header_err(request_rec *r, apr_file_t *f, char *buffer);
  
--- 85,91 ----
   * @param buffer Empty when calling the function.  On output, if there was an
   *               error, the string that cause the error is stored here. 
   * @return HTTP_OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise
!  * @fn int ap_scan_script_header_err(request_rec *r, apr_file_t *f, char *buffer)
   */ 
  AP_DECLARE(int) ap_scan_script_header_err(request_rec *r, apr_file_t *f, char *buffer);
  
*************** AP_DECLARE(int) ap_scan_script_header_er
*** 98,104 ****
   * @param buffer Empty when calling the function.  On output, if there was an
   *               error, the string that cause the error is stored here. 
   * @return HTTP_OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise
!  * @deffunc int ap_scan_script_header_err_brigade(request_rec *r, apr_bucket_brigade *bb, char *buffer)
   */ 
  AP_DECLARE(int) ap_scan_script_header_err_brigade(request_rec *r,
                                                    apr_bucket_brigade *bb,
--- 98,104 ----
   * @param buffer Empty when calling the function.  On output, if there was an
   *               error, the string that cause the error is stored here. 
   * @return HTTP_OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise
!  * @fn int ap_scan_script_header_err_brigade(request_rec *r, apr_bucket_brigade *bb, char *buffer)
   */ 
  AP_DECLARE(int) ap_scan_script_header_err_brigade(request_rec *r,
                                                    apr_bucket_brigade *bb,
*************** AP_DECLARE(int) ap_scan_script_header_er
*** 113,122 ****
   *               error, the string that cause the error is stored here. 
   * @param termch Pointer to the last character parsed.
   * @param termarg Pointer to an int to capture the last argument parsed.
!  * @param args   String arguments to parse consecutively for headers, 
!  *               a NULL argument terminates the list.
   * @return HTTP_OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise
-  * @deffunc int ap_scan_script_header_err_core(request_rec *r, char *buffer, int (*getsfunc)(char *, int, void *), void *getsfunc_data)
   */ 
  AP_DECLARE_NONSTD(int) ap_scan_script_header_err_strs(request_rec *r, 
                                                        char *buffer, 
--- 113,123 ----
   *               error, the string that cause the error is stored here. 
   * @param termch Pointer to the last character parsed.
   * @param termarg Pointer to an int to capture the last argument parsed.
!  * 
!  * The varargs are string arguments to parse consecutively for headers, 
!  * with a NULL argument to terminate the list.
!  *
   * @return HTTP_OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise
   */ 
  AP_DECLARE_NONSTD(int) ap_scan_script_header_err_strs(request_rec *r, 
                                                        char *buffer, 
*************** AP_DECLARE_NONSTD(int) ap_scan_script_he
*** 134,145 ****
                     act like gets()
   * @param getsfunc_data The place to read from
   * @return HTTP_OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise
-  * @deffunc int ap_scan_script_header_err_core(request_rec *r, char *buffer, int (*getsfunc)(char *, int, void *), void *getsfunc_data)
   */ 
  AP_DECLARE(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
  				       int (*getsfunc) (char *, int, void *),
  				       void *getsfunc_data);
  
  #ifdef __cplusplus
  }
  #endif
--- 135,149 ----
                     act like gets()
   * @param getsfunc_data The place to read from
   * @return HTTP_OK on success, HTTP_INTERNAL_SERVER_ERROR otherwise
   */ 
  AP_DECLARE(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
  				       int (*getsfunc) (char *, int, void *),
  				       void *getsfunc_data);
  
+ AP_DECLARE(void) ap_args_to_table(request_rec *r, apr_table_t **table);
+ 
+ AP_DECLARE(apr_status_t) ap_body_to_table(request_rec *r, apr_table_t **table);
+     
  #ifdef __cplusplus
  }
  #endif
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/include/util_xml.h /tmp/patch.inc.get2.9J0UCU/include/util_xml.h
*** /tmp/patch.inc.get1.AvnxJA/include/util_xml.h	2013-04-28 19:22:12.347306069 +0200
--- /tmp/patch.inc.get2.9J0UCU/include/util_xml.h	2013-04-28 19:22:13.463311601 +0200
*************** extern "C" {
*** 39,45 ****
   * @param r The current request
   * @param pdoc The XML post data
   * @return HTTP status code
!  * @deffunc int ap_xml_parse_input(request_rec *r, apr_xml_doc **pdoc)
   */
  AP_DECLARE(int) ap_xml_parse_input(request_rec *r, apr_xml_doc **pdoc);
  
--- 39,45 ----
   * @param r The current request
   * @param pdoc The XML post data
   * @return HTTP status code
!  * @fn int ap_xml_parse_input(request_rec *r, apr_xml_doc **pdoc)
   */
  AP_DECLARE(int) ap_xml_parse_input(request_rec *r, apr_xml_doc **pdoc);
  
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/os/unix/os.h /tmp/patch.inc.get2.9J0UCU/os/unix/os.h
*** /tmp/patch.inc.get1.AvnxJA/os/unix/os.h	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/os/unix/os.h	2013-04-28 19:22:13.551312047 +0200
***************
*** 40,45 ****
--- 40,49 ----
   * parent process. */
  #define AP_NEED_SET_MUTEX_PERMS 1
  
+ /* Define command-line rewriting for this platform, handled by core.
+  */
+ #define AP_PLATFORM_REWRITE_ARGS_HOOK ap_mpm_rewrite_args
+ 
  #ifdef _OSD_POSIX
  pid_t os_fork(const char *user);
  #endif
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/os/unix/unixd.c /tmp/patch.inc.get2.9J0UCU/os/unix/unixd.c
*** /tmp/patch.inc.get1.AvnxJA/os/unix/unixd.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/os/unix/unixd.c	2013-04-28 19:22:13.551312047 +0200
***************
*** 15,21 ****
   */
  
  #include "ap_config.h"
- #define CORE_PRIVATE
  #include "httpd.h"
  #include "http_config.h"
  #include "http_main.h"
--- 15,20 ----
***************
*** 51,284 ****
  #include <sys/prctl.h>
  #endif
  
! unixd_config_rec unixd_config;
  
- /* Set group privileges.
-  *
-  * Note that we use the username as set in the config files, rather than
-  * the lookup of to uid --- the same uid may have multiple passwd entries,
-  * with different sets of groups for each.
-  */
- 
- static int set_group_privs(void)
- {
-     if (!geteuid()) {
-         const char *name;
- 
-         /* Get username if passed as a uid */
- 
-         if (unixd_config.user_name[0] == '#') {
-             struct passwd *ent;
-             uid_t uid = atoi(&unixd_config.user_name[1]);
- 
-             if ((ent = getpwuid(uid)) == NULL) {
-                 ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
-                          "getpwuid: couldn't determine user name from uid %u, "
-                          "you probably need to modify the User directive",
-                          (unsigned)uid);
-                 return -1;
-             }
- 
-             name = ent->pw_name;
-         }
-         else
-             name = unixd_config.user_name;
- 
- #if !defined(OS2) && !defined(TPF)
-         /* OS/2 and TPF don't support groups. */
- 
-         /*
-          * Set the GID before initgroups(), since on some platforms
-          * setgid() is known to zap the group list.
-          */
-         if (setgid(unixd_config.group_id) == -1) {
-             ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
-                         "setgid: unable to set group id to Group %u",
-                         (unsigned)unixd_config.group_id);
-             return -1;
-         }
- 
-         /* Reset `groups' attributes. */
- 
-         if (initgroups(name, unixd_config.group_id) == -1) {
-             ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
-                         "initgroups: unable to set groups for User %s "
-                         "and Group %u", name, (unsigned)unixd_config.group_id);
-             return -1;
-         }
- #endif /* !defined(OS2) && !defined(TPF) */
-     }
-     return 0;
- }
- 
- 
- AP_DECLARE(int) unixd_setup_child(void)
- {
-     if (set_group_privs()) {
-         return -1;
-     }
  
!     if (NULL != unixd_config.chroot_dir) {
!         if (geteuid()) {
!             ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
!                          "Cannot chroot when not started as root");
!             return -1;
!         }
!         if (chdir(unixd_config.chroot_dir) != 0) {
!             ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
!                          "Can't chdir to %s", unixd_config.chroot_dir);
!             return -1;
!         }
!         if (chroot(unixd_config.chroot_dir) != 0) {
!             ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
!                          "Can't chroot to %s", unixd_config.chroot_dir);
!             return -1;
!         }
!         if (chdir("/") != 0) {
!             ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
!                          "Can't chdir to new root");
!             return -1;
!         }
!     }
! 
! #ifdef MPE
!     /* Only try to switch if we're running as MANAGER.SYS */
!     if (geteuid() == 1 && unixd_config.user_id > 1) {
!         GETPRIVMODE();
!         if (setuid(unixd_config.user_id) == -1) {
!             GETUSERMODE();
!             ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
!                         "setuid: unable to change to uid: %ld",
!                         (long) unixd_config.user_id);
!             exit(1);
!         }
!         GETUSERMODE();
!     }
! #else
!     /* Only try to switch if we're running as root */
!     if (!geteuid() && (
! #ifdef _OSD_POSIX
!         os_init_job_environment(NULL, unixd_config.user_name, ap_exists_config_define("DEBUG")) != 0 ||
! #endif
!         setuid(unixd_config.user_id) == -1)) {
!         ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
!                     "setuid: unable to change to uid: %ld",
!                     (long) unixd_config.user_id);
!         return -1;
!     }
! #if defined(HAVE_PRCTL) && defined(PR_SET_DUMPABLE)
!     /* this applies to Linux 2.4+ */
! #ifdef AP_MPM_WANT_SET_COREDUMPDIR
!     if (ap_coredumpdir_configured) {
!         if (prctl(PR_SET_DUMPABLE, 1)) {
!             ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
!                          "set dumpable failed - this child will not coredump"
!                          " after software errors");
!         }
!     }
! #endif
! #endif
! #endif
!     return 0;
! }
! 
! 
! AP_DECLARE(const char *) unixd_set_user(cmd_parms *cmd, void *dummy,
!                                         const char *arg)
! {
!     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
!     if (err != NULL) {
!         return err;
!     }
! 
!     unixd_config.user_name = arg;
!     unixd_config.user_id = ap_uname2id(arg);
! #if !defined (BIG_SECURITY_HOLE) && !defined (OS2)
!     if (unixd_config.user_id == 0) {
!         return "Error:\tApache has not been designed to serve pages while\n"
!                 "\trunning as root.  There are known race conditions that\n"
!                 "\twill allow any local user to read any file on the system.\n"
!                 "\tIf you still desire to serve pages as root then\n"
!                 "\tadd -DBIG_SECURITY_HOLE to the CFLAGS env variable\n"
!                 "\tand then rebuild the server.\n"
!                 "\tIt is strongly suggested that you instead modify the User\n"
!                 "\tdirective in your httpd.conf file to list a non-root\n"
!                 "\tuser.\n";
!     }
! #endif
! 
!     return NULL;
! }
! 
! AP_DECLARE(const char *) unixd_set_group(cmd_parms *cmd, void *dummy,
!                                          const char *arg)
! {
!     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
!     if (err != NULL) {
!         return err;
!     }
! 
!     unixd_config.group_id = ap_gname2id(arg);
! 
!     return NULL;
! }
! AP_DECLARE(const char *) unixd_set_chroot_dir(cmd_parms *cmd, void *dummy,
!                                               const char *arg)
! {
!     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
!     if (err != NULL) {
!         return err;
!     }
!     if (!ap_is_directory(cmd->pool, arg)) {
!         return "ChrootDir must be a valid directory";
!     }
! 
!     unixd_config.chroot_dir = arg;
!     return NULL;
! }
! 
! AP_DECLARE(const char *) unixd_set_suexec(cmd_parms *cmd, void *dummy,
!                                           int arg)
! {
!     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
!     if (err != NULL) {
!         return err;
!     }
! 
!     if (!unixd_config.suexec_enabled && arg) {
!         return "suEXEC isn't supported; check existence, owner, and "
!                "file mode of " SUEXEC_BIN;
!     }
! 
!     unixd_config.suexec_enabled = arg;
!     return NULL;
! }
! 
! AP_DECLARE(void) unixd_pre_config(apr_pool_t *ptemp)
! {
!     apr_finfo_t wrapper;
! 
!     unixd_config.user_name = DEFAULT_USER;
!     unixd_config.user_id = ap_uname2id(DEFAULT_USER);
!     unixd_config.group_id = ap_gname2id(DEFAULT_GROUP);
!     
!     unixd_config.chroot_dir = NULL; /* none */
! 
!     /* Check for suexec */
!     unixd_config.suexec_enabled = 0;
!     if ((apr_stat(&wrapper, SUEXEC_BIN,
!                   APR_FINFO_NORM, ptemp)) != APR_SUCCESS) {
!         return;
!     }
! 
!     if ((wrapper.protection & APR_USETID) && wrapper.user == 0) {
!         unixd_config.suexec_enabled = 1;
!     }
! }
! 
! 
! AP_DECLARE(void) unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
!                            const char *arg, const char * arg2, int type)
  {
  #if (defined(RLIMIT_CPU) || defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_NPROC) || defined(RLIMIT_AS)) && APR_HAVE_STRUCT_RLIMIT && APR_HAVE_GETRLIMIT
      char *str;
--- 50,61 ----
  #include <sys/prctl.h>
  #endif
  
! unixd_config_rec ap_unixd_config;
  
  
! AP_DECLARE(void) ap_unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
!                                      const char *arg,
!                                      const char * arg2, int type)
  {
  #if (defined(RLIMIT_CPU) || defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_NPROC) || defined(RLIMIT_AS)) && APR_HAVE_STRUCT_RLIMIT && APR_HAVE_GETRLIMIT
      char *str;
*************** static apr_status_t ap_unix_create_privi
*** 357,363 ****
      char *execuser, *execgroup;
      const char *argv0;
  
!     if (!unixd_config.suexec_enabled) {
          return apr_proc_create(newproc, progname, args, env, attr, p);
      }
  
--- 134,140 ----
      char *execuser, *execgroup;
      const char *argv0;
  
!     if (!ap_unixd_config.suexec_enabled) {
          return apr_proc_create(newproc, progname, args, env, attr, p);
      }
  
*************** static apr_lockmech_e proc_mutex_mech(ap
*** 445,451 ****
      return APR_LOCK_DEFAULT;
  }
  
! AP_DECLARE(apr_status_t) unixd_set_proc_mutex_perms(apr_proc_mutex_t *pmutex)
  {
      if (!geteuid()) {
          apr_lockmech_e mech = proc_mutex_mech(pmutex);
--- 222,228 ----
      return APR_LOCK_DEFAULT;
  }
  
! AP_DECLARE(apr_status_t) ap_unixd_set_proc_mutex_perms(apr_proc_mutex_t *pmutex)
  {
      if (!geteuid()) {
          apr_lockmech_e mech = proc_mutex_mech(pmutex);
*************** AP_DECLARE(apr_status_t) unixd_set_proc_
*** 466,473 ****
              struct semid_ds buf;
  
              apr_os_proc_mutex_get(&ospmutex, pmutex);
!             buf.sem_perm.uid = unixd_config.user_id;
!             buf.sem_perm.gid = unixd_config.group_id;
              buf.sem_perm.mode = 0600;
              ick.buf = &buf;
              if (semctl(ospmutex.crossproc, 0, IPC_SET, ick) < 0) {
--- 243,250 ----
              struct semid_ds buf;
  
              apr_os_proc_mutex_get(&ospmutex, pmutex);
!             buf.sem_perm.uid = ap_unixd_config.user_id;
!             buf.sem_perm.gid = ap_unixd_config.group_id;
              buf.sem_perm.mode = 0600;
              ick.buf = &buf;
              if (semctl(ospmutex.crossproc, 0, IPC_SET, ick) < 0) {
*************** AP_DECLARE(apr_status_t) unixd_set_proc_
*** 482,488 ****
              const char *lockfile = apr_proc_mutex_lockfile(pmutex);
  
              if (lockfile) {
!                 if (chown(lockfile, unixd_config.user_id,
                            -1 /* no gid change */) < 0) {
                      return errno;
                  }
--- 259,265 ----
              const char *lockfile = apr_proc_mutex_lockfile(pmutex);
  
              if (lockfile) {
!                 if (chown(lockfile, ap_unixd_config.user_id,
                            -1 /* no gid change */) < 0) {
                      return errno;
                  }
*************** AP_DECLARE(apr_status_t) unixd_set_proc_
*** 498,517 ****
      return APR_SUCCESS;
  }
  
! AP_DECLARE(apr_status_t) unixd_set_global_mutex_perms(apr_global_mutex_t *gmutex)
  {
  #if !APR_PROC_MUTEX_IS_GLOBAL
      apr_os_global_mutex_t osgmutex;
      apr_os_global_mutex_get(&osgmutex, gmutex);
!     return unixd_set_proc_mutex_perms(osgmutex.proc_mutex);
  #else  /* APR_PROC_MUTEX_IS_GLOBAL */
      /* In this case, apr_proc_mutex_t and apr_global_mutex_t are the same. */
!     return unixd_set_proc_mutex_perms(gmutex);
  #endif /* APR_PROC_MUTEX_IS_GLOBAL */
  }
  
! AP_DECLARE(apr_status_t) unixd_accept(void **accepted, ap_listen_rec *lr,
!                                         apr_pool_t *ptrans)
  {
      apr_socket_t *csd;
      apr_status_t status;
--- 275,294 ----
      return APR_SUCCESS;
  }
  
! AP_DECLARE(apr_status_t) ap_unixd_set_global_mutex_perms(apr_global_mutex_t *gmutex)
  {
  #if !APR_PROC_MUTEX_IS_GLOBAL
      apr_os_global_mutex_t osgmutex;
      apr_os_global_mutex_get(&osgmutex, gmutex);
!     return ap_unixd_set_proc_mutex_perms(osgmutex.proc_mutex);
  #else  /* APR_PROC_MUTEX_IS_GLOBAL */
      /* In this case, apr_proc_mutex_t and apr_global_mutex_t are the same. */
!     return ap_unixd_set_proc_mutex_perms(gmutex);
  #endif /* APR_PROC_MUTEX_IS_GLOBAL */
  }
  
! AP_DECLARE(apr_status_t) ap_unixd_accept(void **accepted, ap_listen_rec *lr,
!                                          apr_pool_t *ptrans)
  {
      apr_socket_t *csd;
      apr_status_t status;
*************** AP_DECLARE(apr_status_t) unixd_accept(vo
*** 638,659 ****
              return APR_EGENERAL;
  #endif /*ENETDOWN*/
  
- #ifdef TPF
-         case EINACT:
-             ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
-                          "offload device inactive");
-             return APR_EGENERAL;
-             break;
-         default:
-             ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
-                          "select/accept error (%d)", status);
-             return APR_EGENERAL;
- #else
          default:
              ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf,
                           "apr_socket_accept: (client socket)");
              return APR_EGENERAL;
- #endif
      }
      return status;
  }
--- 415,432 ----
              return APR_EGENERAL;
  #endif /*ENETDOWN*/
  
          default:
+ #ifdef _OSD_POSIX /* Possibly on other platforms too */
+             /* If the socket has been closed in ap_close_listeners()
+              * by the restart/stop action, we may get EBADF.
+              * Do not print an error in this case.
+              */
+             if (!lr->active && status == EBADF)
+                 return status;
+ #endif
              ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf,
                           "apr_socket_accept: (client socket)");
              return APR_EGENERAL;
      }
      return status;
  }
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/os/unix/unixd.h /tmp/patch.inc.get2.9J0UCU/os/unix/unixd.h
*** /tmp/patch.inc.get1.AvnxJA/os/unix/unixd.h	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/os/unix/unixd.h	2013-04-28 19:22:13.551312047 +0200
***************
*** 41,53 ****
  
  #include <pwd.h>
  #include <grp.h>
! #ifdef APR_HAVE_SYS_TYPES_H
  #include <sys/types.h>
  #endif
  #ifdef HAVE_SYS_IPC_H
  #include <sys/ipc.h>
  #endif
  
  typedef struct {
      uid_t uid;
      gid_t gid;
--- 41,57 ----
  
  #include <pwd.h>
  #include <grp.h>
! #if APR_HAVE_SYS_TYPES_H
  #include <sys/types.h>
  #endif
  #ifdef HAVE_SYS_IPC_H
  #include <sys/ipc.h>
  #endif
  
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
  typedef struct {
      uid_t uid;
      gid_t gid;
*************** typedef struct {
*** 74,98 ****
      int suexec_enabled;
      const char *chroot_dir;
  } unixd_config_rec;
! AP_DECLARE_DATA extern unixd_config_rec unixd_config;
  
- AP_DECLARE(int) unixd_setup_child(void);
- AP_DECLARE(void) unixd_pre_config(apr_pool_t *ptemp);
- AP_DECLARE(const char *) unixd_set_user(cmd_parms *cmd, void *dummy, 
-                                         const char *arg);
- AP_DECLARE(const char *) unixd_set_group(cmd_parms *cmd, void *dummy, 
-                                          const char *arg);
- AP_DECLARE(const char *) unixd_set_chroot_dir(cmd_parms *cmd, void *dummy, 
-                                               const char *arg);
- 					 
  #if defined(RLIMIT_CPU) || defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_NPROC) || defined(RLIMIT_AS)
! AP_DECLARE(void) unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
!                            const char *arg, const char * arg2, int type);
  #endif
  
- AP_DECLARE(const char *) unixd_set_suexec(cmd_parms *cmd, void *dummy, 
-                                           int arg);
- 
  /**
   * One of the functions to set mutex permissions should be called in
   * the parent process on platforms that switch identity when the 
--- 78,91 ----
      int suexec_enabled;
      const char *chroot_dir;
  } unixd_config_rec;
! AP_DECLARE_DATA extern unixd_config_rec ap_unixd_config;
  
  #if defined(RLIMIT_CPU) || defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_NPROC) || defined(RLIMIT_AS)
! AP_DECLARE(void) ap_unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
!                                      const char *arg, 
!                                      const char * arg2, int type);
  #endif
  
  /**
   * One of the functions to set mutex permissions should be called in
   * the parent process on platforms that switch identity when the 
*************** AP_DECLARE(const char *) unixd_set_suexe
*** 102,116 ****
   * for SysV semaphores.  Otherwise, it is safe to call it for all
   * mutex types.
   */
! AP_DECLARE(apr_status_t) unixd_set_proc_mutex_perms(apr_proc_mutex_t *pmutex);
! AP_DECLARE(apr_status_t) unixd_set_global_mutex_perms(apr_global_mutex_t *gmutex);
! AP_DECLARE(apr_status_t) unixd_accept(void **accepted, ap_listen_rec *lr, apr_pool_t *ptrans);
  
  #ifdef HAVE_KILLPG
! #define unixd_killpg(x, y)	(killpg ((x), (y)))
  #define ap_os_killpg(x, y)      (killpg ((x), (y)))
  #else /* HAVE_KILLPG */
! #define unixd_killpg(x, y)	(kill (-(x), (y)))
  #define ap_os_killpg(x, y)      (kill (-(x), (y)))
  #endif /* HAVE_KILLPG */
  
--- 95,109 ----
   * for SysV semaphores.  Otherwise, it is safe to call it for all
   * mutex types.
   */
! AP_DECLARE(apr_status_t) ap_unixd_set_proc_mutex_perms(apr_proc_mutex_t *pmutex);
! AP_DECLARE(apr_status_t) ap_unixd_set_global_mutex_perms(apr_global_mutex_t *gmutex);
! AP_DECLARE(apr_status_t) ap_unixd_accept(void **accepted, ap_listen_rec *lr, apr_pool_t *ptrans);
  
  #ifdef HAVE_KILLPG
! #define ap_unixd_killpg(x, y)	(killpg ((x), (y)))
  #define ap_os_killpg(x, y)      (killpg ((x), (y)))
  #else /* HAVE_KILLPG */
! #define ap_unixd_killpg(x, y)	(kill (-(x), (y)))
  #define ap_os_killpg(x, y)      (kill (-(x), (y)))
  #endif /* HAVE_KILLPG */
  
*************** AP_INIT_TAKE1("Group", unixd_set_group,
*** 122,126 ****
--- 115,123 ----
  AP_INIT_TAKE1("ChrootDir", unixd_set_chroot_dir, NULL, RSRC_CONF, \
      "The directory to chroot(2) into")
  
+ #ifdef __cplusplus
+ }
+ #endif
+ 
  #endif
  /** @} */
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/config.c /tmp/patch.inc.get2.9J0UCU/server/config.c
*** /tmp/patch.inc.get1.AvnxJA/server/config.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/config.c	2013-04-28 19:22:13.551312047 +0200
***************
*** 39,46 ****
  #define APR_WANT_STRFUNC
  #include "apr_want.h"
  
- #define CORE_PRIVATE
- 
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_config.h"
--- 39,44 ----
***************
*** 51,62 ****
  #include "http_main.h"
  #include "http_vhost.h"
  #include "util_cfgtree.h"
- #include "mpm.h"
- 
  
  AP_DECLARE_DATA const char *ap_server_argv0 = NULL;
- 
  AP_DECLARE_DATA const char *ap_server_root = NULL;
  
  AP_DECLARE_DATA apr_array_header_t *ap_server_pre_read_config = NULL;
  AP_DECLARE_DATA apr_array_header_t *ap_server_post_read_config = NULL;
--- 49,59 ----
  #include "http_main.h"
  #include "http_vhost.h"
  #include "util_cfgtree.h"
  
  AP_DECLARE_DATA const char *ap_server_argv0 = NULL;
  AP_DECLARE_DATA const char *ap_server_root = NULL;
+ AP_DECLARE_DATA server_rec *ap_server_conf = NULL;
+ AP_DECLARE_DATA apr_pool_t *ap_pglobal = NULL;
  
  AP_DECLARE_DATA apr_array_header_t *ap_server_pre_read_config = NULL;
  AP_DECLARE_DATA apr_array_header_t *ap_server_post_read_config = NULL;
*************** AP_DECLARE_DATA ap_directive_t *ap_conft
*** 67,72 ****
--- 64,70 ----
  APR_HOOK_STRUCT(
             APR_HOOK_LINK(header_parser)
             APR_HOOK_LINK(pre_config)
+            APR_HOOK_LINK(check_config)
             APR_HOOK_LINK(post_config)
             APR_HOOK_LINK(open_logs)
             APR_HOOK_LINK(child_init)
*************** AP_IMPLEMENT_HOOK_RUN_ALL(int, pre_confi
*** 84,89 ****
--- 82,92 ----
                             apr_pool_t *ptemp),
                            (pconf, plog, ptemp), OK, DECLINED)
  
+ AP_IMPLEMENT_HOOK_RUN_ALL(int, check_config,
+                           (apr_pool_t *pconf, apr_pool_t *plog,
+                            apr_pool_t *ptemp, server_rec *s),
+                           (pconf, plog, ptemp, s), OK, DECLINED)
+ 
  AP_IMPLEMENT_HOOK_VOID(test_config,
                         (apr_pool_t *pconf, server_rec *s),
                         (pconf, s))
*************** AP_CORE_DECLARE(ap_conf_vector_t *) ap_c
*** 306,319 ****
      return create_empty_config(p);
  }
  
! /* Invoke the filter_init_func for all filters with FILTERS where f->r
!  * matches R.  Restricting to a matching R avoids re-running init
!  * functions for filters configured for r->main where r is a
!  * subrequest.  */
! static int invoke_filter_init(request_rec *r, ap_filter_t *filters)
  {
      while (filters) {
!         if (filters->frec->filter_init_func && filters->r == r) {
              int result = filters->frec->filter_init_func(filters);
              if (result != OK) {
                  return result;
--- 309,318 ----
      return create_empty_config(p);
  }
  
! static int ap_invoke_filter_init(ap_filter_t *filters)
  {
      while (filters) {
!         if (filters->frec->filter_init_func) {
              int result = filters->frec->filter_init_func(filters);
              if (result != OK) {
                  return result;
*************** static int invoke_filter_init(request_re
*** 324,329 ****
--- 323,334 ----
      return OK;
  }
  
+ /*
+  * TODO: Move this to an appropriate include file and possibly prefix it
+  * with AP_.
+  */
+ #define DEFAULT_HANDLER_NAME ""
+ 
  AP_CORE_DECLARE(int) ap_invoke_handler(request_rec *r)
  {
      const char *handler;
*************** AP_CORE_DECLARE(int) ap_invoke_handler(r
*** 346,373 ****
       * run their init function to let them do any magic before we could
       * start generating data.
       */
!     result = invoke_filter_init(r, r->input_filters);
      if (result != OK) {
          return result;
      }
!     result = invoke_filter_init(r, r->output_filters);
      if (result != OK) {
          return result;
      }
  
      if (!r->handler) {
!         handler = r->content_type ? r->content_type : ap_default_type(r);
!         if ((p=ap_strchr_c(handler, ';')) != NULL) {
!             char *new_handler = (char *)apr_pmemdup(r->pool, handler,
!                                                     p - handler + 1);
!             char *p2 = new_handler + (p - handler);
!             handler = new_handler;
! 
!             /* MIME type arguments */
!             while (p2 > handler && p2[-1] == ' ')
!                 --p2; /* strip trailing spaces */
  
!             *p2='\0';
          }
  
          r->handler = handler;
--- 351,383 ----
       * run their init function to let them do any magic before we could
       * start generating data.
       */
!     result = ap_invoke_filter_init(r->input_filters);
      if (result != OK) {
          return result;
      }
!     result = ap_invoke_filter_init(r->output_filters);
      if (result != OK) {
          return result;
      }
  
      if (!r->handler) {
!         if (r->content_type) {
!             handler = r->content_type;
!             if ((p=ap_strchr_c(handler, ';')) != NULL) {
!                 char *new_handler = (char *)apr_pmemdup(r->pool, handler,
!                                                         p - handler + 1);
!                 char *p2 = new_handler + (p - handler);
!                 handler = new_handler;
! 
!                 /* exclude media type arguments */
!                 while (p2 > handler && p2[-1] == ' ')
!                     --p2; /* strip trailing spaces */
  
!                 *p2='\0';
!             }
!         }
!         else {
!             handler = DEFAULT_HANDLER_NAME;
          }
  
          r->handler = handler;
*************** AP_CORE_DECLARE(int) ap_invoke_handler(r
*** 381,388 ****
          ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
              "handler \"%s\" not found for: %s", r->handler, r->filename);
      }
!     if ((result != OK) && (result != DONE) && (result != DECLINED)
!         && (result != AP_FILTER_ERROR)
          && !ap_is_HTTP_VALID_RESPONSE(result)) {
          /* If a module is deliberately returning something else
           * (request_rec in non-HTTP or proprietary extension?)
--- 391,398 ----
          ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
              "handler \"%s\" not found for: %s", r->handler, r->filename);
      }
!     if ((result != OK) && (result != DONE) && (result != DECLINED) && (result != SUSPENDED)
!         && (result != AP_FILTER_ERROR) /* ap_die() knows about this specifically */
          && !ap_is_HTTP_VALID_RESPONSE(result)) {
          /* If a module is deliberately returning something else
           * (request_rec in non-HTTP or proprietary extension?)
*************** AP_DECLARE(const char *) ap_build_cont_c
*** 1112,1122 ****
          if (retval != NULL)
              return retval;
  
!         if (sub_tree == NULL) {
              sub_tree = *curr_parent;
          }
  
!         if (sub_tree == NULL) {
              sub_tree = *current;
          }
      }
--- 1122,1132 ----
          if (retval != NULL)
              return retval;
  
!         if (sub_tree == NULL && curr_parent != NULL) {
              sub_tree = *curr_parent;
          }
  
!         if (sub_tree == NULL && current != NULL) {
              sub_tree = *current;
          }
      }
*************** AP_DECLARE(void) ap_show_modules(void)
*** 2184,2190 ****
          printf("  %s\n", ap_loaded_modules[n]->name);
  }
  
! AP_DECLARE(const char *) ap_show_mpm(void)
  {
!     return MPM_NAME;
  }
--- 2194,2212 ----
          printf("  %s\n", ap_loaded_modules[n]->name);
  }
  
! AP_DECLARE(void *) ap_retained_data_get(const char *key)
  {
!     void *retained;
! 
!     apr_pool_userdata_get((void *)&retained, key, ap_pglobal);
!     return retained;
! }
! 
! AP_DECLARE(void *) ap_retained_data_create(const char *key, apr_size_t size)
! {
!     void *retained;
! 
!     retained = apr_pcalloc(ap_pglobal, size);
!     apr_pool_userdata_set((const void *)retained, key, apr_pool_cleanup_null, ap_pglobal);
!     return retained;
  }
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/connection.c /tmp/patch.inc.get2.9J0UCU/server/connection.c
*** /tmp/patch.inc.get1.AvnxJA/server/connection.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/connection.c	2013-04-28 19:22:13.551312047 +0200
***************
*** 17,30 ****
  #include "apr.h"
  #include "apr_strings.h"
  
- #define CORE_PRIVATE
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_connection.h"
  #include "http_request.h"
  #include "http_protocol.h"
  #include "ap_mpm.h"
- #include "mpm_default.h"
  #include "http_config.h"
  #include "http_core.h"
  #include "http_vhost.h"
--- 17,28 ----
*************** AP_DECLARE(void) ap_lingering_close(conn
*** 154,173 ****
              break;
  
          if (timeup == 0) {
!             /*
!              * First time through;
!              * calculate now + 30 seconds (MAX_SECS_TO_LINGER).
!              *
!              * If some module requested a shortened waiting period, only wait
!              * for 2s (SECONDS_TO_LINGER). This is useful for mitigating
!              * certain DoS attacks.
!              */
!             if (apr_table_get(c->notes, "short-lingering-close")) {
!                 timeup = apr_time_now() + apr_time_from_sec(SECONDS_TO_LINGER);
!             }
!             else {
!                 timeup = apr_time_now() + apr_time_from_sec(MAX_SECS_TO_LINGER);
!             }
              continue;
          }
      } while (apr_time_now() < timeup);
--- 152,159 ----
              break;
  
          if (timeup == 0) {
!             /* First time through; calculate now + 30 seconds. */
!             timeup = apr_time_now() + apr_time_from_sec(MAX_SECS_TO_LINGER);
              continue;
          }
      } while (apr_time_now() < timeup);
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/core.c /tmp/patch.inc.get2.9J0UCU/server/core.c
*** /tmp/patch.inc.get1.AvnxJA/server/core.c	2013-04-28 19:22:12.451306580 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/core.c	2013-04-28 19:22:13.567312116 +0200
***************
*** 27,33 ****
  #define APR_WANT_MEMFUNC
  #include "apr_want.h"
  
- #define CORE_PRIVATE
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_config.h"
--- 27,32 ----
***************
*** 42,48 ****
  #include "apr_buckets.h"
  #include "util_filter.h"
  #include "util_ebcdic.h"
! #include "mpm.h"
  #include "mpm_common.h"
  #include "scoreboard.h"
  #include "mod_core.h"
--- 41,47 ----
  #include "apr_buckets.h"
  #include "util_filter.h"
  #include "util_ebcdic.h"
! #include "util_mutex.h"
  #include "mpm_common.h"
  #include "scoreboard.h"
  #include "mod_core.h"
***************
*** 51,56 ****
--- 50,59 ----
  
  #include "mod_so.h" /* for ap_find_loaded_module_symbol */
  
+ #if defined(RLIMIT_CPU) || defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS) || defined (RLIMIT_NPROC)
+ #include "unixd.h"
+ #endif
+ 
  /* LimitRequestBody handling */
  #define AP_LIMIT_REQ_BODY_UNSET         ((apr_off_t) -1)
  #define AP_DEFAULT_LIMIT_REQ_BODY       ((apr_off_t) 0)
***************
*** 66,74 ****
  #define AP_MAX_INCLUDE_DEPTH            (128)
  #endif
  
- /* valid in core-conf, but not in runtime r->used_path_info */
- #define AP_ACCEPT_PATHINFO_UNSET 3 
- 
  APR_HOOK_STRUCT(
      APR_HOOK_LINK(get_mgmt_items)
  )
--- 69,74 ----
*************** AP_IMPLEMENT_HOOK_RUN_ALL(int, get_mgmt_
*** 81,90 ****
   * server operations, including options and commands which control the
   * operation of other modules.  Consider this the bureaucracy module.
   *
!  * The core module also defines handlers, etc., do handle just enough
!  * to allow a server with the core module ONLY to actually serve documents
!  * (though it slaps DefaultType on all of 'em); this was useful in testing,
!  * but may not be worth preserving.
   *
   * This file could almost be mod_core.c, except for the stuff which affects
   * the http_conf_globals.
--- 81,88 ----
   * server operations, including options and commands which control the
   * operation of other modules.  Consider this the bureaucracy module.
   *
!  * The core module also defines handlers, etc., to handle just enough
!  * to allow a server with the core module ONLY to actually serve documents.
   *
   * This file could almost be mod_core.c, except for the stuff which affects
   * the http_conf_globals.
*************** AP_DECLARE_DATA ap_filter_rec_t *ap_core
*** 99,111 ****
  /* magic pointer for ErrorDocument xxx "default" */
  static char errordocument_default;
  
- /* Default ap_document_root_check to default value: true */
- AP_DECLARE_DATA int ap_document_root_check = 1;
- 
  static void *create_core_dir_config(apr_pool_t *a, char *dir)
  {
      core_dir_config *conf;
-     int i;
  
      conf = (core_dir_config *)apr_pcalloc(a, sizeof(core_dir_config));
  
--- 97,105 ----
*************** static void *create_core_dir_config(apr_
*** 117,132 ****
      conf->override_opts = OPT_UNSET | OPT_ALL | OPT_SYM_OWNER | OPT_MULTI;
  
      conf->content_md5 = 2;
!     conf->accept_path_info = AP_ACCEPT_PATHINFO_UNSET;
  
      conf->use_canonical_name = USE_CANONICAL_NAME_UNSET;
      conf->use_canonical_phys_port = USE_CANONICAL_PHYS_PORT_UNSET;
  
      conf->hostname_lookups = HOSTNAME_LOOKUP_UNSET;
-     conf->satisfy = apr_palloc(a, sizeof(*conf->satisfy) * METHODS);
-     for (i = 0; i < METHODS; ++i) {
-         conf->satisfy[i] = SATISFY_NOSPEC;
-     }
  
  #ifdef RLIMIT_CPU
      conf->limit_cpu = NULL;
--- 111,122 ----
      conf->override_opts = OPT_UNSET | OPT_ALL | OPT_SYM_OWNER | OPT_MULTI;
  
      conf->content_md5 = 2;
!     conf->accept_path_info = 3;
  
      conf->use_canonical_name = USE_CANONICAL_NAME_UNSET;
      conf->use_canonical_phys_port = USE_CANONICAL_PHYS_PORT_UNSET;
  
      conf->hostname_lookups = HOSTNAME_LOOKUP_UNSET;
  
  #ifdef RLIMIT_CPU
      conf->limit_cpu = NULL;
*************** static void *create_core_dir_config(apr_
*** 164,172 ****
      conf->enable_mmap = ENABLE_MMAP_UNSET;
      conf->enable_sendfile = ENABLE_SENDFILE_UNSET;
      conf->allow_encoded_slashes = 0;
-     conf->decode_encoded_slashes = 0;
-  
-     conf->max_ranges = AP_MAXRANGES_UNSET;
  
      return (void *)conf;
  }
--- 154,159 ----
*************** static void *merge_core_dir_configs(apr_
*** 241,246 ****
--- 228,234 ----
      conf->d_is_fnmatch = new->d_is_fnmatch;
      conf->d_components = new->d_components;
      conf->r = new->r;
+     conf->condition = new->condition;
  
      if (new->opts & OPT_UNSET) {
          /* there was no explicit setting of new->opts, so we merge
*************** static void *merge_core_dir_configs(apr_
*** 278,299 ****
          conf->override_opts = new->override_opts;
      }
  
-     if (new->ap_default_type) {
-         conf->ap_default_type = new->ap_default_type;
-     }
- 
-     if (new->ap_auth_type) {
-         conf->ap_auth_type = new->ap_auth_type;
-     }
- 
-     if (new->ap_auth_name) {
-         conf->ap_auth_name = new->ap_auth_name;
-     }
- 
-     if (new->ap_requires) {
-         conf->ap_requires = new->ap_requires;
-     }
- 
      if (conf->response_code_strings == NULL) {
          conf->response_code_strings = new->response_code_strings;
      }
--- 266,271 ----
*************** static void *merge_core_dir_configs(apr_
*** 371,386 ****
      /* Otherwise we simply use the base->sec_file array
       */
  
-     /* use a separate ->satisfy[] array either way */
-     conf->satisfy = apr_palloc(a, sizeof(*conf->satisfy) * METHODS);
-     for (i = 0; i < METHODS; ++i) {
-         if (new->satisfy[i] != SATISFY_NOSPEC) {
-             conf->satisfy[i] = new->satisfy[i];
-         } else {
-             conf->satisfy[i] = base->satisfy[i];
-         }
-     }
- 
      if (new->server_signature != srv_sig_unset) {
          conf->server_signature = new->server_signature;
      }
--- 343,348 ----
*************** static void *merge_core_dir_configs(apr_
*** 453,465 ****
      }
  
      conf->allow_encoded_slashes = new->allow_encoded_slashes;
-     conf->decode_encoded_slashes = new->decode_encoded_slashes;
- 
-     conf->max_ranges = new->max_ranges != AP_MAXRANGES_UNSET ? new->max_ranges : base->max_ranges;
  
      return (void*)conf;
  }
  
  static void *create_core_server_config(apr_pool_t *a, server_rec *s)
  {
      core_server_config *conf;
--- 415,436 ----
      }
  
      conf->allow_encoded_slashes = new->allow_encoded_slashes;
  
      return (void*)conf;
  }
  
+ #if APR_HAS_SO_ACCEPTFILTER
+ #ifndef ACCEPT_FILTER_NAME
+ #define ACCEPT_FILTER_NAME "httpready"
+ #ifdef __FreeBSD_version
+ #if __FreeBSD_version < 411000 /* httpready broken before 4.1.1 */
+ #undef ACCEPT_FILTER_NAME
+ #define ACCEPT_FILTER_NAME "dataready"
+ #endif
+ #endif
+ #endif
+ #endif
+ 
  static void *create_core_server_config(apr_pool_t *a, server_rec *s)
  {
      core_server_config *conf;
*************** static void *create_core_server_config(a
*** 467,506 ****
  
      conf = (core_server_config *)apr_pcalloc(a, sizeof(core_server_config));
  
! #ifdef GPROF
!     conf->gprof_dir = NULL;
  #endif
  
-     conf->access_name = is_virtual ? NULL : DEFAULT_ACCESS_FNAME;
-     conf->ap_document_root = is_virtual ? NULL : DOCUMENT_LOCATION;
      conf->sec_dir = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));
      conf->sec_url = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));
  
!     /* recursion stopper */
!     conf->redirect_limit = 0; /* 0 == unset */
      conf->subreq_limit = 0;
  
      conf->protocol = NULL;
!     conf->accf_map = apr_table_make(a, 5);
! 
! #ifdef APR_TCP_DEFER_ACCEPT
!     apr_table_set(conf->accf_map, "http", "data");
!     apr_table_set(conf->accf_map, "https", "data");
! #endif
! 
! #if APR_HAS_SO_ACCEPTFILTER
! #ifndef ACCEPT_FILTER_NAME
! #define ACCEPT_FILTER_NAME "httpready"
! #ifdef __FreeBSD_version
! #if __FreeBSD_version < 411000 /* httpready broken before 4.1.1 */
! #undef ACCEPT_FILTER_NAME
! #define ACCEPT_FILTER_NAME "dataready"
! #endif
! #endif
! #endif
!     apr_table_set(conf->accf_map, "http", ACCEPT_FILTER_NAME);
!     apr_table_set(conf->accf_map, "https", "dataready");
! #endif
  
      conf->trace_enable = AP_TRACE_UNSET;
  
--- 438,481 ----
  
      conf = (core_server_config *)apr_pcalloc(a, sizeof(core_server_config));
  
!     /* global-default / global-only settings */
! 
!     if (!is_virtual) {
!         conf->ap_document_root = DOCUMENT_LOCATION;
!         conf->access_name = DEFAULT_ACCESS_FNAME;
! 
!         /* A mapping only makes sense in the global context */
!         conf->accf_map = apr_table_make(a, 5);
! #if APR_HAS_SO_ACCEPTFILTER
!         apr_table_setn(conf->accf_map, "http", ACCEPT_FILTER_NAME);
!         apr_table_setn(conf->accf_map, "https", "dataready");
! #else
!         apr_table_setn(conf->accf_map, "http", "data");
!         apr_table_setn(conf->accf_map, "https", "data");
  #endif
+     }
+     /* pcalloc'ed - we have NULL's/0's
+     else ** is_virtual ** {
+         conf->ap_document_root = NULL;
+         conf->access_name = NULL;
+         conf->accf_map = NULL;
+     }
+      */
+ 
+     /* initialization, no special case for global context */
  
      conf->sec_dir = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));
      conf->sec_url = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));
  
!     /* pcalloc'ed - we have NULL's/0's
!     conf->gprof_dir = NULL;
! 
!     ** recursion stopper; 0 == unset
!     conf->redirect_limit = 0;
      conf->subreq_limit = 0;
  
      conf->protocol = NULL;
!      */
  
      conf->trace_enable = AP_TRACE_UNSET;
  
*************** static void *merge_core_server_configs(a
*** 511,546 ****
  {
      core_server_config *base = (core_server_config *)basev;
      core_server_config *virt = (core_server_config *)virtv;
!     core_server_config *conf;
! 
!     conf = (core_server_config *)apr_pmemdup(p, virt, sizeof(core_server_config));
  
!     if (!conf->access_name) {
!         conf->access_name = base->access_name;
!     }
  
!     if (!conf->ap_document_root) {
!         conf->ap_document_root = base->ap_document_root;
!     }
! 
!     if (!conf->protocol) {
!         conf->protocol = base->protocol;
!     }
  
      conf->sec_dir = apr_array_append(p, base->sec_dir, virt->sec_dir);
      conf->sec_url = apr_array_append(p, base->sec_url, virt->sec_url);
  
!     conf->redirect_limit = virt->redirect_limit
!                            ? virt->redirect_limit
!                            : base->redirect_limit;
! 
!     conf->subreq_limit = virt->subreq_limit
!                          ? virt->subreq_limit
!                          : base->subreq_limit;
! 
!     conf->trace_enable = (virt->trace_enable != AP_TRACE_UNSET)
!                          ? virt->trace_enable
!                          : base->trace_enable;
  
      return conf;
  }
--- 486,520 ----
  {
      core_server_config *base = (core_server_config *)basev;
      core_server_config *virt = (core_server_config *)virtv;
!     core_server_config *conf = (core_server_config *)
!                                apr_pmemdup(p, base, sizeof(core_server_config));
  
!     if (virt->ap_document_root)
!         conf->ap_document_root = virt->ap_document_root;
  
!     if (virt->access_name)
!         conf->access_name = virt->access_name;
  
+     /* XXX optimize to keep base->sec_ pointers if virt->sec_ array is empty */
      conf->sec_dir = apr_array_append(p, base->sec_dir, virt->sec_dir);
      conf->sec_url = apr_array_append(p, base->sec_url, virt->sec_url);
  
!     if (virt->redirect_limit)
!         conf->redirect_limit = virt->redirect_limit;
! 
!     if (virt->subreq_limit)
!         conf->subreq_limit = virt->subreq_limit;
! 
!     if (virt->trace_enable != AP_TRACE_UNSET)
!         conf->trace_enable = virt->trace_enable;
! 
!     /* no action for virt->accf_map, not allowed per-vhost */
! 
!     if (virt->protocol)
!         conf->protocol = virt->protocol;
! 
!     if (virt->gprof_dir)
!         conf->gprof_dir = virt->gprof_dir;
  
      return conf;
  }
*************** AP_DECLARE(int) ap_allow_options(request
*** 673,688 ****
      core_dir_config *conf =
        (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
  
!     /* Per comment in http_core.h - the OPT_INC_WITH_EXEC bit is
!      * inverted, such that the exposed semantics match that of
!      * OPT_INCNOEXEC; i.e., the bit is only enabled if exec= is *not*
!      * permitted. */
!     if (conf->opts & OPT_INCLUDES) {
!         return conf->opts ^ OPT_INC_WITH_EXEC;
!     }
!     else {
!         return conf->opts;
!     }
  }
  
  AP_DECLARE(int) ap_allow_overrides(request_rec *r)
--- 647,653 ----
      core_dir_config *conf =
        (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
  
!     return conf->opts;
  }
  
  AP_DECLARE(int) ap_allow_overrides(request_rec *r)
*************** AP_DECLARE(int) ap_allow_overrides(reque
*** 694,729 ****
      return conf->override;
  }
  
  AP_DECLARE(const char *) ap_auth_type(request_rec *r)
  {
!     core_dir_config *conf;
! 
!     conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
!                                                    &core_module);
! 
!     return conf->ap_auth_type;
  }
  
  AP_DECLARE(const char *) ap_auth_name(request_rec *r)
  {
!     core_dir_config *conf;
! 
!     conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
!                                                    &core_module);
! 
!     return conf->ap_auth_name;
  }
  
! AP_DECLARE(const char *) ap_default_type(request_rec *r)
! {
!     core_dir_config *conf;
! 
!     conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
!                                                    &core_module);
  
!     return conf->ap_default_type
!                ? conf->ap_default_type
!                : DEFAULT_CONTENT_TYPE;
  }
  
  AP_DECLARE(const char *) ap_document_root(request_rec *r) /* Don't use this! */
--- 659,704 ----
      return conf->override;
  }
  
+ /*
+  * Optional function coming from mod_authn_core, used for
+  * retrieving the type of autorization
+  */
+ static APR_OPTIONAL_FN_TYPE(authn_ap_auth_type) *authn_ap_auth_type;
+ 
  AP_DECLARE(const char *) ap_auth_type(request_rec *r)
  {
!     if (authn_ap_auth_type) {
!         return authn_ap_auth_type(r);
!     }
!     return NULL;
  }
  
+ /*
+  * Optional function coming from mod_authn_core, used for
+  * retrieving the authorization realm
+  */
+ static APR_OPTIONAL_FN_TYPE(authn_ap_auth_name) *authn_ap_auth_name;
+ 
  AP_DECLARE(const char *) ap_auth_name(request_rec *r)
  {
!     if (authn_ap_auth_name) {
!         return authn_ap_auth_name(r);
!     }
!     return NULL;
  }
  
! /*
!  * Optional function coming from mod_access_compat, used to determine how
!    access control interacts with authentication/authorization
!  */
! static APR_OPTIONAL_FN_TYPE(access_compat_ap_satisfies) *access_compat_ap_satisfies;
  
! AP_DECLARE(int) ap_satisfies(request_rec *r)
! {
!     if (access_compat_ap_satisfies) {
!         return access_compat_ap_satisfies(r);
!     }
!     return SATISFY_NOSPEC;
  }
  
  AP_DECLARE(const char *) ap_document_root(request_rec *r) /* Don't use this! */
*************** AP_DECLARE(const char *) ap_document_roo
*** 736,761 ****
      return conf->ap_document_root;
  }
  
- AP_DECLARE(const apr_array_header_t *) ap_requires(request_rec *r)
- {
-     core_dir_config *conf;
- 
-     conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
-                                                    &core_module);
- 
-     return conf->ap_requires;
- }
- 
- AP_DECLARE(int) ap_satisfies(request_rec *r)
- {
-     core_dir_config *conf;
- 
-     conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
-                                                    &core_module);
- 
-     return conf->satisfy[r->method_number];
- }
- 
  /* Should probably just get rid of this... the only code that cares is
   * part of the core anyway (and in fact, it isn't publicised to other
   * modules).
--- 711,716 ----
*************** AP_DECLARE(const char *) ap_check_cmd_co
*** 1089,1097 ****
                             " cannot occur within <VirtualHost> section", NULL);
      }
  
!     if ((forbidden & NOT_IN_LIMIT) && cmd->limited != -1) {
          return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,
!                            " cannot occur within <Limit> section", NULL);
      }
  
      if ((forbidden & NOT_IN_DIR_LOC_FILE) == NOT_IN_DIR_LOC_FILE) {
--- 1044,1054 ----
                             " cannot occur within <VirtualHost> section", NULL);
      }
  
!     if ((forbidden & (NOT_IN_LIMIT | NOT_IN_DIR_LOC_FILE))
!         && cmd->limited != -1) {
          return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,
!                            " cannot occur within <Limit> or <LimitExcept> "
!                            "section", NULL);
      }
  
      if ((forbidden & NOT_IN_DIR_LOC_FILE) == NOT_IN_DIR_LOC_FILE) {
*************** static const char *set_access_name(cmd_p
*** 1131,1138 ****
      void *sconf = cmd->server->module_config;
      core_server_config *conf = ap_get_module_config(sconf, &core_module);
  
!     const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      if (err != NULL) {
          return err;
      }
--- 1088,1094 ----
      void *sconf = cmd->server->module_config;
      core_server_config *conf = ap_get_module_config(sconf, &core_module);
  
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      if (err != NULL) {
          return err;
      }
*************** static const char *set_access_name(cmd_p
*** 1141,1154 ****
      return NULL;
  }
  
  #ifdef GPROF
  static const char *set_gprof_dir(cmd_parms *cmd, void *dummy, const char *arg)
  {
      void *sconf = cmd->server->module_config;
      core_server_config *conf = ap_get_module_config(sconf, &core_module);
  
!     const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      if (err != NULL) {
          return err;
      }
--- 1097,1127 ----
      return NULL;
  }
  
+ 
+ static const char *set_define(cmd_parms *cmd, void *dummy,
+                                    const char *optarg)
+ {
+     char **newv;
+ 
+     const char *err = ap_check_cmd_context(cmd,
+                                            GLOBAL_ONLY);
+     if (err != NULL) {
+         return err;
+     }
+ 
+     newv = (char **)apr_array_push(ap_server_config_defines);
+     *newv = apr_pstrdup(cmd->pool, optarg);
+ 
+     return NULL;
+ }
+ 
  #ifdef GPROF
  static const char *set_gprof_dir(cmd_parms *cmd, void *dummy, const char *arg)
  {
      void *sconf = cmd->server->module_config;
      core_server_config *conf = ap_get_module_config(sconf, &core_module);
  
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      if (err != NULL) {
          return err;
      }
*************** static const char *set_add_default_chars
*** 1163,1173 ****
  {
      core_dir_config *d = d_;
  
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
-     if (err != NULL) {
-         return err;
-     }
- 
      if (!strcasecmp(arg, "Off")) {
         d->add_default_charset = ADD_DEFAULT_CHARSET_OFF;
      }
--- 1136,1141 ----
*************** static const char *set_document_root(cmd
*** 1189,1213 ****
      void *sconf = cmd->server->module_config;
      core_server_config *conf = ap_get_module_config(sconf, &core_module);
  
!     const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      if (err != NULL) {
          return err;
      }
  
-     /* When ap_document_root_check is false; skip all the stuff below */
-     if (!ap_document_root_check) {
-        conf->ap_document_root = arg;
-        return NULL;
-     }
- 
      /* Make it absolute, relative to ServerRoot */
      arg = ap_server_root_relative(cmd->pool, arg);
      if (arg == NULL) {
          return "DocumentRoot must be a directory";
      }
  
!     /* TODO: ap_configtestonly */
      if (apr_filepath_merge((char**)&conf->ap_document_root, NULL, arg,
                             APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS
          || !ap_is_directory(cmd->pool, arg)) {
--- 1157,1174 ----
      void *sconf = cmd->server->module_config;
      core_server_config *conf = ap_get_module_config(sconf, &core_module);
  
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      if (err != NULL) {
          return err;
      }
  
      /* Make it absolute, relative to ServerRoot */
      arg = ap_server_root_relative(cmd->pool, arg);
      if (arg == NULL) {
          return "DocumentRoot must be a directory";
      }
  
!     /* TODO: ap_configtestonly && ap_docrootcheck && */
      if (apr_filepath_merge((char**)&conf->ap_document_root, NULL, arg,
                             APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS
          || !ap_is_directory(cmd->pool, arg)) {
*************** static const char *set_error_document(cm
*** 1252,1262 ****
      int error_number, index_number, idx500;
      enum { MSG, LOCAL_PATH, REMOTE_PATH } what = MSG;
  
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
-     if (err != NULL) {
-         return err;
-     }
- 
      /* 1st parameter should be a 3 digit number, which we recognize;
       * convert it into an array index
       */
--- 1213,1218 ----
*************** static const char *set_override(cmd_parm
*** 1383,1393 ****
      char *w;
      char *k, *v;
  
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
-     if (err != NULL) {
-         return err;
-     }
- 
      /* Throw a warning if we're in <Location> or <Files> */
      if (ap_check_cmd_context(cmd, NOT_IN_LOCATION | NOT_IN_FILES)) {
          ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
--- 1339,1344 ----
*************** static const char *set_options(cmd_parms
*** 1515,1520 ****
--- 1466,1483 ----
      return NULL;
  }
  
+ static const char *set_default_type(cmd_parms *cmd, void *d_,
+                                    const char *arg)
+ {
+     if ((strcasecmp(arg, "off") != 0) && (strcasecmp(arg, "none") != 0)) {
+         ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+               "Ignoring deprecated use of DefaultType in line %d of %s.",
+                      cmd->directive->line_num, cmd->directive->filename);
+     }
+ 
+     return NULL;
+ }
+ 
  /*
   * Note what data should be used when forming file ETag values.
   * It would be nicer to do this as an ITERATE, but then we couldn't
*************** static const char *set_enable_mmap(cmd_p
*** 1652,1662 ****
                                     const char *arg)
  {
      core_dir_config *d = d_;
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
- 
-     if (err != NULL) {
-         return err;
-     }
  
      if (strcasecmp(arg, "on") == 0) {
          d->enable_mmap = ENABLE_MMAP_ON;
--- 1615,1620 ----
*************** static const char *set_enable_sendfile(c
*** 1675,1685 ****
                                     const char *arg)
  {
      core_dir_config *d = d_;
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
- 
-     if (err != NULL) {
-         return err;
-     }
  
      if (strcasecmp(arg, "on") == 0) {
          d->enable_sendfile = ENABLE_SENDFILE_ON;
--- 1633,1638 ----
*************** static const char *set_enable_sendfile(c
*** 1694,1739 ****
      return NULL;
  }
  
- static const char *satisfy(cmd_parms *cmd, void *c_, const char *arg)
- {
-     core_dir_config *c = c_;
-     int satisfy = SATISFY_NOSPEC;
-     int i;
- 
-     if (!strcasecmp(arg, "all")) {
-         satisfy = SATISFY_ALL;
-     }
-     else if (!strcasecmp(arg, "any")) {
-         satisfy = SATISFY_ANY;
-     }
-     else {
-         return "Satisfy either 'any' or 'all'.";
-     }
- 
-     for (i = 0; i < METHODS; ++i) {
-         if (cmd->limited & (AP_METHOD_BIT << i)) {
-             c->satisfy[i] = satisfy;
-         }
-     }
- 
-     return NULL;
- }
- 
- static const char *require(cmd_parms *cmd, void *c_, const char *arg)
- {
-     require_line *r;
-     core_dir_config *c = c_;
- 
-     if (!c->ap_requires) {
-         c->ap_requires = apr_array_make(cmd->pool, 2, sizeof(require_line));
-     }
- 
-     r = (require_line *)apr_array_push(c->ap_requires);
-     r->requirement = apr_pstrdup(cmd->pool, arg);
-     r->method_mask = cmd->limited;
- 
-     return NULL;
- }
  
  /*
   * Report a missing-'>' syntax error.
--- 1647,1652 ----
*************** AP_CORE_DECLARE_NONSTD(const char *) ap_
*** 1761,1773 ****
      const char *limited_methods;
      void *tog = cmd->cmd->cmd_data;
      apr_int64_t limited = 0;
      const char *errmsg;
  
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
-     if (err != NULL) {
-         return err;
-     }
- 
      if (endp == NULL) {
          return unclosed_directive(cmd);
      }
--- 1674,1682 ----
      const char *limited_methods;
      void *tog = cmd->cmd->cmd_data;
      apr_int64_t limited = 0;
+     apr_int64_t old_limited = cmd->limited;
      const char *errmsg;
  
      if (endp == NULL) {
          return unclosed_directive(cmd);
      }
*************** AP_CORE_DECLARE_NONSTD(const char *) ap_
*** 1801,1811 ****
      /* Killing two features with one function,
       * if (tog == NULL) <Limit>, else <LimitExcept>
       */
!     cmd->limited = tog ? ~limited : limited;
  
      errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);
  
!     cmd->limited = -1;
  
      return errmsg;
  }
--- 1710,1732 ----
      /* Killing two features with one function,
       * if (tog == NULL) <Limit>, else <LimitExcept>
       */
!     limited = tog ? ~limited : limited;
! 
!     if (!(old_limited & limited)) {
!         return apr_pstrcat(cmd->pool, cmd->cmd->name,
!                            "> directive excludes all methods", NULL);
!     }
!     else if ((old_limited & limited) == old_limited) {
!         return apr_pstrcat(cmd->pool, cmd->cmd->name,
!                            "> directive specifies methods already excluded",
!                            NULL);
!     }
! 
!     cmd->limited &= limited;
  
      errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);
  
!     cmd->limited = old_limited;
  
      return errmsg;
  }
*************** static const char *dirsection(cmd_parms
*** 1833,1840 ****
      ap_regex_t *r = NULL;
      const command_rec *thiscmd = cmd->cmd;
  
!     const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      if (err != NULL) {
          return err;
      }
--- 1754,1760 ----
      ap_regex_t *r = NULL;
      const command_rec *thiscmd = cmd->cmd;
  
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      if (err != NULL) {
          return err;
      }
*************** static const char *dirsection(cmd_parms
*** 1849,1854 ****
--- 1769,1781 ----
          return missing_container_arg(cmd);
      }
  
+     if (!arg) {
+         if (thiscmd->cmd_data)
+             return "<DirectoryMatch > block must specify a path";
+         else
+             return "<Directory > block must specify a path";
+     }
+ 
      cmd->path = ap_getword_conf(cmd->pool, &arg);
      cmd->override = OR_ALL|ACCESS_CONF;
  
*************** static const char *urlsection(cmd_parms
*** 1930,1937 ****
      ap_regex_t *r = NULL;
      const command_rec *thiscmd = cmd->cmd;
      ap_conf_vector_t *new_url_conf = ap_create_per_dir_config(cmd->pool);
!     const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      if (err != NULL) {
          return err;
      }
--- 1857,1863 ----
      ap_regex_t *r = NULL;
      const command_rec *thiscmd = cmd->cmd;
      ap_conf_vector_t *new_url_conf = ap_create_per_dir_config(cmd->pool);
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      if (err != NULL) {
          return err;
      }
*************** static const char *filesection(cmd_parms
*** 1999,2005 ****
      const command_rec *thiscmd = cmd->cmd;
      core_dir_config *c = mconfig;
      ap_conf_vector_t *new_file_conf = ap_create_per_dir_config(cmd->pool);
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT|NOT_IN_LOCATION);
  
      if (err != NULL) {
          return err;
--- 1925,1932 ----
      const command_rec *thiscmd = cmd->cmd;
      core_dir_config *c = mconfig;
      ap_conf_vector_t *new_file_conf = ap_create_per_dir_config(cmd->pool);
!     const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_LOCATION | NOT_IN_LIMIT);
  
      if (err != NULL) {
          return err;
*************** static const char *filesection(cmd_parms
*** 2069,2074 ****
--- 1996,2065 ----
  
      return NULL;
  }
+ static const char *ifsection(cmd_parms *cmd, void *mconfig, const char *arg)
+ {
+     const char *errmsg;
+     const char *endp = ap_strrchr_c(arg, '>');
+     int old_overrides = cmd->override;
+     char *old_path = cmd->path;
+     core_dir_config *conf;
+     const command_rec *thiscmd = cmd->cmd;
+     core_dir_config *c = mconfig;
+     ap_conf_vector_t *new_file_conf = ap_create_per_dir_config(cmd->pool);
+     const char *err = ap_check_cmd_context(cmd,
+                                            NOT_IN_LOCATION | NOT_IN_LIMIT);
+     const char *condition;
+     int expr_err = 0;
+ 
+     if (err != NULL) {
+         return err;
+     }
+ 
+     if (endp == NULL) {
+         return unclosed_directive(cmd);
+     }
+ 
+     arg = apr_pstrndup(cmd->pool, arg, endp - arg);
+ 
+     if (!arg[0]) {
+         return missing_container_arg(cmd);
+     }
+ 
+     condition = ap_getword_conf(cmd->pool, &arg);
+     /* Only if not an .htaccess file */
+     if (!old_path) {
+         cmd->override = OR_ALL|ACCESS_CONF;
+     }
+ 
+     /* initialize our config and fetch it */
+     conf = ap_set_config_vectors(cmd->server, new_file_conf, cmd->path,
+                                  &core_module, cmd->pool);
+ 
+     conf->condition = ap_expr_parse(cmd->pool, condition, &expr_err);
+     if (expr_err) {
+         return "Cannot parse condition clause";
+     }
+ 
+     errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_file_conf);
+     if (errmsg != NULL)
+         return errmsg;
+ 
+     conf->d = cmd->path;
+     conf->d_is_fnmatch = 0;
+     conf->r = NULL;
+ 
+     ap_add_file_conf(c, new_file_conf);
+ 
+     if (*arg != '\0') {
+         return apr_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
+                            "> arguments not supported.", NULL);
+     }
+ 
+     cmd->path = old_path;
+     cmd->override = old_overrides;
+ 
+     return NULL;
+ }
  
  static const char *start_ifmod(cmd_parms *cmd, void *mconfig, const char *arg)
  {
*************** static const char *set_accf_map(cmd_parm
*** 2278,2284 ****
      ap_str_tolower(proto);
      accf = apr_pstrdup(cmd->pool, iaccf);
      ap_str_tolower(accf);
!     apr_table_set(conf->accf_map, proto, accf);
  
      return NULL;
  }
--- 2269,2275 ----
      ap_str_tolower(proto);
      accf = apr_pstrdup(cmd->pool, iaccf);
      ap_str_tolower(accf);
!     apr_table_setn(conf->accf_map, proto, accf);
  
      return NULL;
  }
*************** AP_DECLARE(void) ap_set_server_protocol(
*** 2300,2306 ****
  static const char *set_protocol(cmd_parms *cmd, void *dummy,
                                  const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      core_server_config *conf = ap_get_module_config(cmd->server->module_config,
                                                      &core_module);
      char* proto;
--- 2291,2297 ----
  static const char *set_protocol(cmd_parms *cmd, void *dummy,
                                  const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      core_server_config *conf = ap_get_module_config(cmd->server->module_config,
                                                      &core_module);
      char* proto;
*************** static const char *set_server_string_slo
*** 2325,2331 ****
      char *struct_ptr = (char *)cmd->server;
  
      const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      if (err != NULL) {
          return err;
      }
--- 2316,2322 ----
      char *struct_ptr = (char *)cmd->server;
  
      const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE);
      if (err != NULL) {
          return err;
      }
*************** static const char *set_server_string_slo
*** 2344,2350 ****
  
  static const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      const char *portstr, *part;
      char *scheme;
      int port;
--- 2335,2341 ----
  
  static const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      const char *portstr, *part;
      char *scheme;
      int port;
*************** static const char *server_hostname_port(
*** 2356,2364 ****
      part = ap_strstr_c(arg, "://");
  
      if (part) {
!       scheme = apr_pstrmemdup(cmd->pool, arg, part - arg);
        ap_str_tolower(scheme);
!       cmd->server->server_scheme = scheme;
        part += 3;
      } else {
        part = arg;
--- 2347,2355 ----
      part = ap_strstr_c(arg, "://");
  
      if (part) {
!       scheme = apr_pstrndup(cmd->pool, arg, part - arg);
        ap_str_tolower(scheme);
!       cmd->server->server_scheme = (const char *)scheme;
        part += 3;
      } else {
        part = arg;
*************** static const char *server_hostname_port(
*** 2366,2373 ****
  
      portstr = ap_strchr_c(part, ':');
      if (portstr) {
!         cmd->server->server_hostname = apr_pstrmemdup(cmd->pool, part,
!                                                       portstr - part);
          portstr++;
          port = atoi(portstr);
          if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */
--- 2357,2364 ----
  
      portstr = ap_strchr_c(part, ':');
      if (portstr) {
!         cmd->server->server_hostname = apr_pstrndup(cmd->pool, part,
!                                                     portstr - part);
          portstr++;
          port = atoi(portstr);
          if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */
*************** static const char *set_signature_flag(cm
*** 2389,2399 ****
                                        const char *arg)
  {
      core_dir_config *d = d_;
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
- 
-     if (err != NULL) {
-         return err;
-     }
  
      if (strcasecmp(arg, "On") == 0) {
          d->server_signature = srv_sig_on;
--- 2380,2385 ----
*************** static const char *set_server_root(cmd_p
*** 2431,2437 ****
  
  static const char *set_timeout(cmd_parms *cmd, void *dummy, const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
  
      if (err != NULL) {
          return err;
--- 2417,2423 ----
  
  static const char *set_timeout(cmd_parms *cmd, void *dummy, const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
  
      if (err != NULL) {
          return err;
*************** static const char *set_timeout(cmd_parms
*** 2441,2469 ****
      return NULL;
  }
  
! static const char *set_allow2f(cmd_parms *cmd, void *d_, const char *arg)
  {
      core_dir_config *d = d_;
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
  
!     if (err != NULL) {
!         return err;
!     }
! 
!     if (0 == strcasecmp(arg, "on")) {
!         d->allow_encoded_slashes = 1;
!         d->decode_encoded_slashes = 1;
!     } else if (0 == strcasecmp(arg, "off")) {
!         d->allow_encoded_slashes = 0;
!         d->decode_encoded_slashes = 0;
!     } else if (0 == strcasecmp(arg, "nodecode")) {
!         d->allow_encoded_slashes = 1;
!         d->decode_encoded_slashes = 0;
!     } else {
!         return apr_pstrcat(cmd->pool,
!                            cmd->cmd->name, " must be On, Off, or NoDecode",
!                            NULL);
!     }
      return NULL;
  }
  
--- 2427,2437 ----
      return NULL;
  }
  
! static const char *set_allow2f(cmd_parms *cmd, void *d_, int arg)
  {
      core_dir_config *d = d_;
  
!     d->allow_encoded_slashes = arg != 0;
      return NULL;
  }
  
*************** static const char *set_hostname_lookups(
*** 2471,2481 ****
                                          const char *arg)
  {
      core_dir_config *d = d_;
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
- 
-     if (err != NULL) {
-         return err;
-     }
  
      if (!strcasecmp(arg, "on")) {
          d->hostname_lookups = HOSTNAME_LOOKUP_ON;
--- 2439,2444 ----
*************** static const char *set_hostname_lookups(
*** 2496,2502 ****
  static const char *set_serverpath(cmd_parms *cmd, void *dummy,
                                    const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
  
      if (err != NULL) {
          return err;
--- 2459,2465 ----
  static const char *set_serverpath(cmd_parms *cmd, void *dummy,
                                    const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
  
      if (err != NULL) {
          return err;
*************** static const char *set_serverpath(cmd_pa
*** 2510,2520 ****
  static const char *set_content_md5(cmd_parms *cmd, void *d_, int arg)
  {
      core_dir_config *d = d_;
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
- 
-     if (err != NULL) {
-         return err;
-     }
  
      d->content_md5 = arg != 0;
      return NULL;
--- 2473,2478 ----
*************** static const char *set_use_canonical_nam
*** 2544,2554 ****
                                            const char *arg)
  {
      core_dir_config *d = d_;
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
- 
-     if (err != NULL) {
-         return err;
-     }
  
      if (strcasecmp(arg, "on") == 0) {
          d->use_canonical_name = USE_CANONICAL_NAME_ON;
--- 2502,2507 ----
*************** static const char *set_use_canonical_phy
*** 2570,2580 ****
                                            const char *arg)
  {
      core_dir_config *d = d_;
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
- 
-     if (err != NULL) {
-         return err;
-     }
  
      if (strcasecmp(arg, "on") == 0) {
          d->use_canonical_phys_port = USE_CANONICAL_PHYS_PORT_ON;
--- 2523,2528 ----
*************** static const char *set_loglevel(cmd_parm
*** 2643,2650 ****
  {
      char *str;
  
!     const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      if (err != NULL) {
          return err;
      }
--- 2591,2597 ----
  {
      char *str;
  
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      if (err != NULL) {
          return err;
      }
*************** AP_DECLARE(const char *) ap_psignature(c
*** 2720,2738 ****
  }
  
  /*
-  * Load an authorisation realm into our location configuration, applying the
-  * usual rules that apply to realms.
-  */
- static const char *set_authname(cmd_parms *cmd, void *mconfig,
-                                 const char *word1)
- {
-     core_dir_config *aconfig = (core_dir_config *)mconfig;
- 
-     aconfig->ap_auth_name = ap_escape_quotes(cmd->pool, word1);
-     return NULL;
- }
- 
- /*
   * Handle a request to include the server's OS platform in the Server
   * response header field (the ServerTokens directive).  Unfortunately
   * this requires a new global in order to communicate the setting back to
--- 2667,2672 ----
*************** static int banner_locked = 0;
*** 2745,2755 ****
  static char *server_description = NULL;
  
  enum server_token_type {
!     SrvTk_MAJOR,        /* eg: Apache/2 */
!     SrvTk_MINOR,        /* eg. Apache/2.0 */
!     SrvTk_MINIMAL,      /* eg: Apache/2.0.41 */
!     SrvTk_OS,           /* eg: Apache/2.0.41 (UNIX) */
!     SrvTk_FULL,         /* eg: Apache/2.0.41 (UNIX) PHP/4.2.2 FooBar/1.2b */
      SrvTk_PRODUCT_ONLY  /* eg: Apache */
  };
  static enum server_token_type ap_server_tokens = SrvTk_FULL;
--- 2679,2689 ----
  static char *server_description = NULL;
  
  enum server_token_type {
!     SrvTk_MAJOR,         /* eg: Apache/2 */
!     SrvTk_MINOR,         /* eg. Apache/2.0 */
!     SrvTk_MINIMAL,       /* eg: Apache/2.0.41 */
!     SrvTk_OS,            /* eg: Apache/2.0.41 (UNIX) */
!     SrvTk_FULL,          /* eg: Apache/2.0.41 (UNIX) PHP/4.2.2 FooBar/1.2b */
      SrvTk_PRODUCT_ONLY  /* eg: Apache */
  };
  static enum server_token_type ap_server_tokens = SrvTk_FULL;
*************** AP_DECLARE(const char *) ap_get_server_b
*** 2782,2795 ****
      return server_banner ? server_banner : AP_SERVER_BASEVERSION;
  }
  
- /* ap_get_server_version() is deprecated.  ap_get_server_banner()
-  * provides the same semantics.
-  */
- AP_DECLARE(const char *) ap_get_server_version(void)
- {
-     return ap_get_server_banner();
- }
- 
  AP_DECLARE(void) ap_add_version_component(apr_pool_t *pconf, const char *component)
  {
      if (! banner_locked) {
--- 2716,2721 ----
*************** static void set_banner(apr_pool_t *pconf
*** 2849,2855 ****
  }
  
  static const char *set_serv_tokens(cmd_parms *cmd, void *dummy,
!                                    const char *arg)
  {
      const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
  
--- 2775,2781 ----
  }
  
  static const char *set_serv_tokens(cmd_parms *cmd, void *dummy,
!                                    const char *arg1, const char *arg2)
  {
      const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
  
*************** static const char *set_serv_tokens(cmd_p
*** 2857,2875 ****
          return err;
      }
  
!     if (!strcasecmp(arg, "OS")) {
          ap_server_tokens = SrvTk_OS;
      }
!     else if (!strcasecmp(arg, "Min") || !strcasecmp(arg, "Minimal")) {
          ap_server_tokens = SrvTk_MINIMAL;
      }
!     else if (!strcasecmp(arg, "Major")) {
          ap_server_tokens = SrvTk_MAJOR;
      }
!     else if (!strcasecmp(arg, "Minor") ) {
          ap_server_tokens = SrvTk_MINOR;
      }
!     else if (!strcasecmp(arg, "Prod") || !strcasecmp(arg, "ProductOnly")) {
          ap_server_tokens = SrvTk_PRODUCT_ONLY;
      }
      else {
--- 2783,2801 ----
          return err;
      }
  
!     if (!strcasecmp(arg1, "OS")) {
          ap_server_tokens = SrvTk_OS;
      }
!     else if (!strcasecmp(arg1, "Min") || !strcasecmp(arg1, "Minimal")) {
          ap_server_tokens = SrvTk_MINIMAL;
      }
!     else if (!strcasecmp(arg1, "Major")) {
          ap_server_tokens = SrvTk_MAJOR;
      }
!     else if (!strcasecmp(arg1, "Minor") ) {
          ap_server_tokens = SrvTk_MINOR;
      }
!     else if (!strcasecmp(arg1, "Prod") || !strcasecmp(arg1, "ProductOnly")) {
          ap_server_tokens = SrvTk_PRODUCT_ONLY;
      }
      else {
*************** static const char *set_serv_tokens(cmd_p
*** 2882,2889 ****
  static const char *set_limit_req_line(cmd_parms *cmd, void *dummy,
                                        const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      int lim;
  
      if (err != NULL) {
--- 2808,2814 ----
  static const char *set_limit_req_line(cmd_parms *cmd, void *dummy,
                                        const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      int lim;
  
      if (err != NULL) {
*************** static const char *set_limit_req_line(cm
*** 2903,2910 ****
  static const char *set_limit_req_fieldsize(cmd_parms *cmd, void *dummy,
                                             const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      int lim;
  
      if (err != NULL) {
--- 2828,2834 ----
  static const char *set_limit_req_fieldsize(cmd_parms *cmd, void *dummy,
                                             const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      int lim;
  
      if (err != NULL) {
*************** static const char *set_limit_req_fieldsi
*** 2925,2932 ****
  static const char *set_limit_req_fields(cmd_parms *cmd, void *dummy,
                                          const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd,
!                                            NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
      int lim;
  
      if (err != NULL) {
--- 2849,2855 ----
  static const char *set_limit_req_fields(cmd_parms *cmd, void *dummy,
                                          const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);
      int lim;
  
      if (err != NULL) {
*************** static const char *set_limit_req_body(cm
*** 2948,2960 ****
                                        const char *arg)
  {
      core_dir_config *conf = conf_;
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
      char *errp;
  
-     if (err != NULL) {
-         return err;
-     }
- 
      if (APR_SUCCESS != apr_strtoff(&conf->limit_req_body, arg, &errp, 10)) {
          return "LimitRequestBody argument is not parsable.";
      }
--- 2871,2878 ----
*************** static const char *set_limit_xml_req_bod
*** 2969,2979 ****
                                            const char *arg)
  {
      core_dir_config *conf = conf_;
-     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
- 
-     if (err != NULL) {
-         return err;
-     }
  
      conf->limit_xml_body = atol(arg);
      if (conf->limit_xml_body < 0)
--- 2887,2892 ----
*************** static const char *set_limit_xml_req_bod
*** 2982,3012 ****
      return NULL;
  }
  
- static const char *set_max_ranges(cmd_parms *cmd, void *conf_, const char *arg)
- {
-     core_dir_config *conf = conf_;
-     int val = 0;
- 
-     if (!strcasecmp(arg, "none")) { 
-         val = AP_MAXRANGES_NORANGES;
-     }
-     else if (!strcasecmp(arg, "default")) { 
-         val = AP_MAXRANGES_DEFAULT;
-     }
-     else if (!strcasecmp(arg, "unlimited")) { 
-         val = AP_MAXRANGES_UNLIMITED;
-     }
-     else { 
-         val = atoi(arg);
-         if (val <= 0)
-             return "MaxRanges requires 'none', 'default', 'unlimited' or " 
-                    "a positive integer";
-     }
- 
-     conf->max_ranges = val;
-     
-     return NULL;
- }
  AP_DECLARE(size_t) ap_get_limit_xml_body(const request_rec *r)
  {
      core_dir_config *conf;
--- 2895,2900 ----
*************** static const char *set_limit_cpu(cmd_par
*** 3035,3041 ****
  {
      core_dir_config *conf = conf_;
  
!     unixd_set_rlimit(cmd, &conf->limit_cpu, arg, arg2, RLIMIT_CPU);
      return NULL;
  }
  #endif
--- 2923,2929 ----
  {
      core_dir_config *conf = conf_;
  
!     ap_unixd_set_rlimit(cmd, &conf->limit_cpu, arg, arg2, RLIMIT_CPU);
      return NULL;
  }
  #endif
*************** static const char *set_limit_mem(cmd_par
*** 3047,3057 ****
      core_dir_config *conf = conf_;
  
  #if defined(RLIMIT_AS)
!     unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2 ,RLIMIT_AS);
  #elif defined(RLIMIT_DATA)
!     unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_DATA);
  #elif defined(RLIMIT_VMEM)
!     unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_VMEM);
  #endif
  
      return NULL;
--- 2935,2945 ----
      core_dir_config *conf = conf_;
  
  #if defined(RLIMIT_AS)
!     ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2 ,RLIMIT_AS);
  #elif defined(RLIMIT_DATA)
!     ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_DATA);
  #elif defined(RLIMIT_VMEM)
!     ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_VMEM);
  #endif
  
      return NULL;
*************** static const char *set_limit_nproc(cmd_p
*** 3064,3070 ****
  {
      core_dir_config *conf = conf_;
  
!     unixd_set_rlimit(cmd, &conf->limit_nproc, arg, arg2, RLIMIT_NPROC);
      return NULL;
  }
  #endif
--- 2952,2958 ----
  {
      core_dir_config *conf = conf_;
  
!     ap_unixd_set_rlimit(cmd, &conf->limit_nproc, arg, arg2, RLIMIT_NPROC);
      return NULL;
  }
  #endif
*************** AP_DECLARE(int) ap_is_recursion_limit_ex
*** 3172,3178 ****
                  /* uuh, too much. */
                  ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                "Request exceeded the limit of %d subrequest "
!                               "nesting levels due to probable confguration "
                                "error. Use 'LimitInternalRecursion' to increase "
                                "the limit if necessary. Use 'LogLevel debug' to "
                                "get a backtrace.", slimit);
--- 3060,3066 ----
                  /* uuh, too much. */
                  ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                "Request exceeded the limit of %d subrequest "
!                               "nesting levels due to probable configuration "
                                "error. Use 'LimitInternalRecursion' to increase "
                                "the limit if necessary. Use 'LogLevel debug' to "
                                "get a backtrace.", slimit);
*************** AP_INIT_RAW_ARGS("<VirtualHost", virtual
*** 3314,3323 ****
    "more host addresses"),
  AP_INIT_RAW_ARGS("<Files", filesection, NULL, OR_ALL,
    "Container for directives affecting files matching specified patterns"),
! AP_INIT_RAW_ARGS("<Limit", ap_limit_section, NULL, OR_ALL,
    "Container for authentication directives when accessed using specified HTTP "
    "methods"),
! AP_INIT_RAW_ARGS("<LimitExcept", ap_limit_section, (void*)1, OR_ALL,
    "Container for authentication directives to be applied when any HTTP "
    "method other than those specified is used to access the resource"),
  AP_INIT_TAKE1("<IfModule", start_ifmod, NULL, EXEC_ON_READ | OR_ALL,
--- 3202,3212 ----
    "more host addresses"),
  AP_INIT_RAW_ARGS("<Files", filesection, NULL, OR_ALL,
    "Container for directives affecting files matching specified patterns"),
! AP_INIT_RAW_ARGS("<Limit", ap_limit_section, NULL, OR_LIMIT | OR_AUTHCFG,
    "Container for authentication directives when accessed using specified HTTP "
    "methods"),
! AP_INIT_RAW_ARGS("<LimitExcept", ap_limit_section, (void*)1,
!                  OR_LIMIT | OR_AUTHCFG,
    "Container for authentication directives to be applied when any HTTP "
    "method other than those specified is used to access the resource"),
  AP_INIT_TAKE1("<IfModule", start_ifmod, NULL, EXEC_ON_READ | OR_ALL,
*************** AP_INIT_RAW_ARGS("<LocationMatch", urlse
*** 3332,3346 ****
    "specified URL paths"),
  AP_INIT_RAW_ARGS("<FilesMatch", filesection, (void*)1, OR_ALL,
    "Container for directives affecting files matching specified patterns"),
- AP_INIT_TAKE1("AuthType", ap_set_string_slot,
-   (void*)APR_OFFSETOF(core_dir_config, ap_auth_type), OR_AUTHCFG,
-   "An HTTP authorization type (e.g., \"Basic\")"),
- AP_INIT_TAKE1("AuthName", set_authname, NULL, OR_AUTHCFG,
-   "The authentication realm (e.g. \"Members Only\")"),
- AP_INIT_RAW_ARGS("Require", require, NULL, OR_AUTHCFG,
-   "Selects which authenticated users or groups may access a protected space"),
- AP_INIT_TAKE1("Satisfy", satisfy, NULL, OR_AUTHCFG,
-   "access policy if both allow and require used ('all' or 'any')"),
  #ifdef GPROF
  AP_INIT_TAKE1("GprofDir", set_gprof_dir, NULL, RSRC_CONF,
    "Directory to plop gmon.out files"),
--- 3221,3226 ----
*************** AP_INIT_TAKE1("AddDefaultCharset", set_a
*** 3349,3354 ****
--- 3229,3238 ----
    "The name of the default charset to add to any Content-Type without one or 'Off' to disable"),
  AP_INIT_TAKE1("AcceptPathInfo", set_accept_path_info, NULL, OR_FILEINFO,
    "Set to on or off for PATH_INFO to be accepted by handlers, or default for the per-handler preference"),
+ AP_INIT_TAKE1("Define", set_define, NULL, RSRC_CONF,
+               "Define the existance of a variable.  Same as passing -D to the command line."),
+ AP_INIT_RAW_ARGS("<If", ifsection, NULL, OR_ALL,
+   "Container for directives to be conditionally applied"),
  
  /* Old resource config file commands */
  
*************** AP_INIT_RAW_ARGS("AllowOverride", set_ov
*** 3363,3371 ****
    "config files"),
  AP_INIT_RAW_ARGS("Options", set_options, NULL, OR_OPTIONS,
    "Set a number of attributes for a given directory"),
! AP_INIT_TAKE1("DefaultType", ap_set_string_slot,
!   (void*)APR_OFFSETOF(core_dir_config, ap_default_type),
!   OR_FILEINFO, "the default MIME type for untypable files"),
  AP_INIT_RAW_ARGS("FileETag", set_etag_bits, NULL, OR_FILEINFO,
    "Specify components used to construct a file's ETag"),
  AP_INIT_TAKE1("EnableMMAP", set_enable_mmap, NULL, OR_FILEINFO,
--- 3247,3254 ----
    "config files"),
  AP_INIT_RAW_ARGS("Options", set_options, NULL, OR_OPTIONS,
    "Set a number of attributes for a given directory"),
! AP_INIT_TAKE1("DefaultType", set_default_type, NULL, OR_FILEINFO,
!   "the default media type for otherwise untyped files (DEPRECATED)"),
  AP_INIT_RAW_ARGS("FileETag", set_etag_bits, NULL, OR_FILEINFO,
    "Specify components used to construct a file's ETag"),
  AP_INIT_TAKE1("EnableMMAP", set_enable_mmap, NULL, OR_FILEINFO,
*************** AP_INIT_TAKE1("LogLevel", set_loglevel,
*** 3420,3427 ****
    "Level of verbosity in error logging"),
  AP_INIT_TAKE1("NameVirtualHost", ap_set_name_virtual_host, NULL, RSRC_CONF,
    "A numeric IP address:port, or the name of a host"),
! AP_INIT_TAKE1("ServerTokens", set_serv_tokens, NULL, RSRC_CONF,
!   "Determine tokens displayed in the Server: header - Min(imal), OS or Full"),
  AP_INIT_TAKE1("LimitRequestLine", set_limit_req_line, NULL, RSRC_CONF,
    "Limit on maximum size of an HTTP request line"),
  AP_INIT_TAKE1("LimitRequestFieldsize", set_limit_req_fieldsize, NULL,
--- 3303,3311 ----
    "Level of verbosity in error logging"),
  AP_INIT_TAKE1("NameVirtualHost", ap_set_name_virtual_host, NULL, RSRC_CONF,
    "A numeric IP address:port, or the name of a host"),
! AP_INIT_TAKE12("ServerTokens", set_serv_tokens, NULL, RSRC_CONF,
!   "Determine tokens displayed in the Server: header - Min(imal), "
!   "Major, Minor, Prod, OS or Full"),
  AP_INIT_TAKE1("LimitRequestLine", set_limit_req_line, NULL, RSRC_CONF,
    "Limit on maximum size of an HTTP request line"),
  AP_INIT_TAKE1("LimitRequestFieldsize", set_limit_req_fieldsize, NULL,
*************** AP_INIT_TAKE1("LimitRequestBody", set_li
*** 3435,3444 ****
  AP_INIT_TAKE1("LimitXMLRequestBody", set_limit_xml_req_body, NULL, OR_ALL,
                "Limit (in bytes) on maximum size of an XML-based request "
                "body"),
  
- AP_INIT_TAKE1("MaxRanges", set_max_ranges, NULL, RSRC_CONF|ACCESS_CONF,
-               "Maximum number of Ranges in a request before returning the entire "
-               "resource, or 0 for unlimited"),
  /* System Resource Controls */
  #ifdef RLIMIT_CPU
  AP_INIT_TAKE12("RLimitCPU", set_limit_cpu,
--- 3319,3327 ----
  AP_INIT_TAKE1("LimitXMLRequestBody", set_limit_xml_req_body, NULL, OR_ALL,
                "Limit (in bytes) on maximum size of an XML-based request "
                "body"),
+ AP_INIT_TAKE2("Mutex", ap_set_mutex, NULL, RSRC_CONF,
+               "mutex (or \"default\") and mechanism"),
  
  /* System Resource Controls */
  #ifdef RLIMIT_CPU
  AP_INIT_TAKE12("RLimitCPU", set_limit_cpu,
*************** AP_INIT_TAKE1("SetInputFilter", ap_set_s
*** 3484,3539 ****
  AP_INIT_ITERATE2("AddOutputFilterByType", add_ct_output_filters,
         (void *)APR_OFFSETOF(core_dir_config, ct_output_filters), OR_FILEINFO,
       "output filter name followed by one or more content-types"),
! AP_INIT_TAKE1("AllowEncodedSlashes", set_allow2f, NULL, RSRC_CONF,
               "Allow URLs containing '/' encoded as '%2F'"),
  
  /*
   * These are default configuration directives that mpms can/should
!  * pay attention to. If an mpm wishes to use these, they should
!  * #defined them in mpm.h.
   */
- #ifdef AP_MPM_WANT_SET_PIDFILE
  AP_INIT_TAKE1("PidFile",  ap_mpm_set_pidfile, NULL, RSRC_CONF,
                "A file for logging the server process ID"),
- #endif
- #ifdef AP_MPM_WANT_SET_SCOREBOARD
  AP_INIT_TAKE1("ScoreBoardFile", ap_mpm_set_scoreboard, NULL, RSRC_CONF,
                "A file for Apache to maintain runtime process management information"),
- #endif
- #ifdef AP_MPM_WANT_SET_LOCKFILE
- AP_INIT_TAKE1("LockFile",  ap_mpm_set_lockfile, NULL, RSRC_CONF,
-               "The lockfile used when Apache needs to lock the accept() call"),
- #endif
- #ifdef AP_MPM_WANT_SET_MAX_REQUESTS
  AP_INIT_TAKE1("MaxRequestsPerChild", ap_mpm_set_max_requests, NULL, RSRC_CONF,
                "Maximum number of requests a particular child serves before dying."),
- #endif
- #ifdef AP_MPM_WANT_SET_COREDUMPDIR
  AP_INIT_TAKE1("CoreDumpDirectory", ap_mpm_set_coredumpdir, NULL, RSRC_CONF,
                "The location of the directory Apache changes to before dumping core"),
- #endif
- #ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
- AP_INIT_TAKE1("AcceptMutex", ap_mpm_set_accept_lock_mech, NULL, RSRC_CONF,
-               ap_valid_accept_mutex_string),
- #endif
- #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
  AP_INIT_TAKE1("MaxMemFree", ap_mpm_set_max_mem_free, NULL, RSRC_CONF,
                "Maximum number of 1k blocks a particular childs allocator may hold."),
- #endif
- #ifdef AP_MPM_WANT_SET_STACKSIZE
  AP_INIT_TAKE1("ThreadStackSize", ap_mpm_set_thread_stacksize, NULL, RSRC_CONF,
                "Size in bytes of stack used by threads handling client connections"),
- #endif
  #if AP_ENABLE_EXCEPTION_HOOK
  AP_INIT_TAKE1("EnableExceptionHook", ap_mpm_set_exception_hook, NULL, RSRC_CONF,
                "Controls whether exception hook may be called after a crash"),
  #endif
  AP_INIT_TAKE1("TraceEnable", set_trace_enable, NULL, RSRC_CONF,
                "'on' (default), 'off' or 'extended' to trace request body content"),
- #ifdef SUEXEC_BIN
- AP_INIT_FLAG("Suexec", unixd_set_suexec, NULL, RSRC_CONF,
-              "Enable or disable suEXEC support"),
- #endif
  { NULL }
  };
  
--- 3367,3399 ----
  AP_INIT_ITERATE2("AddOutputFilterByType", add_ct_output_filters,
         (void *)APR_OFFSETOF(core_dir_config, ct_output_filters), OR_FILEINFO,
       "output filter name followed by one or more content-types"),
! AP_INIT_FLAG("AllowEncodedSlashes", set_allow2f, NULL, RSRC_CONF,
               "Allow URLs containing '/' encoded as '%2F'"),
  
  /*
   * These are default configuration directives that mpms can/should
!  * pay attention to.
!  * XXX These are not for all platforms, and even some Unix MPMs might not want
!  * some directives.
   */
  AP_INIT_TAKE1("PidFile",  ap_mpm_set_pidfile, NULL, RSRC_CONF,
                "A file for logging the server process ID"),
  AP_INIT_TAKE1("ScoreBoardFile", ap_mpm_set_scoreboard, NULL, RSRC_CONF,
                "A file for Apache to maintain runtime process management information"),
  AP_INIT_TAKE1("MaxRequestsPerChild", ap_mpm_set_max_requests, NULL, RSRC_CONF,
                "Maximum number of requests a particular child serves before dying."),
  AP_INIT_TAKE1("CoreDumpDirectory", ap_mpm_set_coredumpdir, NULL, RSRC_CONF,
                "The location of the directory Apache changes to before dumping core"),
  AP_INIT_TAKE1("MaxMemFree", ap_mpm_set_max_mem_free, NULL, RSRC_CONF,
                "Maximum number of 1k blocks a particular childs allocator may hold."),
  AP_INIT_TAKE1("ThreadStackSize", ap_mpm_set_thread_stacksize, NULL, RSRC_CONF,
                "Size in bytes of stack used by threads handling client connections"),
  #if AP_ENABLE_EXCEPTION_HOOK
  AP_INIT_TAKE1("EnableExceptionHook", ap_mpm_set_exception_hook, NULL, RSRC_CONF,
                "Controls whether exception hook may be called after a crash"),
  #endif
  AP_INIT_TAKE1("TraceEnable", set_trace_enable, NULL, RSRC_CONF,
                "'on' (default), 'off' or 'extended' to trace request body content"),
  { NULL }
  };
  
*************** static int core_override_type(request_re
*** 3650,3666 ****
      /* Deal with the poor soul who is trying to force path_info to be
       * accepted within the core_handler, where they will let the subreq
       * address its contents.  This is toggled by the user in the very
!      * beginning of the fixup phase (here!), so modules should override the user's
       * discretion in their own module fixup phase.  It is tristate, if
!      * the user doesn't specify, the result is AP_REQ_DEFAULT_PATH_INFO.
!      * (which the module may interpret to its own customary behavior.)  
!      * It won't be touched if the value is no longer AP_ACCEPT_PATHINFO_UNSET,
!      * so any module changing the value prior to the fixup phase 
!      * OVERRIDES the user's choice.
       */
      if ((r->used_path_info == AP_REQ_DEFAULT_PATH_INFO)
!         && (conf->accept_path_info != AP_ACCEPT_PATHINFO_UNSET)) {
!         /* No module knew better, and the user coded AcceptPathInfo */
          r->used_path_info = conf->accept_path_info;
      }
  
--- 3510,3524 ----
      /* Deal with the poor soul who is trying to force path_info to be
       * accepted within the core_handler, where they will let the subreq
       * address its contents.  This is toggled by the user in the very
!      * beginning of the fixup phase, so modules should override the user's
       * discretion in their own module fixup phase.  It is tristate, if
!      * the user doesn't specify, the result is 2 (which the module may
!      * interpret to its own customary behavior.)  It won't be touched
!      * if the value is no longer undefined (2), so any module changing
!      * the value prior to the fixup phase OVERRIDES the user's choice.
       */
      if ((r->used_path_info == AP_REQ_DEFAULT_PATH_INFO)
!         && (conf->accept_path_info != 3)) {
          r->used_path_info = conf->accept_path_info;
      }
  
*************** static int default_handler(request_rec *
*** 3763,3770 ****
          ap_update_mtime(r, r->finfo.mtime);
          ap_set_last_modified(r);
          ap_set_etag(r);
!         ap_set_accept_ranges(r);
          ap_set_content_length(r, r->finfo.size);
  
          bb = apr_brigade_create(r->pool, c->bucket_alloc);
  
--- 3621,3632 ----
          ap_update_mtime(r, r->finfo.mtime);
          ap_set_last_modified(r);
          ap_set_etag(r);
!         apr_table_setn(r->headers_out, "Accept-Ranges", "bytes");
          ap_set_content_length(r, r->finfo.size);
+         if (bld_content_md5) {
+             apr_table_setn(r->headers_out, "Content-MD5",
+                            ap_md5digest(r->pool, fd));
+         }
  
          bb = apr_brigade_create(r->pool, c->bucket_alloc);
  
*************** static int default_handler(request_rec *
*** 3773,3812 ****
              r->status = errstatus;
          }
          else {
!             if (bld_content_md5) {
!                 apr_table_setn(r->headers_out, "Content-MD5",
!                                ap_md5digest(r->pool, fd));
!             }
! 
!             /* For platforms where the size of the file may be larger than
!              * that which can be stored in a single bucket (where the
!              * length field is an apr_size_t), split it into several
!              * buckets: */
!             if (sizeof(apr_off_t) > sizeof(apr_size_t)
!                 && r->finfo.size > AP_MAX_SENDFILE) {
!                 apr_off_t fsize = r->finfo.size;
!                 e = apr_bucket_file_create(fd, 0, AP_MAX_SENDFILE, r->pool,
!                                            c->bucket_alloc);
!                 while (fsize > AP_MAX_SENDFILE) {
!                     apr_bucket *ce;
!                     apr_bucket_copy(e, &ce);
!                     APR_BRIGADE_INSERT_TAIL(bb, ce);
!                     e->start += AP_MAX_SENDFILE;
!                     fsize -= AP_MAX_SENDFILE;
!                 }
!                 e->length = (apr_size_t)fsize; /* Resize just the last bucket */
!             }
!             else {
!                 e = apr_bucket_file_create(fd, 0, (apr_size_t)r->finfo.size,
!                                            r->pool, c->bucket_alloc);
!             }
  
  #if APR_HAS_MMAP
              if (d->enable_mmap == ENABLE_MMAP_OFF) {
                  (void)apr_bucket_file_enable_mmap(e, 0);
              }
  #endif
-             APR_BRIGADE_INSERT_TAIL(bb, e);
          }
  
          e = apr_bucket_eos_create(c->bucket_alloc);
--- 3635,3647 ----
              r->status = errstatus;
          }
          else {
!             e = apr_brigade_insert_file(bb, fd, 0, r->finfo.size, r->pool);
  
  #if APR_HAS_MMAP
              if (d->enable_mmap == ENABLE_MMAP_OFF) {
                  (void)apr_bucket_file_enable_mmap(e, 0);
              }
  #endif
          }
  
          e = apr_bucket_eos_create(c->bucket_alloc);
*************** static int default_handler(request_rec *
*** 3828,3835 ****
      }
      else {              /* unusual method (not GET or POST) */
          if (r->method_number == M_INVALID) {
!             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
!                           "Invalid method in request %s", r->the_request);
              return HTTP_NOT_IMPLEMENTED;
          }
  
--- 3663,3681 ----
      }
      else {              /* unusual method (not GET or POST) */
          if (r->method_number == M_INVALID) {
!             /* See if this looks like an undecrypted SSL handshake attempt.
!              * It's safe to look a couple bytes into the_request if it exists, as it's
!              * always allocated at least MIN_LINE_ALLOC (80) bytes.
!              */
!             if (r->the_request
!                 && r->the_request[0] == 0x16                                
!                 && (r->the_request[1] == 0x2 || r->the_request[1] == 0x3)) {
!                 ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
!                               "Invalid method in request %s - possible attempt to establish SSL connection on non-SSL port", r->the_request);
!             } else {
!                 ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
!                               "Invalid method in request %s", r->the_request);
!             }
              return HTTP_NOT_IMPLEMENTED;
          }
  
*************** static int default_handler(request_rec *
*** 3843,3857 ****
  /* Optional function coming from mod_logio, used for logging of output
   * traffic
   */
! APR_OPTIONAL_FN_TYPE(ap_logio_add_bytes_out) *logio_add_bytes_out;
  
  static int core_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
  {
!     logio_add_bytes_out = APR_RETRIEVE_OPTIONAL_FN(ap_logio_add_bytes_out);
      ident_lookup = APR_RETRIEVE_OPTIONAL_FN(ap_ident_lookup);
  
      set_banner(pconf);
      ap_setup_make_content_type(pconf);
      return OK;
  }
  
--- 3689,3725 ----
  /* Optional function coming from mod_logio, used for logging of output
   * traffic
   */
! APR_OPTIONAL_FN_TYPE(ap_logio_add_bytes_out) *ap__logio_add_bytes_out;
! APR_OPTIONAL_FN_TYPE(authz_some_auth_required) *ap__authz_ap_some_auth_required;
  
+ /* Insist that at least one module will undertake to provide system
+  * security by dropping startup privileges.
+  */
+ static int sys_privileges = 0;
+ AP_DECLARE(int) ap_sys_privileges_handlers(int inc)
+ {
+     sys_privileges += inc;
+     return sys_privileges;
+ }
  static int core_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
  {
!     ap__logio_add_bytes_out = APR_RETRIEVE_OPTIONAL_FN(ap_logio_add_bytes_out);
      ident_lookup = APR_RETRIEVE_OPTIONAL_FN(ap_ident_lookup);
+     ap__authz_ap_some_auth_required = APR_RETRIEVE_OPTIONAL_FN(authz_some_auth_required);
+     authn_ap_auth_type = APR_RETRIEVE_OPTIONAL_FN(authn_ap_auth_type);
+     authn_ap_auth_name = APR_RETRIEVE_OPTIONAL_FN(authn_ap_auth_name);
+     access_compat_ap_satisfies = APR_RETRIEVE_OPTIONAL_FN(access_compat_ap_satisfies);
  
      set_banner(pconf);
      ap_setup_make_content_type(pconf);
+     ap_setup_auth_internal(ptemp);
+     if (!sys_privileges) {
+         ap_log_error(APLOG_MARK, APLOG_CRIT, 0, NULL,
+                      "Server MUST relinquish startup privileges before "
+                      "accepting connections.  Please ensure mod_unixd "
+                      "or other system security module is loaded.");
+         return !OK;
+     }
      return OK;
  }
  
*************** static conn_rec *core_create_conn(apr_po
*** 3981,3986 ****
--- 3849,3862 ----
  
      c->id = id;
      c->bucket_alloc = alloc;
+ 
+     c->cs = (conn_state_t *)apr_pcalloc(ptrans, sizeof(conn_state_t));
+     APR_RING_INIT(&(c->cs->timeout_list), conn_state_t, timeout_list);
+     c->cs->expiration_time = 0;
+     c->cs->state = CONN_STATE_CHECK_REQUEST_LINE_READABLE;
+     c->cs->c = c;
+     c->cs->p = ptrans;
+     c->cs->bucket_alloc = alloc;
      c->clogging_input_filters = 0;
  
      return c;
*************** static int core_pre_connection(conn_rec
*** 3991,3997 ****
      core_net_rec *net = apr_palloc(c->pool, sizeof(*net));
      apr_status_t rv;
  
- #ifdef AP_MPM_DISABLE_NAGLE_ACCEPTED_SOCK
      /* The Nagle algorithm says that we should delay sending partial
       * packets in hopes of getting more data.  We don't want to do
       * this; we are not telnet.  There are bad interactions between
--- 3867,3872 ----
*************** static int core_pre_connection(conn_rec
*** 4007,4013 ****
          ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c,
                        "apr_socket_opt_set(APR_TCP_NODELAY)");
      }
- #endif
  
      /* The core filter requires the timeout mode to be set, which
       * incidentally sets the socket to be nonblocking.  If this
--- 3882,3887 ----
*************** static void register_hooks(apr_pool_t *p
*** 4054,4060 ****
      /* FIXME: I suspect we can eliminate the need for these do_nothings - Ben */
      ap_hook_type_checker(do_nothing,NULL,NULL,APR_HOOK_REALLY_LAST);
      ap_hook_fixups(core_override_type,NULL,NULL,APR_HOOK_REALLY_FIRST);
-     ap_hook_access_checker(do_nothing,NULL,NULL,APR_HOOK_REALLY_LAST);
      ap_hook_create_request(core_create_req, NULL, NULL, APR_HOOK_MIDDLE);
      APR_OPTIONAL_HOOK(proxy, create_req, core_create_proxy_req, NULL, NULL,
                        APR_HOOK_MIDDLE);
--- 3928,3933 ----
*************** static void register_hooks(apr_pool_t *p
*** 4083,4089 ****
  }
  
  AP_DECLARE_DATA module core_module = {
!     STANDARD20_MODULE_STUFF,
      create_core_dir_config,       /* create per-directory config structure */
      merge_core_dir_configs,       /* merge per-directory config structures */
      create_core_server_config,    /* create per-server config structure */
--- 3956,3963 ----
  }
  
  AP_DECLARE_DATA module core_module = {
!     MPM20_MODULE_STUFF,
!     AP_PLATFORM_REWRITE_ARGS_HOOK, /* hook to run before apache parses args */
      create_core_dir_config,       /* create per-directory config structure */
      merge_core_dir_configs,       /* merge per-directory config structures */
      create_core_server_config,    /* create per-server config structure */
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/core_filters.c /tmp/patch.inc.get2.9J0UCU/server/core_filters.c
*** /tmp/patch.inc.get1.AvnxJA/server/core_filters.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/core_filters.c	2013-04-28 19:22:13.551312047 +0200
***************
*** 32,38 ****
  #define APR_WANT_MEMFUNC
  #include "apr_want.h"
  
- #define CORE_PRIVATE
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_config.h"
--- 32,37 ----
***************
*** 47,53 ****
  #include "apr_buckets.h"
  #include "util_filter.h"
  #include "util_ebcdic.h"
- #include "mpm.h"
  #include "mpm_common.h"
  #include "scoreboard.h"
  #include "mod_core.h"
--- 46,51 ----
*************** do { \
*** 78,103 ****
  } while (0)
  
  
- /**
-  * Split the contents of a brigade after bucket 'e' to an existing brigade
-  *
-  * XXXX: Should this function be added to APR-Util?
-  */
- static void brigade_move(apr_bucket_brigade *b, apr_bucket_brigade *a,
-                          apr_bucket *e)
- {
-     apr_bucket *f;
- 
-     if (e != APR_BRIGADE_SENTINEL(b)) {
-         f = APR_RING_LAST(&b->list);
-         APR_RING_UNSPLICE(e, f, link);
-         APR_RING_SPLICE_HEAD(&a->list, e, f, apr_bucket, link);
-     }
- 
-     APR_BRIGADE_CHECK_CONSISTENCY(a);
-     APR_BRIGADE_CHECK_CONSISTENCY(b);
- }
- 
  int ap_core_input_filter(ap_filter_t *f, apr_bucket_brigade *b,
                           ap_input_mode_t mode, apr_read_type_e block,
                           apr_off_t readbytes)
--- 76,81 ----
*************** int ap_core_input_filter(ap_filter_t *f,
*** 214,223 ****
       * the brigade that was passed down, and send that brigade back.
       *
       * NOTE:  This is VERY dangerous to use, and should only be done with
!      * extreme caution.  However, the Perchild MPM needs this feature
!      * if it is ever going to work correctly again.  With this, the Perchild
!      * MPM can easily request the socket and all data that has been read,
!      * which means that it can pass it to the correct child process.
       */
      if (mode == AP_MODE_EXHAUSTIVE) {
          apr_bucket *e;
--- 192,200 ----
       * the brigade that was passed down, and send that brigade back.
       *
       * NOTE:  This is VERY dangerous to use, and should only be done with
!      * extreme caution.  FWLIW, this would be needed by an MPM like Perchild;
!      * such an MPM can easily request the socket and all data that has been
!      * read, which means that it can pass it to the correct child process.
       */
      if (mode == AP_MODE_EXHAUSTIVE) {
          apr_bucket *e;
*************** int ap_core_input_filter(ap_filter_t *f,
*** 268,273 ****
--- 245,281 ----
              return APR_SUCCESS;
          }
  
+         /* Have we read as much data as we wanted (be greedy)? */
+         if (len < readbytes) {
+             apr_size_t bucket_len;
+ 
+             rv = APR_SUCCESS;
+             /* We already registered the data in e in len */
+             e = APR_BUCKET_NEXT(e);
+             while ((len < readbytes) && (rv == APR_SUCCESS)
+                    && (e != APR_BRIGADE_SENTINEL(ctx->b))) {
+                 /* Check for the availability of buckets with known length */
+                 if (e->length != -1) {
+                     len += e->length;
+                     e = APR_BUCKET_NEXT(e);
+                 }
+                 else {
+                     /*
+                      * Read from bucket, but non blocking. If there isn't any
+                      * more data, well than this is fine as well, we will
+                      * not wait for more since we already got some and we are
+                      * only checking if there isn't more.
+                      */
+                     rv = apr_bucket_read(e, &str, &bucket_len,
+                                          APR_NONBLOCK_READ);
+                     if (rv == APR_SUCCESS) {
+                         len += bucket_len;
+                         e = APR_BUCKET_NEXT(e);
+                     }
+                 }
+             }
+         }
+ 
          /* We can only return at most what we read. */
          if (len < readbytes) {
              readbytes = len;
*************** int ap_core_input_filter(ap_filter_t *f,
*** 279,285 ****
          }
  
          /* Must do move before CONCAT */
!         brigade_move(ctx->b, ctx->tmpbb, e);
  
          if (mode == AP_MODE_READBYTES) {
              APR_BRIGADE_CONCAT(b, ctx->b);
--- 287,293 ----
          }
  
          /* Must do move before CONCAT */
!         ctx->tmpbb = apr_brigade_split_ex(ctx->b, e, ctx->tmpbb);
  
          if (mode == AP_MODE_READBYTES) {
              APR_BRIGADE_CONCAT(b, ctx->b);
*************** int ap_core_input_filter(ap_filter_t *f,
*** 305,520 ****
      return APR_SUCCESS;
  }
  
! static apr_status_t writev_it_all(apr_socket_t *s,
!                                   struct iovec *vec, int nvec,
!                                   apr_size_t len, apr_size_t *nbytes)
! {
!     apr_size_t bytes_written = 0;
!     apr_status_t rv;
!     apr_size_t n = len;
!     int i = 0;
! 
!     *nbytes = 0;
  
!     /* XXX handle checking for non-blocking socket */
!     while (bytes_written != len) {
!         rv = apr_socket_sendv(s, vec + i, nvec - i, &n);
!         *nbytes += n;
!         bytes_written += n;
!         if (rv != APR_SUCCESS)
!             return rv;
! 
!         /* If the write did not complete, adjust the iovecs and issue
!          * apr_socket_sendv again
!          */
!         if (bytes_written < len) {
!             /* Skip over the vectors that have already been written */
!             apr_size_t cnt = vec[i].iov_len;
!             while (n >= cnt && i + 1 < nvec) {
!                 i++;
!                 cnt += vec[i].iov_len;
!             }
! 
!             if (n < cnt) {
!                 /* Handle partial write of vec i */
!                 vec[i].iov_base = (char *) vec[i].iov_base +
!                     (vec[i].iov_len - (cnt - n));
!                 vec[i].iov_len = cnt -n;
!             }
!         }
! 
!         n = len - bytes_written;
!     }
  
!     return APR_SUCCESS;
! }
  
! /* sendfile_it_all()
!  *  send the entire file using sendfile()
!  *  handle partial writes
!  *  return only when all bytes have been sent or an error is encountered.
   */
  
! #if APR_HAS_SENDFILE
! static apr_status_t sendfile_it_all(core_net_rec *c,
!                                     apr_file_t *fd,
!                                     apr_hdtr_t *hdtr,
!                                     apr_off_t   file_offset,
!                                     apr_size_t  file_bytes_left,
!                                     apr_size_t  total_bytes_left,
!                                     apr_size_t  *bytes_sent,
!                                     apr_int32_t flags)
  {
      apr_status_t rv;
- #ifdef AP_DEBUG
-     apr_interval_time_t timeout = 0;
- #endif
- 
-     AP_DEBUG_ASSERT((apr_socket_timeout_get(c->client_socket, &timeout)
-                          == APR_SUCCESS)
-                     && timeout > 0);  /* socket must be in timeout mode */
- 
-     /* Reset the bytes_sent field */
-     *bytes_sent = 0;
  
!     do {
!         apr_size_t tmplen = file_bytes_left;
! 
!         rv = apr_socket_sendfile(c->client_socket, fd, hdtr, &file_offset, &tmplen,
!                                  flags);
!         *bytes_sent += tmplen;
!         total_bytes_left -= tmplen;
!         if (!total_bytes_left || rv != APR_SUCCESS) {
!             return rv;        /* normal case & error exit */
          }
  
!         AP_DEBUG_ASSERT(total_bytes_left > 0 && tmplen > 0);
! 
!         /* partial write, oooh noooo...
!          * Skip over any header data which was written
           */
!         while (tmplen && hdtr->numheaders) {
!             if (tmplen >= hdtr->headers[0].iov_len) {
!                 tmplen -= hdtr->headers[0].iov_len;
!                 --hdtr->numheaders;
!                 ++hdtr->headers;
!             }
!             else {
!                 char *iov_base = (char *)hdtr->headers[0].iov_base;
  
!                 hdtr->headers[0].iov_len -= tmplen;
!                 iov_base += tmplen;
!                 hdtr->headers[0].iov_base = iov_base;
!                 tmplen = 0;
              }
          }
  
!         /* Skip over any file data which was written */
! 
!         if (tmplen <= file_bytes_left) {
!             file_offset += tmplen;
!             file_bytes_left -= tmplen;
!             continue;
          }
  
!         tmplen -= file_bytes_left;
!         file_bytes_left = 0;
!         file_offset = 0;
  
!         /* Skip over any trailer data which was written */
  
!         while (tmplen && hdtr->numtrailers) {
!             if (tmplen >= hdtr->trailers[0].iov_len) {
!                 tmplen -= hdtr->trailers[0].iov_len;
!                 --hdtr->numtrailers;
!                 ++hdtr->trailers;
              }
!             else {
!                 char *iov_base = (char *)hdtr->trailers[0].iov_base;
! 
!                 hdtr->trailers[0].iov_len -= tmplen;
!                 iov_base += tmplen;
!                 hdtr->trailers[0].iov_base = iov_base;
!                 tmplen = 0;
              }
          }
-     } while (1);
- }
- #endif
- 
- /*
-  * emulate_sendfile()
-  * Sends the contents of file fd along with header/trailer bytes, if any,
-  * to the network. emulate_sendfile will return only when all the bytes have been
-  * sent (i.e., it handles partial writes) or on a network error condition.
-  */
- static apr_status_t emulate_sendfile(core_net_rec *c, apr_file_t *fd,
-                                      apr_hdtr_t *hdtr, apr_off_t offset,
-                                      apr_size_t length, apr_size_t *nbytes)
- {
-     apr_status_t rv = APR_SUCCESS;
-     apr_size_t togo;        /* Remaining number of bytes in the file to send */
-     apr_size_t sendlen = 0;
-     apr_size_t bytes_sent;
-     apr_int32_t i;
-     apr_off_t o;             /* Track the file offset for partial writes */
-     char buffer[8192];
- 
-     *nbytes = 0;
- 
-     /* Send the headers
-      * writev_it_all handles partial writes.
-      * XXX: optimization... if headers are less than MIN_WRITE_SIZE, copy
-      * them into buffer
-      */
-     if (hdtr && hdtr->numheaders > 0 ) {
-         for (i = 0; i < hdtr->numheaders; i++) {
-             sendlen += hdtr->headers[i].iov_len;
-         }
- 
-         rv = writev_it_all(c->client_socket, hdtr->headers, hdtr->numheaders,
-                            sendlen, &bytes_sent);
-         *nbytes += bytes_sent;     /* track total bytes sent */
      }
  
!     /* Seek the file to 'offset' */
!     if (offset >= 0 && rv == APR_SUCCESS) {
!         rv = apr_file_seek(fd, APR_SET, &offset);
      }
! 
!     /* Send the file, making sure to handle partial writes */
!     togo = length;
!     while (rv == APR_SUCCESS && togo) {
!         sendlen = togo > sizeof(buffer) ? sizeof(buffer) : togo;
!         o = 0;
!         rv = apr_file_read(fd, buffer, &sendlen);
!         while (rv == APR_SUCCESS && sendlen) {
!             bytes_sent = sendlen;
!             rv = apr_socket_send(c->client_socket, &buffer[o], &bytes_sent);
!             *nbytes += bytes_sent;
!             if (rv == APR_SUCCESS) {
!                 sendlen -= bytes_sent; /* sendlen != bytes_sent ==> partial write */
!                 o += bytes_sent;       /* o is where we are in the buffer */
!                 togo -= bytes_sent;    /* track how much of the file we've sent */
!             }
          }
      }
  
!     /* Send the trailers
!      * XXX: optimization... if it will fit, send this on the last send in the
!      * loop above
!      */
!     sendlen = 0;
!     if ( rv == APR_SUCCESS && hdtr && hdtr->numtrailers > 0 ) {
!         for (i = 0; i < hdtr->numtrailers; i++) {
!             sendlen += hdtr->trailers[i].iov_len;
!         }
!         rv = writev_it_all(c->client_socket, hdtr->trailers, hdtr->numtrailers,
!                            sendlen, &bytes_sent);
!         *nbytes += bytes_sent;
!     }
  
!     return rv;
  }
  
  #ifndef APR_MAX_IOVEC_SIZE
--- 313,535 ----
      return APR_SUCCESS;
  }
  
! static void setaside_remaining_output(ap_filter_t *f,
!                                       core_output_filter_ctx_t *ctx,
!                                       apr_bucket_brigade *bb,
!                                       conn_rec *c);
! 
! static apr_status_t send_brigade_nonblocking(apr_socket_t *s,
!                                              apr_bucket_brigade *bb,
!                                              apr_size_t *bytes_written,
!                                              conn_rec *c);
! 
! static void remove_empty_buckets(apr_bucket_brigade *bb);
! 
! static apr_status_t send_brigade_blocking(apr_socket_t *s,
!                                           apr_bucket_brigade *bb,
!                                           apr_size_t *bytes_written,
!                                           conn_rec *c);
! 
! static apr_status_t writev_nonblocking(apr_socket_t *s,
!                                        struct iovec *vec, apr_size_t nvec,
!                                        apr_bucket_brigade *bb,
!                                        apr_size_t *cumulative_bytes_written,
!                                        conn_rec *c);
  
! #if APR_HAS_SENDFILE
! static apr_status_t sendfile_nonblocking(apr_socket_t *s,
!                                          apr_bucket *bucket,
!                                          apr_size_t *cumulative_bytes_written,
!                                          conn_rec *c);
! #endif
  
! #define THRESHOLD_MIN_WRITE 4096
! #define THRESHOLD_MAX_BUFFER 65536
  
! /* Optional function coming from mod_logio, used for logging of output
!  * traffic
   */
+ extern APR_OPTIONAL_FN_TYPE(ap_logio_add_bytes_out) *ap__logio_add_bytes_out;
  
! apr_status_t ap_core_output_filter(ap_filter_t *f, apr_bucket_brigade *new_bb)
  {
+     conn_rec *c = f->c;
+     core_net_rec *net = f->ctx;
+     core_output_filter_ctx_t *ctx = net->out_ctx;
+     apr_bucket_brigade *bb = NULL;
+     apr_bucket *bucket, *next;
+     apr_size_t bytes_in_brigade, non_file_bytes_in_brigade;
      apr_status_t rv;
  
!     /* Fail quickly if the connection has already been aborted. */
!     if (c->aborted) {
!         if (new_bb != NULL) {
!             apr_brigade_cleanup(new_bb);
          }
+         return APR_ECONNABORTED;
+     }
  
!     if (ctx == NULL) {
!         ctx = apr_pcalloc(c->pool, sizeof(*ctx));
!         net->out_ctx = (core_output_filter_ctx_t *)ctx;
!         rv = apr_socket_opt_set(net->client_socket, APR_SO_NONBLOCK, 1);
!         if (rv != APR_SUCCESS) {
!             return rv;
!         }
!         /*
!          * Need to create tmp brigade with correct lifetime. Passing
!          * NULL to apr_brigade_split_ex would result in a brigade
!          * allocated from bb->pool which might be wrong.
           */
!         ctx->tmp_flush_bb = apr_brigade_create(c->pool, c->bucket_alloc);
!     }
  
!     if (new_bb != NULL) {
!         for (bucket = APR_BRIGADE_FIRST(new_bb); bucket != APR_BRIGADE_SENTINEL(new_bb); bucket = APR_BUCKET_NEXT(bucket)) {
!             if (bucket->length > 0) {
!                 ctx->bytes_in += bucket->length;
              }
          }
+         bb = new_bb;
+     }
  
!     if ((ctx->buffered_bb != NULL) &&
!         !APR_BRIGADE_EMPTY(ctx->buffered_bb)) {
!         if (new_bb != NULL) {
!             APR_BRIGADE_PREPEND(bb, ctx->buffered_bb);
!         }
!         else {
!             bb = ctx->buffered_bb;
          }
+         c->data_in_output_filters = 0;
+     }
+     else if (new_bb == NULL) {
+         return APR_SUCCESS;
+     }
  
!     /* Scan through the brigade and decide whether to attempt a write,
!      * based on the following rules:
!      *
!      *  1) The new_bb is null: Do a nonblocking write of as much as
!      *     possible: do a nonblocking write of as much data as possible,
!      *     then save the rest in ctx->buffered_bb.  (If new_bb == NULL,
!      *     it probably means that the MPM is doing asynchronous write
!      *     completion and has just determined that this connection
!      *     is writable.)
!      *
!      *  2) The brigade contains a flush bucket: Do a blocking write
!      *     of everything up that point.
!      *
!      *  3) The request is in CONN_STATE_HANDLER state, and the brigade
!      *     contains at least THRESHOLD_MAX_BUFFER bytes in non-file
!      *     buckets: Do blocking writes until the amount of data in the
!      *     buffer is less than THRESHOLD_MAX_BUFFER.  (The point of this
!      *     rule is to provide flow control, in case a handler is
!      *     streaming out lots of data faster than the data can be
!      *     sent to the client.)
!      *
!      *  4) The brigade contains at least THRESHOLD_MIN_WRITE
!      *     bytes: Do a nonblocking write of as much data as possible,
!      *     then save the rest in ctx->buffered_bb.
!      */
  
!     if (new_bb == NULL) {
!         rv = send_brigade_nonblocking(net->client_socket, bb,
!                                       &(ctx->bytes_written), c);
!         if (APR_STATUS_IS_EAGAIN(rv)) {
!             rv = APR_SUCCESS;
!         }
!         else if (rv != APR_SUCCESS) {
!             /* The client has aborted the connection */
!             c->aborted = 1;
!         }
!         setaside_remaining_output(f, ctx, bb, c);
!         return rv;
!     }
  
!     bytes_in_brigade = 0;
!     non_file_bytes_in_brigade = 0;
!     for (bucket = APR_BRIGADE_FIRST(bb); bucket != APR_BRIGADE_SENTINEL(bb);
!          bucket = next) {
!         next = APR_BUCKET_NEXT(bucket);
!         if (APR_BUCKET_IS_FLUSH(bucket)) {
!             ctx->tmp_flush_bb = apr_brigade_split_ex(bb, next, ctx->tmp_flush_bb);
!             rv = send_brigade_blocking(net->client_socket, bb,
!                                        &(ctx->bytes_written), c);
!             if (rv != APR_SUCCESS) {
!                 /* The client has aborted the connection */
!                 c->aborted = 1;
!                 return rv;
              }
!             APR_BRIGADE_CONCAT(bb, ctx->tmp_flush_bb);
!             next = APR_BRIGADE_FIRST(bb);
!             bytes_in_brigade = 0;
!             non_file_bytes_in_brigade = 0;
!         }
!         else if (!APR_BUCKET_IS_METADATA(bucket)) {
!             if (bucket->length < 0) {
!                 const char *data;
!                 apr_size_t length;
!                 /* XXX support nonblocking read here? */
!                 rv = apr_bucket_read(bucket, &data, &length, APR_BLOCK_READ);
!                 if (rv != APR_SUCCESS) {
!                     return rv;
!                 }
!                 /* reading may have split the bucket, so recompute next: */
!                 next = APR_BUCKET_NEXT(bucket);
!             }
!             bytes_in_brigade += bucket->length;
!             if (!APR_BUCKET_IS_FILE(bucket)) {
!                 non_file_bytes_in_brigade += bucket->length;
              }
          }
      }
  
!     if (non_file_bytes_in_brigade >= THRESHOLD_MAX_BUFFER) {
!         /* ### Writing the entire brigade may be excessive; we really just
!          * ### need to send enough data to be under THRESHOLD_MAX_BUFFER.
!          */
!         rv = send_brigade_blocking(net->client_socket, bb,
!                                    &(ctx->bytes_written), c);
!         if (rv != APR_SUCCESS) {
!             /* The client has aborted the connection */
!             c->aborted = 1;
!             return rv;
!         }
      }
!     else if (bytes_in_brigade >= THRESHOLD_MIN_WRITE) {
!         rv = send_brigade_nonblocking(net->client_socket, bb,
!                                       &(ctx->bytes_written), c);
!         if ((rv != APR_SUCCESS) && (!APR_STATUS_IS_EAGAIN(rv))) {
!             /* The client has aborted the connection */
!             c->aborted = 1;
!             return rv;
          }
      }
  
!     setaside_remaining_output(f, ctx, bb, c);
!     return APR_SUCCESS;
! }
  
! static void setaside_remaining_output(ap_filter_t *f,
!                                       core_output_filter_ctx_t *ctx,
!                                       apr_bucket_brigade *bb,
!                                       conn_rec *c)
! {
!     if (bb == NULL) {
!         return;
!     }
!     remove_empty_buckets(bb);
!     if (!APR_BRIGADE_EMPTY(bb)) {
!         c->data_in_output_filters = 1;
!         if (bb != ctx->buffered_bb) {
!             /* XXX should this use a separate deferred write pool, like
!              * the original ap_core_output_filter?
!              */
!             ap_save_brigade(f, &(ctx->buffered_bb), &bb, c->pool);
!             apr_brigade_cleanup(bb);
!         }
!     }
  }
  
  #ifndef APR_MAX_IOVEC_SIZE
*************** static apr_status_t emulate_sendfile(cor
*** 527,924 ****
  #endif
  #endif
  
! /* Optional function coming from mod_logio, used for logging of output
!  * traffic
!  */
! extern APR_OPTIONAL_FN_TYPE(ap_logio_add_bytes_out) *logio_add_bytes_out;
! 
! apr_status_t ap_core_output_filter(ap_filter_t *f, apr_bucket_brigade *b)
  {
      apr_status_t rv;
!     apr_bucket_brigade *more;
!     conn_rec *c = f->c;
!     core_net_rec *net = f->ctx;
!     core_output_filter_ctx_t *ctx = net->out_ctx;
!     apr_read_type_e eblock = APR_NONBLOCK_READ;
!     apr_pool_t *input_pool = b->p;
! 
!     /* Fail quickly if the connection has already been aborted. */
!     if (c->aborted) {
!         apr_brigade_cleanup(b);
!         return APR_ECONNABORTED;
!     }
! 
!     if (ctx == NULL) {
!         ctx = apr_pcalloc(c->pool, sizeof(*ctx));
!         net->out_ctx = ctx;
!     }
! 
!     /* If we have a saved brigade, concatenate the new brigade to it */
!     if (ctx->b) {
!         APR_BRIGADE_CONCAT(ctx->b, b);
!         b = ctx->b;
!         ctx->b = NULL;
!     }
! 
!     /* Perform multiple passes over the brigade, sending batches of output
!        to the connection. */
!     while (b && !APR_BRIGADE_EMPTY(b)) {
!         apr_size_t nbytes = 0;
!         apr_bucket *last_e = NULL; /* initialized for debugging */
!         apr_bucket *e;
  
!         /* one group of iovecs per pass over the brigade */
!         apr_size_t nvec = 0;
!         apr_size_t nvec_trailers = 0;
!         struct iovec vec[MAX_IOVEC_TO_WRITE];
!         struct iovec vec_trailers[MAX_IOVEC_TO_WRITE];
! 
!         /* one file per pass over the brigade */
!         apr_file_t *fd = NULL;
!         apr_size_t flen = 0;
!         apr_off_t foffset = 0;
  
!         /* keep track of buckets that we've concatenated
!          * to avoid small writes
!          */
!         apr_bucket *last_merged_bucket = NULL;
! 
!         /* tail of brigade if we need another pass */
!         more = NULL;
! 
!         /* Iterate over the brigade: collect iovecs and/or a file */
!         for (e = APR_BRIGADE_FIRST(b);
!              e != APR_BRIGADE_SENTINEL(b);
!              e = APR_BUCKET_NEXT(e))
!         {
!             /* keep track of the last bucket processed */
!             last_e = e;
!             if (APR_BUCKET_IS_EOS(e) || AP_BUCKET_IS_EOC(e)) {
!                 break;
!             }
!             else if (APR_BUCKET_IS_FLUSH(e)) {
!                 if (e != APR_BRIGADE_LAST(b)) {
!                     more = apr_brigade_split(b, APR_BUCKET_NEXT(e));
!                 }
!                 break;
!             }
! 
!             /* It doesn't make any sense to use sendfile for a file bucket
!              * that represents 10 bytes.
               */
-             else if (APR_BUCKET_IS_FILE(e)
-                      && (e->length >= AP_MIN_SENDFILE_BYTES)) {
-                 apr_bucket_file *a = e->data;
- 
-                 /* We can't handle more than one file bucket at a time
-                  * so we split here and send the file we have already
-                  * found.
-                  */
-                 if (fd) {
-                     more = apr_brigade_split(b, e);
-                     break;
-                 }
- 
-                 fd = a->fd;
-                 flen = e->length;
-                 foffset = e->start;
-             }
-             else {
-                 const char *str;
-                 apr_size_t n;
  
!                 rv = apr_bucket_read(e, &str, &n, eblock);
!                 if (APR_STATUS_IS_EAGAIN(rv)) {
!                     /* send what we have so far since we shouldn't expect more
!                      * output for a while...  next time we read, block
!                      */
!                     more = apr_brigade_split(b, e);
!                     eblock = APR_BLOCK_READ;
!                     break;
!                 }
!                 eblock = APR_NONBLOCK_READ;
!                 if (n) {
!                     if (!fd) {
!                         if (nvec == MAX_IOVEC_TO_WRITE) {
!                             /* woah! too many. buffer them up, for use later. */
!                             apr_bucket *temp, *next;
!                             apr_bucket_brigade *temp_brig;
! 
!                             if (nbytes >= AP_MIN_BYTES_TO_WRITE) {
!                                 /* We have enough data in the iovec
!                                  * to justify doing a writev
!                                  */
!                                 more = apr_brigade_split(b, e);
!                                 break;
!                             }
! 
!                             /* Create a temporary brigade as a means
!                              * of concatenating a bunch of buckets together
!                              */
!                             temp_brig = apr_brigade_create(f->c->pool,
!                                                        f->c->bucket_alloc);
!                             if (last_merged_bucket) {
!                                 /* If we've concatenated together small
!                                  * buckets already in a previous pass,
!                                  * the initial buckets in this brigade
!                                  * are heap buckets that may have extra
!                                  * space left in them (because they
!                                  * were created by apr_brigade_write()).
!                                  * We can take advantage of this by
!                                  * building the new temp brigade out of
!                                  * these buckets, so that the content
!                                  * in them doesn't have to be copied again.
!                                  */
!                                 APR_BRIGADE_PREPEND(b, temp_brig);
!                                 brigade_move(temp_brig, b, APR_BUCKET_NEXT(last_merged_bucket));
!                             }
! 
!                             temp = APR_BRIGADE_FIRST(b);
!                             while (temp != e) {
!                                 apr_bucket *d;
!                                 rv = apr_bucket_read(temp, &str, &n, APR_BLOCK_READ);
!                                 apr_brigade_write(temp_brig, NULL, NULL, str, n);
!                                 d = temp;
!                                 temp = APR_BUCKET_NEXT(temp);
!                                 apr_bucket_delete(d);
!                             }
! 
!                             nvec = 0;
!                             nbytes = 0;
!                             temp = APR_BRIGADE_FIRST(temp_brig);
!                             APR_BUCKET_REMOVE(temp);
!                             APR_BRIGADE_INSERT_HEAD(b, temp);
!                             apr_bucket_read(temp, &str, &n, APR_BLOCK_READ);
!                             vec[nvec].iov_base = (char*) str;
!                             vec[nvec].iov_len = n;
!                             nvec++;
! 
!                             /* Just in case the temporary brigade has
!                              * multiple buckets, recover the rest of
!                              * them and put them in the brigade that
!                              * we're sending.
!                              */
!                             for (next = APR_BRIGADE_FIRST(temp_brig);
!                                  next != APR_BRIGADE_SENTINEL(temp_brig);
!                                  next = APR_BRIGADE_FIRST(temp_brig)) {
!                                 APR_BUCKET_REMOVE(next);
!                                 APR_BUCKET_INSERT_AFTER(temp, next);
!                                 temp = next;
!                                 apr_bucket_read(next, &str, &n,
!                                                 APR_BLOCK_READ);
!                                 vec[nvec].iov_base = (char*) str;
!                                 vec[nvec].iov_len = n;
!                                 nvec++;
!                             }
! 
!                             apr_brigade_destroy(temp_brig);
! 
!                             last_merged_bucket = temp;
!                             e = temp;
!                             last_e = e;
!                         }
!                         else {
!                             vec[nvec].iov_base = (char*) str;
!                             vec[nvec].iov_len = n;
!                             nvec++;
!                         }
!                     }
!                     else {
!                         /* The bucket is a trailer to a file bucket */
! 
!                         if (nvec_trailers == MAX_IOVEC_TO_WRITE) {
!                             /* woah! too many. stop now. */
!                             more = apr_brigade_split(b, e);
!                             break;
!                         }
! 
!                         vec_trailers[nvec_trailers].iov_base = (char*) str;
!                         vec_trailers[nvec_trailers].iov_len = n;
!                         nvec_trailers++;
                      }
- 
-                     nbytes += n;
                  }
              }
          }
! 
! 
!         /* Completed iterating over the brigade, now determine if we want
!          * to buffer the brigade or send the brigade out on the network.
!          *
!          * Save if we haven't accumulated enough bytes to send, the connection
!          * is not about to be closed, and:
!          *
!          *   1) we didn't see a file, we don't have more passes over the
!          *      brigade to perform,  AND we didn't stop at a FLUSH bucket.
!          *      (IOW, we will save plain old bytes such as HTTP headers)
!          * or
!          *   2) we hit the EOS and have a keep-alive connection
!          *      (IOW, this response is a bit more complex, but we save it
!          *       with the hope of concatenating with another response)
!          */
!         if (nbytes + flen < AP_MIN_BYTES_TO_WRITE
!             && !AP_BUCKET_IS_EOC(last_e)
!             && ((!fd && !more && !APR_BUCKET_IS_FLUSH(last_e))
!                 || (APR_BUCKET_IS_EOS(last_e)
!                     && c->keepalive == AP_CONN_KEEPALIVE))) {
! 
!             /* NEVER save an EOS in here.  If we are saving a brigade with
!              * an EOS bucket, then we are doing keepalive connections, and
!              * we want to process to second request fully.
!              */
!             if (APR_BUCKET_IS_EOS(last_e)) {
!                 apr_bucket *bucket;
!                 int file_bucket_saved = 0;
!                 apr_bucket_delete(last_e);
!                 for (bucket = APR_BRIGADE_FIRST(b);
!                      bucket != APR_BRIGADE_SENTINEL(b);
!                      bucket = APR_BUCKET_NEXT(bucket)) {
! 
!                     /* Do a read on each bucket to pull in the
!                      * data from pipe and socket buckets, so
!                      * that we don't leave their file descriptors
!                      * open indefinitely.  Do the same for file
!                      * buckets, with one exception: allow the
!                      * first file bucket in the brigade to remain
!                      * a file bucket, so that we don't end up
!                      * doing an mmap+memcpy every time a client
!                      * requests a <8KB file over a keepalive
!                      * connection.
!                      */
!                     if (APR_BUCKET_IS_FILE(bucket) && !file_bucket_saved) {
!                         file_bucket_saved = 1;
!                     }
!                     else {
!                         const char *buf;
!                         apr_size_t len = 0;
!                         rv = apr_bucket_read(bucket, &buf, &len,
!                                              APR_BLOCK_READ);
!                         if (rv != APR_SUCCESS) {
!                             ap_log_cerror(APLOG_MARK, APLOG_ERR, rv,
!                                           c, "core_output_filter:"
!                                           " Error reading from bucket.");
!                             return HTTP_INTERNAL_SERVER_ERROR;
!                         }
!                     }
!                 }
              }
!             if (!ctx->deferred_write_pool) {
!                 apr_pool_create(&ctx->deferred_write_pool, c->pool);
!                 apr_pool_tag(ctx->deferred_write_pool, "deferred_write");
              }
-             ap_save_brigade(f, &ctx->b, &b, ctx->deferred_write_pool);
- 
-             return APR_SUCCESS;
          }
  
!         if (fd) {
!             apr_hdtr_t hdtr;
!             apr_size_t bytes_sent;
  
! #if APR_HAS_SENDFILE
!             apr_int32_t flags = 0;
! #endif
  
!             memset(&hdtr, '\0', sizeof(hdtr));
!             if (nvec) {
!                 hdtr.numheaders = nvec;
!                 hdtr.headers = vec;
!             }
  
!             if (nvec_trailers) {
!                 hdtr.numtrailers = nvec_trailers;
!                 hdtr.trailers = vec_trailers;
!             }
  
! #if APR_HAS_SENDFILE
!             if (apr_file_flags_get(fd) & APR_SENDFILE_ENABLED) {
  
!                 if (c->keepalive == AP_CONN_CLOSE && APR_BUCKET_IS_EOS(last_e)) {
!                     /* Prepare the socket to be reused */
!                     flags |= APR_SENDFILE_DISCONNECT_SOCKET;
!                 }
! 
!                 rv = sendfile_it_all(net,      /* the network information   */
!                                      fd,       /* the file to send          */
!                                      &hdtr,    /* header and trailer iovecs */
!                                      foffset,  /* offset in the file to begin
!                                                   sending from              */
!                                      flen,     /* length of file            */
!                                      nbytes + flen, /* total length including
!                                                        headers              */
!                                      &bytes_sent,   /* how many bytes were
!                                                        sent                 */
!                                      flags);   /* apr_sendfile flags        */
              }
!             else
! #endif
!             {
!                 rv = emulate_sendfile(net, fd, &hdtr, foffset, flen,
!                                       &bytes_sent);
              }
- 
-             if (logio_add_bytes_out && bytes_sent > 0)
-                 logio_add_bytes_out(c, bytes_sent);
- 
-             fd = NULL;
          }
!         else {
!             apr_size_t bytes_sent;
! 
!             rv = writev_it_all(net->client_socket,
!                                vec, nvec,
!                                nbytes, &bytes_sent);
! 
!             if (logio_add_bytes_out && bytes_sent > 0)
!                 logio_add_bytes_out(c, bytes_sent);
!         }
! 
!         apr_brigade_cleanup(b);
  
!         /* drive cleanups for resources which were set aside
!          * this may occur before or after termination of the request which
!          * created the resource
!          */
!         if (ctx->deferred_write_pool) {
!             if (more && more->p == ctx->deferred_write_pool) {
!                 /* "more" belongs to the deferred_write_pool,
!                  * which is about to be cleared.
!                  */
!                 if (APR_BRIGADE_EMPTY(more)) {
!                     more = NULL;
                  }
                  else {
!                     /* uh oh... change more's lifetime
!                      * to the input brigade's lifetime
!                      */
!                     apr_bucket_brigade *tmp_more = more;
!                     more = NULL;
!                     ap_save_brigade(f, &more, &tmp_more, input_pool);
                  }
              }
-             apr_pool_clear(ctx->deferred_write_pool);
          }
- 
          if (rv != APR_SUCCESS) {
!             ap_log_cerror(APLOG_MARK, APLOG_INFO, rv, c,
!                           "core_output_filter: writing data to the network");
! 
!             if (more)
!                 apr_brigade_cleanup(more);
  
!             /* No need to check for SUCCESS, we did that above. */
!             if (!APR_STATUS_IS_EAGAIN(rv)) {
!                 c->aborted = 1;
!                 return APR_ECONNABORTED;
!             }
  
!             return APR_SUCCESS;
!         }
  
!         b = more;
!         more = NULL;
!     }  /* end while () */
  
!     return APR_SUCCESS;
  }
--- 542,808 ----
  #endif
  #endif
  
! static apr_status_t send_brigade_nonblocking(apr_socket_t *s,
!                                              apr_bucket_brigade *bb,
!                                              apr_size_t *bytes_written,
!                                              conn_rec *c)
  {
+     apr_bucket *bucket, *next;
      apr_status_t rv;
!     struct iovec vec[MAX_IOVEC_TO_WRITE];
!     apr_size_t nvec = 0;
  
!     remove_empty_buckets(bb);
  
!     for (bucket = APR_BRIGADE_FIRST(bb);
!          bucket != APR_BRIGADE_SENTINEL(bb);
!          bucket = next) {
!         int did_sendfile = 0;
!         next = APR_BUCKET_NEXT(bucket);
! #if APR_HAS_SENDFILE
!         if (APR_BUCKET_IS_FILE(bucket)) {
!             apr_bucket_file *file_bucket = (apr_bucket_file *)(bucket->data);
!             apr_file_t *fd = file_bucket->fd;
!             /* Use sendfile to send this file unless:
!              *   - the platform doesn't support sendfile,
!              *   - the file is too small for sendfile to be useful, or
!              *   - sendfile is disabled in the httpd config via "EnableSendfile off"
               */
  
!             if ((apr_file_flags_get(fd) & APR_SENDFILE_ENABLED) &&
!                 (bucket->length >= AP_MIN_SENDFILE_BYTES)) {
!                 did_sendfile = 1;
!                 if (nvec > 0) {
!                     (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 1);
!                     rv = writev_nonblocking(s, vec, nvec, bb, bytes_written, c);
!                     nvec = 0;
!                     if (rv != APR_SUCCESS) {
!                         (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 0);
!                         return rv;
                      }
                  }
+                 rv = sendfile_nonblocking(s, bucket, bytes_written, c);
+                 if (nvec > 0) {
+                     (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 0);
+                 }
+                 if (rv != APR_SUCCESS) {
+                     return rv;
+                 }
+                 break;
              }
          }
! #endif /* APR_HAS_SENDFILE */
!         if (!did_sendfile && !APR_BUCKET_IS_METADATA(bucket)) {
!             const char *data;
!             apr_size_t length;
!             rv = apr_bucket_read(bucket, &data, &length, APR_BLOCK_READ);
!             if (rv != APR_SUCCESS) {
!                 return rv;
              }
!             /* reading may have split the bucket, so recompute next: */
!             next = APR_BUCKET_NEXT(bucket);
!             vec[nvec].iov_base = (char *)data;
!             vec[nvec].iov_len = length;
!             nvec++;
!             if (nvec == MAX_IOVEC_TO_WRITE) {
!                 rv = writev_nonblocking(s, vec, nvec, bb, bytes_written, c);
!                 nvec = 0;
!                 if (rv != APR_SUCCESS) {
!                     return rv;
!                 }
!                 break;
              }
          }
+     }
  
!     if (nvec > 0) {
!         rv = writev_nonblocking(s, vec, nvec, bb, bytes_written, c);
!         if (rv != APR_SUCCESS) {
!             return rv;
!         }
!     }
  
!     remove_empty_buckets(bb);
  
!     return APR_SUCCESS;
! }
  
! static void remove_empty_buckets(apr_bucket_brigade *bb)
! {
!     apr_bucket *bucket;
!     while (((bucket = APR_BRIGADE_FIRST(bb)) != APR_BRIGADE_SENTINEL(bb)) &&
!            (APR_BUCKET_IS_METADATA(bucket) || (bucket->length == 0))) {
!         APR_BUCKET_REMOVE(bucket);
!         apr_bucket_destroy(bucket);
!     }
! }
  
! static apr_status_t send_brigade_blocking(apr_socket_t *s,
!                                           apr_bucket_brigade *bb,
!                                           apr_size_t *bytes_written,
!                                           conn_rec *c)
! {
!     apr_status_t rv;
  
!     rv = APR_SUCCESS;
!     while (!APR_BRIGADE_EMPTY(bb)) {
!         rv = send_brigade_nonblocking(s, bb, bytes_written, c);
!         if (rv != APR_SUCCESS) {
!             if (APR_STATUS_IS_EAGAIN(rv)) {
!                 /* Wait until we can send more data */
!                 apr_int32_t nsds;
!                 apr_interval_time_t timeout;
!                 apr_pollfd_t pollset;
! 
!                 pollset.p = c->pool;
!                 pollset.desc_type = APR_POLL_SOCKET;
!                 pollset.reqevents = APR_POLLOUT;
!                 pollset.desc.s = s;
!                 apr_socket_timeout_get(s, &timeout);
!                 rv = apr_poll(&pollset, 1, &nsds, timeout);
!                 if (rv != APR_SUCCESS) {
!                     break;
!                 }
              }
!             else {
!                 break;
              }
          }
!     }
!     return rv;
! }
  
! static apr_status_t writev_nonblocking(apr_socket_t *s,
!                                        struct iovec *vec, apr_size_t nvec,
!                                        apr_bucket_brigade *bb,
!                                        apr_size_t *cumulative_bytes_written,
!                                        conn_rec *c)
! {
!     apr_status_t rv = APR_SUCCESS, arv;
!     apr_size_t bytes_written = 0, bytes_to_write = 0;
!     apr_size_t i, offset;
!     apr_interval_time_t old_timeout;
! 
!     arv = apr_socket_timeout_get(s, &old_timeout);
!     if (arv != APR_SUCCESS) {
!         return arv;
!     }
!     arv = apr_socket_timeout_set(s, 0);
!     if (arv != APR_SUCCESS) {
!         return arv;
!     }
! 
!     for (i = 0; i < nvec; i++) {
!         bytes_to_write += vec[i].iov_len;
!     }
!     offset = 0;
!     while (bytes_written < bytes_to_write) {
!         apr_size_t n = 0;
!         rv = apr_socket_sendv(s, vec + offset, nvec - offset, &n);
!         if (n > 0) {
!             bytes_written += n;
!             for (i = offset; i < nvec; ) {
!                 apr_bucket *bucket = APR_BRIGADE_FIRST(bb);
!                 if (APR_BUCKET_IS_METADATA(bucket)) {
!                     APR_BUCKET_REMOVE(bucket);
!                     apr_bucket_destroy(bucket);
!                 }
!                 else if (n >= vec[i].iov_len) {
!                     APR_BUCKET_REMOVE(bucket);
!                     apr_bucket_destroy(bucket);
!                     offset++;
!                     n -= vec[i++].iov_len;
                  }
                  else {
!                     apr_bucket_split(bucket, n);
!                     APR_BUCKET_REMOVE(bucket);
!                     apr_bucket_destroy(bucket);
!                     vec[i].iov_len -= n;
!                     vec[i].iov_base = (char *) vec[i].iov_base + n;
!                     break;
                  }
              }
          }
          if (rv != APR_SUCCESS) {
!             break;
!         }
!     }
!     if ((ap__logio_add_bytes_out != NULL) && (bytes_written > 0)) {
!         ap__logio_add_bytes_out(c, bytes_written);
!     }
!     *cumulative_bytes_written += bytes_written;
  
!     arv = apr_socket_timeout_set(s, old_timeout);
!     if ((arv != APR_SUCCESS) && (rv == APR_SUCCESS)) {
!         return arv;
!     }
!     else {
!         return rv;
!     }
! }
  
! #if APR_HAS_SENDFILE
  
! static apr_status_t sendfile_nonblocking(apr_socket_t *s,
!                                          apr_bucket *bucket,
!                                          apr_size_t *cumulative_bytes_written,
!                                          conn_rec *c)
! {
!     apr_status_t rv = APR_SUCCESS;
!     apr_bucket_file *file_bucket;
!     apr_file_t *fd;
!     apr_size_t file_length;
!     apr_off_t file_offset;
!     apr_size_t bytes_written = 0;
  
!     if (!APR_BUCKET_IS_FILE(bucket)) {
!         ap_log_error(APLOG_MARK, APLOG_ERR, rv, c->base_server,
!                      "core_filter: sendfile_nonblocking: "
!                      "this should never happen");
!         return APR_EGENERAL;
!     }
!     file_bucket = (apr_bucket_file *)(bucket->data);
!     fd = file_bucket->fd;
!     file_length = bucket->length;
!     file_offset = bucket->start;
! 
!     if (bytes_written < file_length) {
!         apr_size_t n = file_length - bytes_written;
!         apr_status_t arv;
!         apr_interval_time_t old_timeout;
! 
!         arv = apr_socket_timeout_get(s, &old_timeout);
!         if (arv != APR_SUCCESS) {
!             return arv;
!         }
!         arv = apr_socket_timeout_set(s, 0);
!         if (arv != APR_SUCCESS) {
!             return arv;
!         }
!         rv = apr_socket_sendfile(s, fd, NULL, &file_offset, &n, 0);
!         if (rv == APR_SUCCESS) {
!             bytes_written += n;
!             file_offset += n;
!         }
!         arv = apr_socket_timeout_set(s, old_timeout);
!         if ((arv != APR_SUCCESS) && (rv == APR_SUCCESS)) {
!             rv = arv;
!         }
!     }
!     if ((ap__logio_add_bytes_out != NULL) && (bytes_written > 0)) {
!         ap__logio_add_bytes_out(c, bytes_written);
!     }
!     *cumulative_bytes_written += bytes_written;
!     if ((bytes_written < file_length) && (bytes_written > 0)) {
!         apr_bucket_split(bucket, bytes_written);
!         APR_BUCKET_REMOVE(bucket);
!         apr_bucket_destroy(bucket);
!     }
!     else if (bytes_written == file_length) {
!         APR_BUCKET_REMOVE(bucket);
!         apr_bucket_destroy(bucket);
!     }
!     return rv;
  }
+ 
+ #endif
Only in /tmp/patch.inc.get2.9J0UCU/server: eor_bucket.c
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/gen_test_char.c /tmp/patch.inc.get2.9J0UCU/server/gen_test_char.c
*** /tmp/patch.inc.get1.AvnxJA/server/gen_test_char.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/gen_test_char.c	2013-04-28 19:22:13.551312047 +0200
***************
*** 29,36 ****
  #include "apr.h"
  #include "apr_lib.h"
  
! #if defined(WIN32) || defined(OS2)
! #define NEED_ENHANCED_ESCAPES
  #endif
  
  #endif
--- 29,36 ----
  #include "apr.h"
  #include "apr_lib.h"
  
! #ifdef WIN32
! #define WANT_WIN32
  #endif
  
  #endif
*************** int main(int argc, char *argv[])
*** 80,86 ****
              printf("\n    ");
  
          /* escape_shell_cmd */
! #ifdef NEED_ENHANCED_ESCAPES
          /* Win32/OS2 have many of the same vulnerable characters
           * as Unix sh, plus the carriage return and percent char.
           * The proper escaping of these characters varies from unix
--- 80,86 ----
              printf("\n    ");
  
          /* escape_shell_cmd */
! #if defined(WANT_WIN32) || defined(OS2)
          /* Win32/OS2 have many of the same vulnerable characters
           * as Unix sh, plus the carriage return and percent char.
           * The proper escaping of these characters varies from unix
Only in /tmp/patch.inc.get1.AvnxJA/server: gen_test_char.dep
Only in /tmp/patch.inc.get1.AvnxJA/server: gen_test_char.mak
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/listen.c /tmp/patch.inc.get2.9J0UCU/server/listen.c
*** /tmp/patch.inc.get1.AvnxJA/server/listen.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/listen.c	2013-04-28 19:22:13.551312047 +0200
***************
*** 20,33 ****
  #define APR_WANT_STRFUNC
  #include "apr_want.h"
  
- #define CORE_PRIVATE
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_config.h"
  #include "http_core.h"
  #include "ap_listen.h"
  #include "http_log.h"
- #include "mpm.h"
  #include "mpm_common.h"
  
  AP_DECLARE_DATA ap_listen_rec *ap_listeners = NULL;
--- 20,31 ----
*************** static apr_status_t make_sock(apr_pool_t
*** 170,180 ****
      server->sd = s;
      server->active = 1;
  
- #ifdef MPM_ACCEPT_FUNC
-     server->accept_func = MPM_ACCEPT_FUNC;
- #else
      server->accept_func = NULL;
- #endif
  
      return APR_SUCCESS;
  }
--- 168,174 ----
*************** static void ap_apply_accept_filter(apr_p
*** 224,237 ****
                            accf);
          }
  #else
! #ifdef APR_TCP_DEFER_ACCEPT
!         rv = apr_socket_opt_set(s, APR_TCP_DEFER_ACCEPT, 1);
          if (rv != APR_SUCCESS && !APR_STATUS_IS_ENOTIMPL(rv)) {
              ap_log_perror(APLOG_MARK, APLOG_WARNING, rv, p,
                                "Failed to enable APR_TCP_DEFER_ACCEPT");
          }
  #endif
- #endif
      }
  }
  
--- 218,229 ----
                            accf);
          }
  #else
!         rv = apr_socket_opt_set(s, APR_TCP_DEFER_ACCEPT, 30);
          if (rv != APR_SUCCESS && !APR_STATUS_IS_ENOTIMPL(rv)) {
              ap_log_perror(APLOG_MARK, APLOG_WARNING, rv, p,
                                "Failed to enable APR_TCP_DEFER_ACCEPT");
          }
  #endif
      }
  }
  
*************** static apr_status_t close_listeners_on_e
*** 242,248 ****
  }
  
  static const char *alloc_listener(process_rec *process, char *addr,
!                                   apr_port_t port, const char* proto)
  {
      ap_listen_rec **walk, *last;
      apr_status_t status;
--- 234,241 ----
  }
  
  static const char *alloc_listener(process_rec *process, char *addr,
!                                   apr_port_t port, const char* proto,
!                                   void *dummy)
  {
      ap_listen_rec **walk, *last;
      apr_status_t status;
*************** static const char *alloc_listener(proces
*** 277,282 ****
--- 270,278 ----
      }
  
      if (found_listener) {
+         if (ap_listeners->slave != dummy) {
+             return "Cannot define a slave on the same IP:port as a Listener";
+         }
          return NULL;
      }
  
*************** static const char *alloc_listener(proces
*** 334,339 ****
--- 330,336 ----
              last->next = new;
              last = new;
          }
+         new->slave = dummy;
      }
  
      return NULL;
*************** AP_DECLARE_NONSTD(void) ap_close_listene
*** 589,594 ****
--- 586,607 ----
          lr->active = 0;
      }
  }
+ AP_DECLARE_NONSTD(int) ap_close_selected_listeners(ap_slave_t *slave)
+ {
+     ap_listen_rec *lr;
+     int n = 0;
+ 
+     for (lr = ap_listeners; lr; lr = lr->next) {
+         if (lr->slave != slave) {
+             apr_socket_close(lr->sd);
+             lr->active = 0;
+         }
+         else {
+             ++n;
+         }
+     }
+     return n;
+ }
  
  AP_DECLARE(void) ap_listen_pre_config(void)
  {
*************** AP_DECLARE(void) ap_listen_pre_config(vo
*** 597,603 ****
      ap_listenbacklog = DEFAULT_LISTENBACKLOG;
  }
  
! 
  AP_DECLARE_NONSTD(const char *) ap_set_listener(cmd_parms *cmd, void *dummy,
                                                  int argc, char *const argv[])
  {
--- 610,619 ----
      ap_listenbacklog = DEFAULT_LISTENBACKLOG;
  }
  
! /* Hack: populate an extra field
!  * When this gets called from a Listen directive, dummy is null.
!  * So we can use non-null dummy to pass a data pointer without conflict
!  */
  AP_DECLARE_NONSTD(const char *) ap_set_listener(cmd_parms *cmd, void *dummy,
                                                  int argc, char *const argv[])
  {
*************** AP_DECLARE_NONSTD(const char *) ap_set_l
*** 644,650 ****
          ap_str_tolower(proto);
      }
  
!     return alloc_listener(cmd->server->process, host, port, proto);
  }
  
  AP_DECLARE_NONSTD(const char *) ap_set_listenbacklog(cmd_parms *cmd,
--- 660,666 ----
          ap_str_tolower(proto);
      }
  
!     return alloc_listener(cmd->server->process, host, port, proto, dummy);
  }
  
  AP_DECLARE_NONSTD(const char *) ap_set_listenbacklog(cmd_parms *cmd,
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/log.c /tmp/patch.inc.get2.9J0UCU/server/log.c
*** /tmp/patch.inc.get1.AvnxJA/server/log.c	2013-04-28 19:22:12.451306580 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/log.c	2013-04-28 19:22:13.567312116 +0200
***************
*** 40,47 ****
  #include <unistd.h>
  #endif
  
- #define CORE_PRIVATE
- 
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_config.h"
--- 40,45 ----
*************** typedef struct read_handle_t {
*** 151,156 ****
--- 149,185 ----
  
  static read_handle_t *read_handles;
  
+ /**
+  * @brief The piped logging structure.  
+  *
+  * Piped logs are used to move functionality out of the main server.  
+  * For example, log rotation is done with piped logs.
+  */
+ struct piped_log {
+     /** The pool to use for the piped log */
+     apr_pool_t *p;
+     /** The pipe between the server and the logging process */
+     apr_file_t *read_fd, *write_fd;
+ #ifdef AP_HAVE_RELIABLE_PIPED_LOGS
+     /** The name of the program the logging process is running */
+     char *program;
+     /** The pid of the logging process */
+     apr_proc_t *pid;
+     /** How to reinvoke program when it must be replaced */
+     apr_cmdtype_e cmdtype;
+ #endif
+ };
+ 
+ AP_DECLARE(apr_file_t *) ap_piped_log_read_fd(piped_log *pl)
+ {
+     return pl->read_fd;
+ }
+ 
+ AP_DECLARE(apr_file_t *) ap_piped_log_write_fd(piped_log *pl)
+ {
+     return pl->write_fd;
+ }
+ 
  /* clear_handle_list() is called when plog is cleared; at that
   * point we need to forget about our old list of pipe read
   * handles.  We let the plog cleanups close the actual pipes.
*************** static int log_child(apr_pool_t *p, cons
*** 275,283 ****
      apr_status_t rc;
      apr_procattr_t *procattr;
      apr_proc_t *procnew;
!     apr_file_t *outfile, *errfile;
  
      if (((rc = apr_procattr_create(&procattr, p)) == APR_SUCCESS)
          && ((rc = apr_procattr_cmdtype_set(procattr, cmdtype)) == APR_SUCCESS)
          && ((rc = apr_procattr_io_set(procattr,
                                        APR_FULL_BLOCK,
--- 304,314 ----
      apr_status_t rc;
      apr_procattr_t *procattr;
      apr_proc_t *procnew;
!     apr_file_t *errfile;
  
      if (((rc = apr_procattr_create(&procattr, p)) == APR_SUCCESS)
+         && ((rc = apr_procattr_dir_set(procattr,
+                                        ap_server_root)) == APR_SUCCESS)
          && ((rc = apr_procattr_cmdtype_set(procattr, cmdtype)) == APR_SUCCESS)
          && ((rc = apr_procattr_io_set(procattr,
                                        APR_FULL_BLOCK,
*************** static int log_child(apr_pool_t *p, cons
*** 293,303 ****
          pname = apr_pstrdup(p, args[0]);
          procnew = (apr_proc_t *)apr_pcalloc(p, sizeof(*procnew));
  
!         if ((rc = apr_file_open_stdout(&outfile, p)) == APR_SUCCESS) {
!             rc = apr_procattr_child_out_set(procattr, outfile, NULL);
!             if (dummy_stderr)
!                 rc = apr_procattr_child_err_set(procattr, outfile, NULL);
!             else if ((rc = apr_file_open_stderr(&errfile, p)) == APR_SUCCESS)
                  rc = apr_procattr_child_err_set(procattr, errfile, NULL);
          }
  
--- 324,331 ----
          pname = apr_pstrdup(p, args[0]);
          procnew = (apr_proc_t *)apr_pcalloc(p, sizeof(*procnew));
  
!         if (dummy_stderr) {
!             if ((rc = apr_file_open_stdout(&errfile, p)) == APR_SUCCESS)
                  rc = apr_procattr_child_err_set(procattr, errfile, NULL);
          }
  
*************** static int open_error_log(server_rec *s,
*** 325,331 ****
  
      if (*s->error_fname == '|') {
          apr_file_t *dummy = NULL;
!         apr_cmdtype_e cmdtype = APR_SHELLCMD_ENV;
          fname = s->error_fname + 1;
  
          /* In 2.4 favor PROGRAM_ENV, accept "||prog" syntax for compatibility
--- 353,359 ----
  
      if (*s->error_fname == '|') {
          apr_file_t *dummy = NULL;
!         apr_cmdtype_e cmdtype = APR_PROGRAM_ENV;
          fname = s->error_fname + 1;
  
          /* In 2.4 favor PROGRAM_ENV, accept "||prog" syntax for compatibility
*************** static int open_error_log(server_rec *s,
*** 333,344 ****
           * Any 2.2 backport would continue to favor SHELLCMD_ENV so there 
           * accept "||prog" to override, and "|$cmd" to ease conversion.
           */
!         if (*fname == '|') {
!             cmdtype = APR_PROGRAM_ENV;
              ++fname;
!         }
!         if (*fname == '$')
              ++fname;
  	
          /* Spawn a new child logger.  If this is the main server_rec,
           * the new child must use a dummy stderr since the current
--- 361,372 ----
           * Any 2.2 backport would continue to favor SHELLCMD_ENV so there 
           * accept "||prog" to override, and "|$cmd" to ease conversion.
           */
!         if (*fname == '|')
              ++fname;
!         if (*fname == '$') {
!             cmdtype = APR_SHELLCMD_ENV;
              ++fname;
+         }
  	
          /* Spawn a new child logger.  If this is the main server_rec,
           * the new child must use a dummy stderr since the current
*************** static int open_error_log(server_rec *s,
*** 347,353 ****
          rc = log_child(p, fname, &dummy, cmdtype, is_main);
          if (rc != APR_SUCCESS) {
              ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL,
!                          "Couldn't start ErrorLog process");
              return DONE;
          }
  
--- 375,382 ----
          rc = log_child(p, fname, &dummy, cmdtype, is_main);
          if (rc != APR_SUCCESS) {
              ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL,
!                          "Couldn't start ErrorLog process '%s'.",
!                          s->error_fname + 1);
              return DONE;
          }
  
*************** int ap_open_logs(apr_pool_t *pconf, apr_
*** 425,431 ****
       */
      apr_pool_create(&stderr_p, apr_pool_parent_get(p));
      apr_pool_tag(stderr_p, "stderr_pool");
!     
      if (open_error_log(s_main, 1, stderr_p) != OK) {
          return DONE;
      }
--- 454,460 ----
       */
      apr_pool_create(&stderr_p, apr_pool_parent_get(p));
      apr_pool_tag(stderr_p, "stderr_pool");
! 
      if (open_error_log(s_main, 1, stderr_p) != OK) {
          return DONE;
      }
*************** int ap_open_logs(apr_pool_t *pconf, apr_
*** 433,439 ****
      replace_stderr = 1;
      if (s_main->error_log) {
          apr_status_t rv;
!         
          /* Replace existing stderr with new log. */
          apr_file_flush(s_main->error_log);
          rv = apr_file_dup2(stderr_log, s_main->error_log, stderr_p);
--- 462,468 ----
      replace_stderr = 1;
      if (s_main->error_log) {
          apr_status_t rv;
! 
          /* Replace existing stderr with new log. */
          apr_file_flush(s_main->error_log);
          rv = apr_file_dup2(stderr_log, s_main->error_log, stderr_p);
*************** int ap_open_logs(apr_pool_t *pconf, apr_
*** 465,470 ****
--- 494,500 ----
       * because it points to the old error log, or back to the tty
       * of the submitter.
       * XXX: This is BS - /dev/null is non-portable
+      *      errno-as-apr_status_t is also non-portable
       */
      if (replace_stderr && freopen("/dev/null", "w", stderr) == NULL) {
          ap_log_error(APLOG_MARK, APLOG_CRIT, errno, s_main,
*************** static void log_error_core(const char *f
*** 530,539 ****
--- 560,571 ----
           * above the default server log level unless it is a startup/shutdown
           * notice
           */
+ #ifndef DEBUG
          if ((level_and_mask != APLOG_NOTICE)
              && (level_and_mask > ap_default_loglevel)) {
              return;
          }
+ #endif
  
          logf = stderr_log;
      }
*************** static void log_error_core(const char *f
*** 549,568 ****
  
          logf = s->error_log;
      }
- #ifdef TPF
-     else if (tpf_child) {
-         /*
-          * If we are doing normal logging, don't log messages that are
-          * above the server log level unless it is a startup/shutdown notice
-          */
-         if ((level_and_mask != APLOG_NOTICE)
-             && (level_and_mask > s->loglevel)) {
-             return;
-         }
- 
-         logf = stderr;
-     }
- #endif /* TPF */
      else {
          /*
           * If we are doing syslog logging, don't log messages that are
--- 581,586 ----
*************** static void log_error_core(const char *f
*** 588,594 ****
                              "[%s] ", priorities[level_and_mask].t_name);
      }
  
- #ifndef TPF
      if (file && level_and_mask == APLOG_DEBUG) {
  #if defined(_OSD_POSIX) || defined(WIN32) || defined(__MVS__)
          char tmp[256];
--- 606,611 ----
*************** static void log_error_core(const char *f
*** 624,630 ****
          len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,
                              "%s(%d): ", file, line);
      }
- #endif /* TPF */
  
      if (c) {
          /* XXX: TODO: add a method of selecting whether logged client
--- 641,646 ----
*************** static apr_status_t piped_log_spawn(pipe
*** 897,907 ****
      apr_status_t status;
  
      if (((status = apr_procattr_create(&procattr, pl->p)) != APR_SUCCESS) ||
          ((status = apr_procattr_cmdtype_set(procattr, pl->cmdtype))
           != APR_SUCCESS) ||
          ((status = apr_procattr_child_in_set(procattr,
!                                              ap_piped_log_read_fd(pl),
!                                              ap_piped_log_write_fd(pl)))
           != APR_SUCCESS) ||
          ((status = apr_procattr_child_errfn_set(procattr, log_child_errfn))
           != APR_SUCCESS) ||
--- 913,925 ----
      apr_status_t status;
  
      if (((status = apr_procattr_create(&procattr, pl->p)) != APR_SUCCESS) ||
+         ((status = apr_procattr_dir_set(procattr, ap_server_root))
+          != APR_SUCCESS) ||
          ((status = apr_procattr_cmdtype_set(procattr, pl->cmdtype))
           != APR_SUCCESS) ||
          ((status = apr_procattr_child_in_set(procattr,
!                                              pl->read_fd,
!                                              pl->write_fd))
           != APR_SUCCESS) ||
          ((status = apr_procattr_child_errfn_set(procattr, log_child_errfn))
           != APR_SUCCESS) ||
*************** static apr_status_t piped_log_spawn(pipe
*** 915,926 ****
      else {
          char **args;
          const char *pname;
-         apr_file_t *outfile, *errfile;
- 
-         if ((status = apr_file_open_stdout(&outfile, pl->p)) == APR_SUCCESS)
-             status = apr_procattr_child_out_set(procattr, outfile, NULL);
-         if ((status = apr_file_open_stderr(&errfile, pl->p)) == APR_SUCCESS)
-             status = apr_procattr_child_err_set(procattr, errfile, NULL);
  
          apr_tokenize_to_argv(pl->program, &args, pl->p);
          pname = apr_pstrdup(pl->p, args[0]);
--- 933,938 ----
*************** static apr_status_t piped_log_spawn(pipe
*** 930,943 ****
  
          if (status == APR_SUCCESS) {
              pl->pid = procnew;
!             /* procnew->in was dup2'd from ap_piped_log_write_fd(pl);
               * since the original fd is still valid, close the copy to
               * avoid a leak. */
              apr_file_close(procnew->in);
              procnew->in = NULL;
              apr_proc_other_child_register(procnew, piped_log_maintenance, pl,
!                                           ap_piped_log_write_fd(pl), pl->p);
!             close_handle_in_child(pl->p, ap_piped_log_read_fd(pl));
          }
          else {
              char buf[120];
--- 942,955 ----
  
          if (status == APR_SUCCESS) {
              pl->pid = procnew;
!             /* procnew->in was dup2'd from pl->write_fd;
               * since the original fd is still valid, close the copy to
               * avoid a leak. */
              apr_file_close(procnew->in);
              procnew->in = NULL;
              apr_proc_other_child_register(procnew, piped_log_maintenance, pl,
!                                           pl->write_fd, pl->p);
!             close_handle_in_child(pl->p, pl->read_fd);
          }
          else {
              char buf[120];
*************** static apr_status_t piped_log_cleanup_fo
*** 1009,1016 ****
  {
      piped_log *pl = data;
  
!     apr_file_close(ap_piped_log_read_fd(pl));
!     apr_file_close(ap_piped_log_write_fd(pl));
      return APR_SUCCESS;
  }
  
--- 1021,1028 ----
  {
      piped_log *pl = data;
  
!     apr_file_close(pl->read_fd);
!     apr_file_close(pl->write_fd);
      return APR_SUCCESS;
  }
  
*************** AP_DECLARE(piped_log *) ap_open_piped_lo
*** 1037,1052 ****
      pl->program = apr_pstrdup(p, program);
      pl->pid = NULL;
      pl->cmdtype = cmdtype;
!     if (apr_file_pipe_create(&ap_piped_log_read_fd(pl),
!                              &ap_piped_log_write_fd(pl), p) != APR_SUCCESS) {
          return NULL;
      }
      apr_pool_cleanup_register(p, pl, piped_log_cleanup,
                                piped_log_cleanup_for_exec);
      if (piped_log_spawn(pl) != APR_SUCCESS) {
          apr_pool_cleanup_kill(p, pl, piped_log_cleanup);
!         apr_file_close(ap_piped_log_read_fd(pl));
!         apr_file_close(ap_piped_log_write_fd(pl));
          return NULL;
      }
      return pl;
--- 1049,1065 ----
      pl->program = apr_pstrdup(p, program);
      pl->pid = NULL;
      pl->cmdtype = cmdtype;
!     if (apr_file_pipe_create_ex(&pl->read_fd,
!                                 &pl->write_fd,
!                                 APR_FULL_BLOCK, p) != APR_SUCCESS) {
          return NULL;
      }
      apr_pool_cleanup_register(p, pl, piped_log_cleanup,
                                piped_log_cleanup_for_exec);
      if (piped_log_spawn(pl) != APR_SUCCESS) {
          apr_pool_cleanup_kill(p, pl, piped_log_cleanup);
!         apr_file_close(pl->read_fd);
!         apr_file_close(pl->write_fd);
          return NULL;
      }
      return pl;
*************** static apr_status_t piped_log_cleanup(vo
*** 1058,1064 ****
  {
      piped_log *pl = data;
  
!     apr_file_close(ap_piped_log_write_fd(pl));
      return APR_SUCCESS;
  }
  
--- 1071,1077 ----
  {
      piped_log *pl = data;
  
!     apr_file_close(pl->write_fd);
      return APR_SUCCESS;
  }
  
*************** AP_DECLARE(piped_log *) ap_open_piped_lo
*** 1073,1086 ****
      rc = log_child(p, program, &dummy, cmdtype, 0);
      if (rc != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL,
!                      "Couldn't start piped log process");
          return NULL;
      }
  
      pl = apr_palloc(p, sizeof (*pl));
      pl->p = p;
!     ap_piped_log_read_fd(pl) = NULL;
!     ap_piped_log_write_fd(pl) = dummy;
      apr_pool_cleanup_register(p, pl, piped_log_cleanup, piped_log_cleanup);
  
      return pl;
--- 1086,1100 ----
      rc = log_child(p, program, &dummy, cmdtype, 0);
      if (rc != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL,
!                      "Couldn't start piped log process '%s'.",
!                      (program == NULL) ? "NULL" : program);
          return NULL;
      }
  
      pl = apr_palloc(p, sizeof (*pl));
      pl->p = p;
!     pl->read_fd = NULL;
!     pl->write_fd = dummy;
      apr_pool_cleanup_register(p, pl, piped_log_cleanup, piped_log_cleanup);
  
      return pl;
*************** AP_DECLARE(piped_log *) ap_open_piped_lo
*** 1091,1109 ****
  AP_DECLARE(piped_log *) ap_open_piped_log(apr_pool_t *p,
                                            const char *program)
  {
!     apr_cmdtype_e cmdtype = APR_SHELLCMD_ENV;
  
      /* In 2.4 favor PROGRAM_ENV, accept "||prog" syntax for compatibility
       * and "|$cmd" to override the default.
       * Any 2.2 backport would continue to favor SHELLCMD_ENV so there 
       * accept "||prog" to override, and "|$cmd" to ease conversion.
       */
!     if (*program == '|') {
!         cmdtype = APR_PROGRAM_ENV;
          ++program;
!     }
!     if (*program == '$')
          ++program;
  
      return ap_open_piped_log_ex(p, program, cmdtype);
  }
--- 1105,1123 ----
  AP_DECLARE(piped_log *) ap_open_piped_log(apr_pool_t *p,
                                            const char *program)
  {
!     apr_cmdtype_e cmdtype = APR_PROGRAM_ENV;
  
      /* In 2.4 favor PROGRAM_ENV, accept "||prog" syntax for compatibility
       * and "|$cmd" to override the default.
       * Any 2.2 backport would continue to favor SHELLCMD_ENV so there 
       * accept "||prog" to override, and "|$cmd" to ease conversion.
       */
!     if (*program == '|')
          ++program;
!     if (*program == '$') {
!         cmdtype = APR_SHELLCMD_ENV;
          ++program;
+     }
  
      return ap_open_piped_log_ex(p, program, cmdtype);
  }
*************** AP_IMPLEMENT_HOOK_VOID(error_log,
*** 1119,1122 ****
                          const request_rec *r, apr_pool_t *pool,
                          const char *errstr), (file, line, level,
                          status, s, r, pool, errstr))
- 
--- 1133,1135 ----
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/main.c /tmp/patch.inc.get2.9J0UCU/server/main.c
*** /tmp/patch.inc.get1.AvnxJA/server/main.c	2013-04-28 19:22:12.451306580 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/main.c	2013-04-28 19:22:13.567312116 +0200
***************
*** 28,45 ****
  #define APR_WANT_STRFUNC
  #include "apr_want.h"
  
- #define CORE_PRIVATE
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_main.h"
  #include "http_log.h"
  #include "http_config.h"
  #include "http_core.h"
  #include "http_vhost.h"
  #include "apr_uri.h"
  #include "util_ebcdic.h"
  #include "ap_mpm.h"
! #include "mpm_common.h"
  
  /* WARNING: Win32 binds http_main.c dynamically to the server. Please place
   *          extern functions and global data in another appropriate module.
--- 28,49 ----
  #define APR_WANT_STRFUNC
  #include "apr_want.h"
  
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_main.h"
  #include "http_log.h"
  #include "http_config.h"
  #include "http_core.h"
+ #include "http_request.h"
  #include "http_vhost.h"
  #include "apr_uri.h"
  #include "util_ebcdic.h"
  #include "ap_mpm.h"
! #include "ap_expr.h"
! 
! #if APR_HAVE_UNISTD_H
! #include <unistd.h>
! #endif
  
  /* WARNING: Win32 binds http_main.c dynamically to the server. Please place
   *          extern functions and global data in another appropriate module.
*************** static void show_compile_settings(void)
*** 93,101 ****
      printf("Server built:   %s\n", ap_get_server_built());
      printf("Server's Module Magic Number: %u:%u\n",
             MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
!     printf("Server loaded:  APR %s, APR-Util %s\n",
             apr_version_string(), apu_version_string());
!     printf("Compiled using: APR %s, APR-Util %s\n",
             APR_VERSION_STRING, APU_VERSION_STRING);
      /* sizeof(foo) is long on some platforms so we might as well
       * make it long everywhere to keep the printf format
--- 97,105 ----
      printf("Server built:   %s\n", ap_get_server_built());
      printf("Server's Module Magic Number: %u:%u\n",
             MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
!     printf("Server loaded:  APR %s, APR-UTIL %s\n",
             apr_version_string(), apu_version_string());
!     printf("Compiled using: APR %s, APR-UTIL %s\n",
             APR_VERSION_STRING, APU_VERSION_STRING);
      /* sizeof(foo) is long on some platforms so we might as well
       * make it long everywhere to keep the printf format
*************** static void show_compile_settings(void)
*** 118,127 ****
      printf(" -D OS=\"" OS "\"\n");
  #endif
  
- #ifdef APACHE_MPM_DIR
-     printf(" -D APACHE_MPM_DIR=\"" APACHE_MPM_DIR "\"\n");
- #endif
- 
  #ifdef HAVE_SHMGET
      printf(" -D HAVE_SHMGET\n");
  #endif
--- 122,127 ----
*************** static void show_compile_settings(void)
*** 237,246 ****
      printf(" -D DEFAULT_SCOREBOARD=\"" DEFAULT_SCOREBOARD "\"\n");
  #endif
  
- #ifdef DEFAULT_LOCKFILE
-     printf(" -D DEFAULT_LOCKFILE=\"" DEFAULT_LOCKFILE "\"\n");
- #endif
- 
  #ifdef DEFAULT_ERRORLOG
      printf(" -D DEFAULT_ERRORLOG=\"" DEFAULT_ERRORLOG "\"\n");
  #endif
--- 237,242 ----
*************** static void destroy_and_exit_process(pro
*** 272,277 ****
--- 268,284 ----
      exit(process_exit_value);
  }
  
+ #define OOM_MESSAGE "[crit] Memory allocation failed, " \
+     "aborting process." APR_EOL_STR
+ 
+ /* APR callback invoked if allocation fails. */
+ static int abort_on_oom(int retcode)
+ {
+     write(STDERR_FILENO, OOM_MESSAGE, strlen(OOM_MESSAGE));
+     abort();
+     return retcode; /* unreachable, hopefully. */
+ }
+ 
  static process_rec *init_process(int *argc, const char * const * *argv)
  {
      process_rec *process;
*************** static process_rec *init_process(int *ar
*** 289,294 ****
--- 296,306 ----
          /* For all intents and purposes, this is impossibly unlikely,
           * but APR doesn't exist yet, we can't use it for reporting
           * these earliest two failures;
+          *
+          * XXX: Note the apr_ctime() and apr_time_now() calls.  These
+          * work, today, against an uninitialized APR, but in the future
+          * (if they relied on global pools or mutexes, for example) then
+          * the datestamp logic will need to be replaced.
           */
          char ctimebuff[APR_CTIME_LEN];
          apr_ctime(ctimebuff, apr_time_now());
*************** static process_rec *init_process(int *ar
*** 299,304 ****
--- 311,317 ----
          exit(1);
      }
  
+     apr_pool_abort_set(abort_on_oom, cntx);
      apr_pool_tag(cntx, "process");
      ap_open_stderr_log(cntx);
  
*************** static process_rec *init_process(int *ar
*** 321,327 ****
  static void usage(process_rec *process)
  {
      const char *bin = process->argv[0];
!     int pad_len = strlen(bin);
  
  #ifdef SHARED_CORE
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL ,
--- 334,347 ----
  static void usage(process_rec *process)
  {
      const char *bin = process->argv[0];
!     char pad[MAX_STRING_LEN];
!     unsigned i;
! 
!     for (i = 0; i < strlen(bin); i++) {
!         pad[i] = ' ';
!     }
! 
!     pad[i] = '\0';
  
  #ifdef SHARED_CORE
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL ,
*************** static void usage(process_rec *process)
*** 333,360 ****
  #endif
  
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %*s [-C \"directive\"] [-c \"directive\"]", pad_len, " ");
  
  #ifdef WIN32
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %*s [-w] [-k start|restart|stop|shutdown]", pad_len, " ");
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %*s [-k install|config|uninstall] [-n service_name]",
!                  pad_len, " ");
! #endif
! #ifdef AP_MPM_WANT_SIGNAL_SERVER
! #ifdef AP_MPM_WANT_SET_GRACEFUL_SHUTDOWN
!     ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %*s [-k start|restart|graceful|graceful-stop|stop]",
!                  pad_len, " ");
  #else
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %*s [-k start|restart|graceful|stop]", pad_len, " ");
! #endif /* AP_MPM_WANT_SET_GRACEFUL_SHUTDOWN */
  #endif
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %*s [-v] [-V] [-h] [-l] [-L] [-t] [-T] [-S]",
!                  pad_len, " ");
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                   "Options:");
  
--- 353,376 ----
  #endif
  
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %s [-C \"directive\"] [-c \"directive\"]", pad);
  
  #ifdef WIN32
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %s [-w] [-k start|restart|stop|shutdown] [-n service_name]", pad);
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %s [-k install|config|uninstall] [-n service_name]",
!                  pad);
  #else
+ /* XXX not all MPMs support signalling the server in general or graceful-stop
+  * in particular
+  */
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %s [-k start|restart|graceful|graceful-stop|stop]",
!                  pad);
  #endif
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                  "       %s [-v] [-V] [-h] [-l] [-L] [-t] [-S]", pad);
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                   "Options:");
  
*************** static void usage(process_rec *process)
*** 386,392 ****
  #ifdef WIN32
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                   "  -n name            : set service name and use its "
!                  "ServerConfigFile");
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                   "  -k start           : tell Apache to start");
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
--- 402,408 ----
  #ifdef WIN32
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                   "  -n name            : set service name and use its "
!                  "ServerConfigFile and ServerRoot");
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                   "  -k start           : tell Apache to start");
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
*************** static void usage(process_rec *process)
*** 433,440 ****
                   "  -M                 : a synonym for -t -D DUMP_MODULES");
      ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                   "  -t                 : run syntax check for config files");
-     ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                 "  -T                 : start without DocumentRoot(s) check");
  
      destroy_and_exit_process(process, 1);
  }
--- 449,454 ----
*************** static void usage(process_rec *process)
*** 442,455 ****
  int main(int argc, const char * const argv[])
  {
      char c;
!     int configtestonly = 0;
      const char *confname = SERVER_CONFIG_FILE;
      const char *def_server_root = HTTPD_ROOT;
      const char *temp_error_log = NULL;
      const char *error;
      process_rec *process;
-     server_rec *server_conf;
-     apr_pool_t *pglobal;
      apr_pool_t *pconf;
      apr_pool_t *plog; /* Pool of log streams, reset _after_ each read of conf */
      apr_pool_t *ptemp; /* Pool for temporary config stuff, reset often */
--- 456,467 ----
  int main(int argc, const char * const argv[])
  {
      char c;
!     int configtestonly = 0, showcompile = 0;
      const char *confname = SERVER_CONFIG_FILE;
      const char *def_server_root = HTTPD_ROOT;
      const char *temp_error_log = NULL;
      const char *error;
      process_rec *process;
      apr_pool_t *pconf;
      apr_pool_t *plog; /* Pool of log streams, reset _after_ each read of conf */
      apr_pool_t *ptemp; /* Pool for temporary config stuff, reset often */
*************** int main(int argc, const char * const ar
*** 463,479 ****
      AP_MONCONTROL(0); /* turn off profiling of startup */
  
      process = init_process(&argc, &argv);
!     pglobal = process->pool;
      pconf = process->pconf;
      ap_server_argv0 = process->short_name;
  
  #if APR_CHARSET_EBCDIC
!     if (ap_init_ebcdic(pglobal) != APR_SUCCESS) {
          destroy_and_exit_process(process, 1);
      }
  #endif
  
!     apr_pool_create(&pcommands, pglobal);
      apr_pool_tag(pcommands, "pcommands");
      ap_server_pre_read_config  = apr_array_make(pcommands, 1, sizeof(char *));
      ap_server_post_read_config = apr_array_make(pcommands, 1, sizeof(char *));
--- 475,498 ----
      AP_MONCONTROL(0); /* turn off profiling of startup */
  
      process = init_process(&argc, &argv);
!     ap_pglobal = process->pool;
      pconf = process->pconf;
      ap_server_argv0 = process->short_name;
  
+     /* Set up the OOM callback in the global pool, so all pools should
+      * by default inherit it. */
+     apr_pool_abort_set(abort_on_oom, apr_pool_parent_get(process->pool));
+ 
  #if APR_CHARSET_EBCDIC
!     if (ap_init_ebcdic(ap_pglobal) != APR_SUCCESS) {
          destroy_and_exit_process(process, 1);
      }
  #endif
+     if (ap_expr_init(ap_pglobal) != APR_SUCCESS) {
+         destroy_and_exit_process(process, 1);
+     }
  
!     apr_pool_create(&pcommands, ap_pglobal);
      apr_pool_tag(pcommands, "pcommands");
      ap_server_pre_read_config  = apr_array_make(pcommands, 1, sizeof(char *));
      ap_server_post_read_config = apr_array_make(pcommands, 1, sizeof(char *));
*************** int main(int argc, const char * const ar
*** 572,579 ****
              destroy_and_exit_process(process, 0);
  
          case 'V':
!             show_compile_settings();
!             destroy_and_exit_process(process, 0);
  
          case 'l':
              ap_show_modules();
--- 591,604 ----
              destroy_and_exit_process(process, 0);
  
          case 'V':
!             if (strcmp(ap_show_mpm(), "")) { /* MPM built-in? */
!                 show_compile_settings();
!                 destroy_and_exit_process(process, 0);
!             }
!             else {
!                 showcompile = 1;
!             }
!             break;
  
          case 'l':
              ap_show_modules();
*************** int main(int argc, const char * const ar
*** 587,596 ****
              configtestonly = 1;
              break;
  
-        case 'T':
-            ap_document_root_check = 0;
-            break;
- 
          case 'S':
              configtestonly = 1;
              new = (char **)apr_array_push(ap_server_config_defines);
--- 612,617 ----
*************** int main(int argc, const char * const ar
*** 614,620 ****
          usage(process);
      }
  
!     apr_pool_create(&plog, pglobal);
      apr_pool_tag(plog, "plog");
      apr_pool_create(&ptemp, pconf);
      apr_pool_tag(ptemp, "ptemp");
--- 635,641 ----
          usage(process);
      }
  
!     apr_pool_create(&plog, ap_pglobal);
      apr_pool_tag(plog, "plog");
      apr_pool_create(&ptemp, pconf);
      apr_pool_tag(ptemp, "ptemp");
*************** int main(int argc, const char * const ar
*** 629,640 ****
      if (temp_error_log) {
          ap_replace_stderr_log(process->pool, temp_error_log);
      }
!     server_conf = ap_read_config(process, ptemp, confname, &ap_conftree);
!     if (!server_conf) {
          destroy_and_exit_process(process, 1);
      }
-     /* sort hooks here to make sure pre_config hooks are sorted properly */
-     apr_hook_sort_all();
  
      if (ap_run_pre_config(pconf, plog, ptemp) != OK) {
          ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR, 0,
--- 650,659 ----
      if (temp_error_log) {
          ap_replace_stderr_log(process->pool, temp_error_log);
      }
!     ap_server_conf = ap_read_config(process, ptemp, confname, &ap_conftree);
!     if (!ap_server_conf) {
          destroy_and_exit_process(process, 1);
      }
  
      if (ap_run_pre_config(pconf, plog, ptemp) != OK) {
          ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR, 0,
*************** int main(int argc, const char * const ar
*** 642,669 ****
          destroy_and_exit_process(process, 1);
      }
  
!     rv = ap_process_config_tree(server_conf, ap_conftree,
                                  process->pconf, ptemp);
      if (rv == OK) {
!         ap_fixup_virtual_hosts(pconf, server_conf);
!         ap_fini_vhost_config(pconf, server_conf);
!         /*
!          * Sort hooks again because ap_process_config_tree may have added
!          * modules and hence hooks. This happens with mod_perl and modules
!          * written in perl.
!          */
          apr_hook_sort_all();
  
          if (configtestonly) {
!             ap_run_test_config(pconf, server_conf);
              ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, "Syntax OK");
              destroy_and_exit_process(process, 0);
          }
!     }
! 
!     /* If our config failed, deal with that here. */
!     if (rv != OK) {
!         destroy_and_exit_process(process, 1);
      }
  
      signal_server = APR_RETRIEVE_OPTIONAL_FN(ap_signal_server);
--- 661,688 ----
          destroy_and_exit_process(process, 1);
      }
  
!     rv = ap_process_config_tree(ap_server_conf, ap_conftree,
                                  process->pconf, ptemp);
      if (rv == OK) {
!         ap_fixup_virtual_hosts(pconf, ap_server_conf);
!         ap_fini_vhost_config(pconf, ap_server_conf);
          apr_hook_sort_all();
  
+         if (ap_run_check_config(pconf, plog, ptemp, ap_server_conf) != OK) {
+             ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR, 0,
+                          NULL, "Configuration check failed");
+             destroy_and_exit_process(process, 1);
+         }
+ 
          if (configtestonly) {
!             ap_run_test_config(pconf, ap_server_conf);
              ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, "Syntax OK");
              destroy_and_exit_process(process, 0);
          }
!         else if (showcompile) { /* deferred due to dynamically loaded MPM */
!             show_compile_settings();
!             destroy_and_exit_process(process, 0);
!         }
      }
  
      signal_server = APR_RETRIEVE_OPTIONAL_FN(ap_signal_server);
*************** int main(int argc, const char * const ar
*** 675,689 ****
          }
      }
  
      apr_pool_clear(plog);
  
!     if ( ap_run_open_logs(pconf, plog, ptemp, server_conf) != OK) {
          ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
                       0, NULL, "Unable to open logs");
          destroy_and_exit_process(process, 1);
      }
  
!     if ( ap_run_post_config(pconf, plog, ptemp, server_conf) != OK) {
          ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR, 0,
                       NULL, "Configuration Failed");
          destroy_and_exit_process(process, 1);
--- 694,713 ----
          }
      }
  
+     /* If our config failed, deal with that here. */
+     if (rv != OK) {
+         destroy_and_exit_process(process, 1);
+     }
+ 
      apr_pool_clear(plog);
  
!     if ( ap_run_open_logs(pconf, plog, ptemp, ap_server_conf) != OK) {
          ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
                       0, NULL, "Unable to open logs");
          destroy_and_exit_process(process, 1);
      }
  
!     if ( ap_run_post_config(pconf, plog, ptemp, ap_server_conf) != OK) {
          ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR, 0,
                       NULL, "Configuration Failed");
          destroy_and_exit_process(process, 1);
*************** int main(int argc, const char * const ar
*** 694,699 ****
--- 718,724 ----
      for (;;) {
          apr_hook_deregister_all();
          apr_pool_clear(pconf);
+         ap_clear_auth_internal();
  
          for (mod = ap_prelinked_modules; *mod != NULL; mod++) {
              ap_register_hooks(*mod, pconf);
*************** int main(int argc, const char * const ar
*** 707,718 ****
          apr_pool_create(&ptemp, pconf);
          apr_pool_tag(ptemp, "ptemp");
          ap_server_root = def_server_root;
!         server_conf = ap_read_config(process, ptemp, confname, &ap_conftree);
!         if (!server_conf) {
              destroy_and_exit_process(process, 1);
          }
-         /* sort hooks here to make sure pre_config hooks are sorted properly */
-         apr_hook_sort_all();
  
          if (ap_run_pre_config(pconf, plog, ptemp) != OK) {
              ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
--- 732,741 ----
          apr_pool_create(&ptemp, pconf);
          apr_pool_tag(ptemp, "ptemp");
          ap_server_root = def_server_root;
!         ap_server_conf = ap_read_config(process, ptemp, confname, &ap_conftree);
!         if (!ap_server_conf) {
              destroy_and_exit_process(process, 1);
          }
  
          if (ap_run_pre_config(pconf, plog, ptemp) != OK) {
              ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
*************** int main(int argc, const char * const ar
*** 720,745 ****
              destroy_and_exit_process(process, 1);
          }
  
!         if (ap_process_config_tree(server_conf, ap_conftree, process->pconf,
                                     ptemp) != OK) {
              destroy_and_exit_process(process, 1);
          }
!         ap_fixup_virtual_hosts(pconf, server_conf);
!         ap_fini_vhost_config(pconf, server_conf);
!         /*
!          * Sort hooks again because ap_process_config_tree may have added
!          * modules and hence hooks. This happens with mod_perl and modules
!          * written in perl.
!          */
          apr_hook_sort_all();
          apr_pool_clear(plog);
!         if (ap_run_open_logs(pconf, plog, ptemp, server_conf) != OK) {
              ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
                           0, NULL, "Unable to open logs");
              destroy_and_exit_process(process, 1);
          }
  
!         if (ap_run_post_config(pconf, plog, ptemp, server_conf) != OK) {
              ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
                           0, NULL, "Configuration Failed");
              destroy_and_exit_process(process, 1);
--- 743,770 ----
              destroy_and_exit_process(process, 1);
          }
  
!         if (ap_process_config_tree(ap_server_conf, ap_conftree, process->pconf,
                                     ptemp) != OK) {
              destroy_and_exit_process(process, 1);
          }
!         ap_fixup_virtual_hosts(pconf, ap_server_conf);
!         ap_fini_vhost_config(pconf, ap_server_conf);
          apr_hook_sort_all();
+ 
+         if (ap_run_check_config(pconf, plog, ptemp, ap_server_conf) != OK) {
+             ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR, 0,
+                          NULL, "Configuration check failed");
+             destroy_and_exit_process(process, 1);
+         }
+ 
          apr_pool_clear(plog);
!         if (ap_run_open_logs(pconf, plog, ptemp, ap_server_conf) != OK) {
              ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
                           0, NULL, "Unable to open logs");
              destroy_and_exit_process(process, 1);
          }
  
!         if (ap_run_post_config(pconf, plog, ptemp, ap_server_conf) != OK) {
              ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
                           0, NULL, "Configuration Failed");
              destroy_and_exit_process(process, 1);
*************** int main(int argc, const char * const ar
*** 750,756 ****
  
          ap_run_optional_fn_retrieve();
  
!         if (ap_mpm_run(pconf, plog, server_conf))
              break;
  
          apr_pool_lock(pconf, 0);
--- 775,781 ----
  
          ap_run_optional_fn_retrieve();
  
!         if (ap_run_mpm(pconf, plog, ap_server_conf) != OK)
              break;
  
          apr_pool_lock(pconf, 0);
*************** int main(int argc, const char * const ar
*** 768,775 ****
   * has all of the APR functions specified by the apr/apr.exports and
   * apr-util/aprutil.exports files.
   */
! const void *suck_in_APR(void);
! const void *suck_in_APR(void)
  {
      extern const void *ap_ugly_hack;
  
--- 793,800 ----
   * has all of the APR functions specified by the apr/apr.exports and
   * apr-util/aprutil.exports files.
   */
! const void *ap_suck_in_APR(void);
! const void *ap_suck_in_APR(void)
  {
      extern const void *ap_ugly_hack;
  
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/mpm/prefork/mpm_default.h /tmp/patch.inc.get2.9J0UCU/server/mpm/prefork/mpm_default.h
*** /tmp/patch.inc.get1.AvnxJA/server/mpm/prefork/mpm_default.h	2013-04-28 19:22:12.443306550 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/mpm/prefork/mpm_default.h	2013-04-28 19:22:13.559312070 +0200
***************
*** 46,56 ****
  #define DEFAULT_MIN_FREE_DAEMON 5
  #endif
  
- /* File used for accept locking, when we use a file */
- #ifndef DEFAULT_LOCKFILE
- #define DEFAULT_LOCKFILE DEFAULT_REL_RUNTIMEDIR "/accept.lock"
- #endif
- 
  /* Where the main/parent process's pid is logged */
  #ifndef DEFAULT_PIDLOG
  #define DEFAULT_PIDLOG DEFAULT_REL_RUNTIMEDIR "/httpd.pid"
--- 46,51 ----
Only in /tmp/patch.inc.get1.AvnxJA/server/mpm/prefork: mpm.h
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/mpm/prefork/prefork.c /tmp/patch.inc.get2.9J0UCU/server/mpm/prefork/prefork.c
*** /tmp/patch.inc.get1.AvnxJA/server/mpm/prefork/prefork.c	2013-04-28 19:22:12.443306550 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/mpm/prefork/prefork.c	2013-04-28 19:22:13.559312070 +0200
***************
*** 31,38 ****
  #include <sys/types.h>
  #endif
  
- #define CORE_PRIVATE
- 
  #include "ap_config.h"
  #include "httpd.h"
  #include "mpm_default.h"
--- 31,36 ----
***************
*** 43,57 ****
  #include "http_connection.h"
  #include "scoreboard.h"
  #include "ap_mpm.h"
  #include "unixd.h"
  #include "mpm_common.h"
  #include "ap_listen.h"
  #include "ap_mmn.h"
  #include "apr_poll.h"
  
- #ifdef HAVE_BSTRING_H
- #include <bstring.h>            /* for IRIX, FD_SET calls bzero() */
- #endif
  #ifdef HAVE_TIME_H
  #include <time.h>
  #endif
--- 41,53 ----
  #include "http_connection.h"
  #include "scoreboard.h"
  #include "ap_mpm.h"
+ #include "util_mutex.h"
  #include "unixd.h"
  #include "mpm_common.h"
  #include "ap_listen.h"
  #include "ap_mmn.h"
  #include "apr_poll.h"
  
  #ifdef HAVE_TIME_H
  #include <time.h>
  #endif
***************
*** 90,114 ****
  
  /* config globals */
  
- int ap_threads_per_child=0;         /* Worker threads per child */
  static apr_proc_mutex_t *accept_mutex;
  static int ap_daemons_to_start=0;
  static int ap_daemons_min_free=0;
  static int ap_daemons_max_free=0;
  static int ap_daemons_limit=0;      /* MaxClients */
! static int server_limit = DEFAULT_SERVER_LIMIT;
! static int first_server_limit = 0;
! static int changed_limit_at_restart;
  static int mpm_state = AP_MPMQ_STARTING;
  static ap_pod_t *pod;
  
  /*
   * The max child slot ever assigned, preserved across restarts.  Necessary
   * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We
   * use this value to optimize routines that have to scan the entire scoreboard.
   */
! int ap_max_daemons_limit = -1;
! server_rec *ap_server_conf;
  
  /* one_process --- debugging mode variable; can be set from the command line
   * with the -X flag.  If set, this gets you the child_main loop running
--- 86,118 ----
  
  /* config globals */
  
  static apr_proc_mutex_t *accept_mutex;
  static int ap_daemons_to_start=0;
  static int ap_daemons_min_free=0;
  static int ap_daemons_max_free=0;
  static int ap_daemons_limit=0;      /* MaxClients */
! static int server_limit = 0;
  static int mpm_state = AP_MPMQ_STARTING;
  static ap_pod_t *pod;
  
+ /* data retained by prefork across load/unload of the module
+  * allocated on first call to pre-config hook; located on
+  * subsequent calls to pre-config hook
+  */
+ typedef struct prefork_retained_data {
+     int first_server_limit;
+     int module_loads;
+ } prefork_retained_data;
+ static prefork_retained_data *retained;
+ 
+ #define MPM_CHILD_PID(i) (ap_scoreboard_image->parent[i].pid)
+ 
  /*
   * The max child slot ever assigned, preserved across restarts.  Necessary
   * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We
   * use this value to optimize routines that have to scan the entire scoreboard.
   */
! static int max_daemons_limit = -1;
  
  /* one_process --- debugging mode variable; can be set from the command line
   * with the -X flag.  If set, this gets you the child_main loop running
*************** static apr_pool_t *pchild;
*** 128,142 ****
  
  static pid_t ap_my_pid; /* it seems silly to call getpid all the time */
  static pid_t parent_pid;
- #ifndef MULTITHREAD
  static int my_child_num;
! #endif
! ap_generation_t volatile ap_my_generation=0;
! 
! #ifdef TPF
! int tpf_child = 0;
! char tpf_server_name[INETD_SERVNAME_LENGTH+1];
! #endif /* TPF */
  
  static volatile int die_now = 0;
  
--- 132,139 ----
  
  static pid_t ap_my_pid; /* it seems silly to call getpid all the time */
  static pid_t parent_pid;
  static int my_child_num;
! static ap_generation_t volatile my_generation=0;
  
  static volatile int die_now = 0;
  
*************** static void chdir_for_gprof(void)
*** 182,191 ****
  #define chdir_for_gprof()
  #endif
  
- /* XXX - I don't know if TPF will ever use this module or not, so leave
-  * the ap_check_signals calls in but disable them - manoj */
- #define ap_check_signals()
- 
  /* a clean exit from a child with proper cleanup */
  static void clean_child_exit(int code) __attribute__ ((noreturn));
  static void clean_child_exit(int code)
--- 179,184 ----
*************** static void accept_mutex_on(void)
*** 206,212 ****
      if (rv != APR_SUCCESS) {
          const char *msg = "couldn't grab the accept mutex";
  
!         if (ap_my_generation !=
              ap_scoreboard_image->global->running_generation) {
              ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, NULL, "%s", msg);
              clean_child_exit(0);
--- 199,205 ----
      if (rv != APR_SUCCESS) {
          const char *msg = "couldn't grab the accept mutex";
  
!         if (my_generation !=
              ap_scoreboard_image->global->running_generation) {
              ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, NULL, "%s", msg);
              clean_child_exit(0);
*************** static void accept_mutex_off(void)
*** 224,230 ****
      if (rv != APR_SUCCESS) {
          const char *msg = "couldn't release the accept mutex";
  
!         if (ap_my_generation !=
              ap_scoreboard_image->global->running_generation) {
              ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, NULL, "%s", msg);
              /* don't exit here... we have a connection to
--- 217,223 ----
      if (rv != APR_SUCCESS) {
          const char *msg = "couldn't release the accept mutex";
  
!         if (my_generation !=
              ap_scoreboard_image->global->running_generation) {
              ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, NULL, "%s", msg);
              /* don't exit here... we have a connection to
*************** static void accept_mutex_off(void)
*** 250,323 ****
  #define SAFE_ACCEPT(stmt) do {stmt;} while(0)
  #endif
  
! AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
  {
      switch(query_code){
      case AP_MPMQ_MAX_DAEMON_USED:
          *result = ap_daemons_limit;
!         return APR_SUCCESS;
      case AP_MPMQ_IS_THREADED:
          *result = AP_MPMQ_NOT_SUPPORTED;
!         return APR_SUCCESS;
      case AP_MPMQ_IS_FORKED:
          *result = AP_MPMQ_DYNAMIC;
!         return APR_SUCCESS;
      case AP_MPMQ_HARD_LIMIT_DAEMONS:
          *result = server_limit;
!         return APR_SUCCESS;
      case AP_MPMQ_HARD_LIMIT_THREADS:
          *result = HARD_THREAD_LIMIT;
!         return APR_SUCCESS;
      case AP_MPMQ_MAX_THREADS:
          *result = 0;
!         return APR_SUCCESS;
      case AP_MPMQ_MIN_SPARE_DAEMONS:
          *result = ap_daemons_min_free;
!         return APR_SUCCESS;
      case AP_MPMQ_MIN_SPARE_THREADS:
          *result = 0;
!         return APR_SUCCESS;
      case AP_MPMQ_MAX_SPARE_DAEMONS:
          *result = ap_daemons_max_free;
!         return APR_SUCCESS;
      case AP_MPMQ_MAX_SPARE_THREADS:
          *result = 0;
!         return APR_SUCCESS;
      case AP_MPMQ_MAX_REQUESTS_DAEMON:
          *result = ap_max_requests_per_child;
!         return APR_SUCCESS;
      case AP_MPMQ_MAX_DAEMONS:
          *result = server_limit;
!         return APR_SUCCESS;
      case AP_MPMQ_MPM_STATE:
          *result = mpm_state;
!         return APR_SUCCESS;
      }
!     return APR_ENOTIMPL;
  }
  
! #if defined(NEED_WAITPID)
! /*
!    Systems without a real waitpid sometimes lose a child's exit while waiting
!    for another.  Search through the scoreboard for missing children.
!  */
! int reap_children(int *exitcode, apr_exit_why_e *status)
  {
!     int n, pid;
  
!     for (n = 0; n < ap_max_daemons_limit; ++n) {
!         if (ap_scoreboard_image->servers[n][0].status != SERVER_DEAD &&
!                 kill((pid = ap_scoreboard_image->parent[n].pid), 0) == -1) {
!             ap_update_child_status_from_indexes(n, 0, SERVER_DEAD, NULL);
!             /* just mark it as having a successful exit status */
!             *status = APR_PROC_EXIT;
!             *exitcode = 0;
!             return(pid);
!         }
!     }
!     return 0;
  }
- #endif
  
  /*****************************************************************
   * Connection structures and accounting...
--- 243,311 ----
  #define SAFE_ACCEPT(stmt) do {stmt;} while(0)
  #endif
  
! static int prefork_query(int query_code, int *result, apr_status_t *rv)
  {
+     *rv = APR_SUCCESS;
      switch(query_code){
      case AP_MPMQ_MAX_DAEMON_USED:
          *result = ap_daemons_limit;
!         break;
      case AP_MPMQ_IS_THREADED:
          *result = AP_MPMQ_NOT_SUPPORTED;
!         break;
      case AP_MPMQ_IS_FORKED:
          *result = AP_MPMQ_DYNAMIC;
!         break;
      case AP_MPMQ_HARD_LIMIT_DAEMONS:
          *result = server_limit;
!         break;
      case AP_MPMQ_HARD_LIMIT_THREADS:
          *result = HARD_THREAD_LIMIT;
!         break;
      case AP_MPMQ_MAX_THREADS:
          *result = 0;
!         break;
      case AP_MPMQ_MIN_SPARE_DAEMONS:
          *result = ap_daemons_min_free;
!         break;
      case AP_MPMQ_MIN_SPARE_THREADS:
          *result = 0;
!         break;
      case AP_MPMQ_MAX_SPARE_DAEMONS:
          *result = ap_daemons_max_free;
!         break;
      case AP_MPMQ_MAX_SPARE_THREADS:
          *result = 0;
!         break;
      case AP_MPMQ_MAX_REQUESTS_DAEMON:
          *result = ap_max_requests_per_child;
!         break;
      case AP_MPMQ_MAX_DAEMONS:
          *result = server_limit;
!         break;
      case AP_MPMQ_MPM_STATE:
          *result = mpm_state;
!         break;
!     case AP_MPMQ_GENERATION:
!         *result = my_generation;
!         break;
!     default:
!         *rv = APR_ENOTIMPL;
!         break;
      }
!     return OK;
  }
  
! static apr_status_t prefork_note_child_killed(int childnum)
  {
!     ap_scoreboard_image->parent[childnum].pid = 0;
!     return APR_SUCCESS;
! }
  
! static const char *prefork_get_name(void)
! {
!     return "prefork";
  }
  
  /*****************************************************************
   * Connection structures and accounting...
*************** static void just_die(int sig)
*** 330,336 ****
  
  static void stop_listening(int sig)
  {
-     mpm_state = AP_MPMQ_STOPPING;
      ap_close_listeners();
  
      /* For a graceful stop, we want the child to exit when done */
--- 318,323 ----
*************** static void sig_term(int sig)
*** 351,357 ****
           */
          return;
      }
-     mpm_state = AP_MPMQ_STOPPING;
      shutdown_pending = 1;
      is_graceful = (sig == AP_SIG_GRACEFUL_STOP);
  }
--- 338,343 ----
*************** static void restart(int sig)
*** 365,371 ****
          /* Probably not an error - don't bother reporting it */
          return;
      }
-     mpm_state = AP_MPMQ_STOPPING;
      restart_pending = 1;
      is_graceful = (sig == AP_SIG_GRACEFUL);
  }
--- 351,356 ----
*************** static void set_signals(void)
*** 458,475 ****
  static int requests_this_child;
  static int num_listensocks = 0;
  
- 
- int ap_graceful_stop_signalled(void)
- {
-     /* Return true if the server is stopping for whatever reason; the
-      * function is used to initiate a fast exit from the connection
-      * processing loop. */
-     return mpm_state == AP_MPMQ_STOPPING;
- }
- 
- 
  static void child_main(int child_num_arg)
  {
      apr_pool_t *ptrans;
      apr_allocator_t *allocator;
      apr_status_t status;
--- 443,454 ----
  static int requests_this_child;
  static int num_listensocks = 0;
  
  static void child_main(int child_num_arg)
  {
+ #if APR_HAS_THREADS
+     apr_thread_t *thd = NULL;
+     apr_os_thread_t osthd;
+ #endif
      apr_pool_t *ptrans;
      apr_allocator_t *allocator;
      apr_status_t status;
*************** static void child_main(int child_num_arg
*** 479,484 ****
--- 458,464 ----
      ap_sb_handle_t *sbh;
      apr_bucket_alloc_t *bucket_alloc;
      int last_poll_idx = 0;
+     const char *lockfile;
  
      mpm_state = AP_MPMQ_STARTING; /* for benefit of any hooks that run as this
                                     * child initializes
*************** static void child_main(int child_num_arg
*** 497,517 ****
      apr_allocator_max_free_set(allocator, ap_max_mem_free);
      apr_pool_create_ex(&pchild, pconf, NULL, allocator);
      apr_allocator_owner_set(allocator, pchild);
  
      apr_pool_create(&ptrans, pchild);
      apr_pool_tag(ptrans, "transaction");
  
      /* needs to be done before we switch UIDs so we have permissions */
      ap_reopen_scoreboard(pchild, NULL, 0);
!     status = apr_proc_mutex_child_init(&accept_mutex, ap_lock_fname, pchild);
      if (status != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
                       "Couldn't initialize cross-process lock in child "
!                      "(%s) (%d)", ap_lock_fname, ap_accept_lock_mech);
          clean_child_exit(APEXIT_CHILDFATAL);
      }
  
!     if (unixd_setup_child()) {
          clean_child_exit(APEXIT_CHILDFATAL);
      }
  
--- 477,508 ----
      apr_allocator_max_free_set(allocator, ap_max_mem_free);
      apr_pool_create_ex(&pchild, pconf, NULL, allocator);
      apr_allocator_owner_set(allocator, pchild);
+     apr_pool_tag(pchild, "pchild");
  
+ #if APR_HAS_THREADS
+     osthd = apr_os_thread_current();
+     apr_os_thread_put(&thd, &osthd, pchild);
+ #endif
+     
      apr_pool_create(&ptrans, pchild);
      apr_pool_tag(ptrans, "transaction");
  
      /* needs to be done before we switch UIDs so we have permissions */
      ap_reopen_scoreboard(pchild, NULL, 0);
!     lockfile = apr_proc_mutex_lockfile(accept_mutex);
!     status = apr_proc_mutex_child_init(&accept_mutex,
!                                        lockfile,
!                                        pchild);
      if (status != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
                       "Couldn't initialize cross-process lock in child "
!                      "(%s) (%s)",
!                      lockfile ? lockfile : "none",
!                      apr_proc_mutex_name(accept_mutex));
          clean_child_exit(APEXIT_CHILDFATAL);
      }
  
!     if (ap_run_drop_privileges(pchild, ap_server_conf)) {
          clean_child_exit(APEXIT_CHILDFATAL);
      }
  
*************** static void child_main(int child_num_arg
*** 537,544 ****
          pfd.reqevents = APR_POLLIN;
          pfd.client_data = lr;
  
!         /* ### check the status */
!         (void) apr_pollset_add(pollset, &pfd);
      }
  
      mpm_state = AP_MPMQ_RUNNING;
--- 528,541 ----
          pfd.reqevents = APR_POLLIN;
          pfd.client_data = lr;
  
!         status = apr_pollset_add(pollset, &pfd);
!         if (status != APR_SUCCESS) {
!             ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
!                          "Couldn't add listener to pollset; check system or user limits");
!             clean_child_exit(APEXIT_CHILDSICK);
!         }
! 
!         lr->accept_func = ap_unixd_accept;
      }
  
      mpm_state = AP_MPMQ_RUNNING;
*************** static void child_main(int child_num_arg
*** 614,620 ****
                      ap_log_error(APLOG_MARK, APLOG_ERR, status,
                                   ap_server_conf, "apr_pollset_poll: (listen)");
                      SAFE_ACCEPT(accept_mutex_off());
!                     clean_child_exit(APEXIT_CHILDSICK);
                  }
  
                  /* We can always use pdesc[0], but sockets at position N
--- 611,617 ----
                      ap_log_error(APLOG_MARK, APLOG_ERR, status,
                                   ap_server_conf, "apr_pollset_poll: (listen)");
                      SAFE_ACCEPT(accept_mutex_off());
!                     clean_child_exit(1);
                  }
  
                  /* We can always use pdesc[0], but sockets at position N
*************** static void child_main(int child_num_arg
*** 651,657 ****
  
          if (status == APR_EGENERAL) {
              /* resource shortage or should-not-occur occured */
!             clean_child_exit(APEXIT_CHILDSICK);
          }
          else if (status != APR_SUCCESS) {
              continue;
--- 648,654 ----
  
          if (status == APR_EGENERAL) {
              /* resource shortage or should-not-occur occured */
!             clean_child_exit(1);
          }
          else if (status != APR_SUCCESS) {
              continue;
*************** static void child_main(int child_num_arg
*** 664,669 ****
--- 661,669 ----
  
          current_conn = ap_run_create_connection(ptrans, ap_server_conf, csd, my_child_num, sbh, bucket_alloc);
          if (current_conn) {
+ #if APR_HAS_THREADS
+             current_conn->current_thread = thd;
+ #endif
              ap_process_connection(current_conn, csd);
              ap_lingering_close(current_conn);
          }
*************** static void child_main(int child_num_arg
*** 676,682 ****
          if (ap_mpm_pod_check(pod) == APR_SUCCESS) { /* selected as idle? */
              die_now = 1;
          }
!         else if (ap_my_generation !=
                   ap_scoreboard_image->global->running_generation) { /* restart? */
              /* yeah, this could be non-graceful restart, in which case the
               * parent will kill us soon enough, but why bother checking?
--- 676,682 ----
          if (ap_mpm_pod_check(pod) == APR_SUCCESS) { /* selected as idle? */
              die_now = 1;
          }
!         else if (my_generation !=
                   ap_scoreboard_image->global->running_generation) { /* restart? */
              /* yeah, this could be non-graceful restart, in which case the
               * parent will kill us soon enough, but why bother checking?
*************** static void child_main(int child_num_arg
*** 684,694 ****
              die_now = 1;
          }
      }
-     /* This apr_pool_clear call is redundant, should be redundant, but compensates
-      * a flaw in the apr reslist code.  This should be removed once that flaw has
-      * been addressed.
-      */
-     apr_pool_clear(ptrans);
      clean_child_exit(0);
  }
  
--- 684,689 ----
*************** static int make_child(server_rec *s, int
*** 697,704 ****
  {
      int pid;
  
!     if (slot + 1 > ap_max_daemons_limit) {
!         ap_max_daemons_limit = slot + 1;
      }
  
      if (one_process) {
--- 692,699 ----
  {
      int pid;
  
!     if (slot + 1 > max_daemons_limit) {
!         max_daemons_limit = slot + 1;
      }
  
      if (one_process) {
*************** static int make_child(server_rec *s, int
*** 719,727 ****
  
  #ifdef _OSD_POSIX
      /* BS2000 requires a "special" version of fork() before a setuid() call */
!     if ((pid = os_fork(unixd_config.user_name)) == -1) {
! #elif defined(TPF)
!     if ((pid = os_fork(s, slot)) == -1) {
  #else
      if ((pid = fork()) == -1) {
  #endif
--- 714,720 ----
  
  #ifdef _OSD_POSIX
      /* BS2000 requires a "special" version of fork() before a setuid() call */
!     if ((pid = os_fork(ap_unixd_config.user_name)) == -1) {
  #else
      if ((pid = fork()) == -1) {
  #endif
*************** static void perform_idle_server_maintena
*** 825,831 ****
      for (i = 0; i < ap_daemons_limit; ++i) {
          int status;
  
!         if (i >= ap_max_daemons_limit && free_length == idle_spawn_rate)
              break;
          ws = &ap_scoreboard_image->servers[i][0];
          status = ws->status;
--- 818,824 ----
      for (i = 0; i < ap_daemons_limit; ++i) {
          int status;
  
!         if (i >= max_daemons_limit && free_length == idle_spawn_rate)
              break;
          ws = &ap_scoreboard_image->servers[i][0];
          status = ws->status;
*************** static void perform_idle_server_maintena
*** 858,864 ****
              last_non_dead = i;
          }
      }
!     ap_max_daemons_limit = last_non_dead + 1;
      if (idle_count > ap_daemons_max_free) {
          /* kill off one child... we use the pod because that'll cause it to
           * shut down gracefully, in case it happened to pick up a request
--- 851,857 ----
              last_non_dead = i;
          }
      }
!     max_daemons_limit = last_non_dead + 1;
      if (idle_count > ap_daemons_max_free) {
          /* kill off one child... we use the pod because that'll cause it to
           * shut down gracefully, in case it happened to pick up a request
*************** static void perform_idle_server_maintena
*** 891,907 ****
                      idle_count, total_non_dead);
              }
              for (i = 0; i < free_length; ++i) {
- #ifdef TPF
-                 if (make_child(ap_server_conf, free_slots[i]) == -1) {
-                     if(free_length == 1) {
-                         shutdown_pending = 1;
-                         ap_log_error(APLOG_MARK, APLOG_EMERG, 0, ap_server_conf,
-                                     "No active child processes: shutting down");
-                     }
-                 }
- #else
                  make_child(ap_server_conf, free_slots[i]);
- #endif /* TPF */
              }
              /* the next time around we want to spawn twice as many if this
               * wasn't good enough, but not if we've just done a graceful
--- 884,890 ----
*************** static void perform_idle_server_maintena
*** 923,929 ****
   * Executive routines.
   */
  
! int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
  {
      int index;
      int remaining_children_to_start;
--- 906,912 ----
   * Executive routines.
   */
  
! static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
  {
      int index;
      int remaining_children_to_start;
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 931,984 ****
  
      ap_log_pid(pconf, ap_pid_fname);
  
-     first_server_limit = server_limit;
-     if (changed_limit_at_restart) {
-         ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
-                      "WARNING: Attempt to change ServerLimit "
-                      "ignored during restart");
-         changed_limit_at_restart = 0;
-     }
- 
      /* Initialize cross-process accept lock */
!     ap_lock_fname = apr_psprintf(_pconf, "%s.%" APR_PID_T_FMT,
!                                  ap_server_root_relative(_pconf, ap_lock_fname),
!                                  ap_my_pid);
! 
!     rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname,
!                                ap_accept_lock_mech, _pconf);
      if (rv != APR_SUCCESS) {
-         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
-                      "Couldn't create accept lock (%s) (%d)",
-                      ap_lock_fname, ap_accept_lock_mech);
          mpm_state = AP_MPMQ_STOPPING;
!         return 1;
!     }
! 
! #if APR_USE_SYSVSEM_SERIALIZE
!     if (ap_accept_lock_mech == APR_LOCK_DEFAULT ||
!         ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
! #else
!     if (ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
! #endif
!         rv = unixd_set_proc_mutex_perms(accept_mutex);
!         if (rv != APR_SUCCESS) {
!             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
!                          "Couldn't set permissions on cross-process lock; "
!                          "check User and Group directives");
!             mpm_state = AP_MPMQ_STOPPING;
!             return 1;
!         }
      }
  
      if (!is_graceful) {
          if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) {
              mpm_state = AP_MPMQ_STOPPING;
!             return 1;
          }
          /* fix the generation number in the global score; we just got a new,
           * cleared scoreboard
           */
!         ap_scoreboard_image->global->running_generation = ap_my_generation;
      }
  
      set_signals();
--- 914,936 ----
  
      ap_log_pid(pconf, ap_pid_fname);
  
      /* Initialize cross-process accept lock */
!     rv = ap_proc_mutex_create(&accept_mutex, ap_accept_mutex_type, NULL, s,
!                               _pconf, 0);
      if (rv != APR_SUCCESS) {
          mpm_state = AP_MPMQ_STOPPING;
!         return DONE;
      }
  
      if (!is_graceful) {
          if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) {
              mpm_state = AP_MPMQ_STOPPING;
!             return DONE;
          }
          /* fix the generation number in the global score; we just got a new,
           * cleared scoreboard
           */
!         ap_scoreboard_image->global->running_generation = my_generation;
      }
  
      set_signals();
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1019,1030 ****
                  ap_get_server_description());
      ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
                  "Server built: %s", ap_get_server_built());
- #ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
      ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
!                 "AcceptMutex: %s (default: %s)",
                  apr_proc_mutex_name(accept_mutex),
                  apr_proc_mutex_defname());
- #endif
      restart_pending = shutdown_pending = 0;
  
      mpm_state = AP_MPMQ_RUNNING;
--- 971,980 ----
                  ap_get_server_description());
      ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
                  "Server built: %s", ap_get_server_built());
      ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
!                 "Accept mutex: %s (default: %s)",
                  apr_proc_mutex_name(accept_mutex),
                  apr_proc_mutex_defname());
      restart_pending = shutdown_pending = 0;
  
      mpm_state = AP_MPMQ_RUNNING;
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1036,1042 ****
          /* this is a memory leak, but I'll fix it later. */
          apr_proc_t pid;
  
!         ap_wait_or_timeout(&exitwhy, &status, &pid, pconf);
  
          /* XXX: if it takes longer than 1 second for all our children
           * to start up and get into IDLE state then we may spawn an
--- 986,992 ----
          /* this is a memory leak, but I'll fix it later. */
          apr_proc_t pid;
  
!         ap_wait_or_timeout(&exitwhy, &status, &pid, pconf, ap_server_conf);
  
          /* XXX: if it takes longer than 1 second for all our children
           * to start up and get into IDLE state then we may spawn an
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1046,1056 ****
              processed_status = ap_process_child_status(&pid, exitwhy, status);
              if (processed_status == APEXIT_CHILDFATAL) {
                  mpm_state = AP_MPMQ_STOPPING;
!                 return 1;
              }
  
              /* non-fatal death... note that it's gone in the scoreboard. */
!             child_slot = find_child_by_pid(&pid);
              if (child_slot >= 0) {
                  (void) ap_update_child_status_from_indexes(child_slot, 0, SERVER_DEAD,
                                                             (request_rec *) NULL);
--- 996,1006 ----
              processed_status = ap_process_child_status(&pid, exitwhy, status);
              if (processed_status == APEXIT_CHILDFATAL) {
                  mpm_state = AP_MPMQ_STOPPING;
!                 return DONE;
              }
  
              /* non-fatal death... note that it's gone in the scoreboard. */
!             child_slot = ap_find_child_by_pid(&pid);
              if (child_slot >= 0) {
                  (void) ap_update_child_status_from_indexes(child_slot, 0, SERVER_DEAD,
                                                             (request_rec *) NULL);
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1105,1115 ****
          }
  
          perform_idle_server_maintenance(pconf);
- #ifdef TPF
-         shutdown_pending = os_check_server(tpf_server_name);
-         ap_check_signals();
-         sleep(1);
- #endif /*TPF */
      }
      } /* one_process */
  
--- 1055,1060 ----
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1119,1125 ****
          /* Time to shut down:
           * Kill child processes, tell them to call child_exit, etc...
           */
!         if (unixd_killpg(getpgrp(), SIGTERM) < 0) {
              ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "killpg SIGTERM");
          }
          ap_reclaim_child_processes(1);          /* Start with SIGTERM */
--- 1064,1070 ----
          /* Time to shut down:
           * Kill child processes, tell them to call child_exit, etc...
           */
!         if (ap_unixd_killpg(getpgrp(), SIGTERM) < 0) {
              ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "killpg SIGTERM");
          }
          ap_reclaim_child_processes(1);          /* Start with SIGTERM */
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1138,1144 ****
          ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                      "caught SIGTERM, shutting down");
  
!         return 1;
      } else if (shutdown_pending) {
          /* Time to perform a graceful shut down:
           * Reap the inactive children, and ask the active ones
--- 1083,1089 ----
          ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                      "caught SIGTERM, shutting down");
  
!         return DONE;
      } else if (shutdown_pending) {
          /* Time to perform a graceful shut down:
           * Reap the inactive children, and ask the active ones
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1152,1158 ****
          ap_close_listeners();
  
          /* kill off the idle ones */
!         ap_mpm_pod_killpg(pod, ap_max_daemons_limit);
  
          /* Send SIGUSR1 to the active children */
          active_children = 0;
--- 1097,1103 ----
          ap_close_listeners();
  
          /* kill off the idle ones */
!         ap_mpm_pod_killpg(pod, max_daemons_limit);
  
          /* Send SIGUSR1 to the active children */
          active_children = 0;
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1210,1218 ****
           * way, try and make sure that all of our processes are
           * really dead.
           */
!         unixd_killpg(getpgrp(), SIGTERM);
  
!         return 1;
      }
  
      /* we've been told to restart */
--- 1155,1163 ----
           * way, try and make sure that all of our processes are
           * really dead.
           */
!         ap_unixd_killpg(getpgrp(), SIGTERM);
  
!         return DONE;
      }
  
      /* we've been told to restart */
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1220,1241 ****
      apr_signal(AP_SIG_GRACEFUL, SIG_IGN);
      if (one_process) {
          /* not worth thinking about */
!         return 1;
      }
  
      /* advance to the next generation */
      /* XXX: we really need to make sure this new generation number isn't in
       * use by any of the children.
       */
!     ++ap_my_generation;
!     ap_scoreboard_image->global->running_generation = ap_my_generation;
  
      if (is_graceful) {
          ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                      "Graceful restart requested, doing restart");
  
          /* kill off the idle ones */
!         ap_mpm_pod_killpg(pod, ap_max_daemons_limit);
  
          /* This is mostly for debugging... so that we know what is still
           * gracefully dealing with existing request.  This will break
--- 1165,1186 ----
      apr_signal(AP_SIG_GRACEFUL, SIG_IGN);
      if (one_process) {
          /* not worth thinking about */
!         return DONE;
      }
  
      /* advance to the next generation */
      /* XXX: we really need to make sure this new generation number isn't in
       * use by any of the children.
       */
!     ++my_generation;
!     ap_scoreboard_image->global->running_generation = my_generation;
  
      if (is_graceful) {
          ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                      "Graceful restart requested, doing restart");
  
          /* kill off the idle ones */
!         ap_mpm_pod_killpg(pod, max_daemons_limit);
  
          /* This is mostly for debugging... so that we know what is still
           * gracefully dealing with existing request.  This will break
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1258,1264 ****
      }
      else {
          /* Kill 'em off */
!         if (unixd_killpg(getpgrp(), SIGHUP) < 0) {
              ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "killpg SIGHUP");
          }
          ap_reclaim_child_processes(0);          /* Not when just starting up */
--- 1203,1209 ----
      }
      else {
          /* Kill 'em off */
!         if (ap_unixd_killpg(getpgrp(), SIGHUP) < 0) {
              ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "killpg SIGHUP");
          }
          ap_reclaim_child_processes(0);          /* Not when just starting up */
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1266,1272 ****
                      "SIGHUP received.  Attempting to restart");
      }
  
!     return 0;
  }
  
  /* This really should be a post_config hook, but the error log is already
--- 1211,1217 ----
                      "SIGHUP received.  Attempting to restart");
      }
  
!     return OK;
  }
  
  /* This really should be a post_config hook, but the error log is already
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1274,1293 ****
   */
  static int prefork_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
  {
      apr_status_t rv;
  
      pconf = p;
!     ap_server_conf = s;
  
      if ((num_listensocks = ap_setup_listeners(ap_server_conf)) < 1) {
!         ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0,
!                      NULL, "no listening sockets available, shutting down");
          return DONE;
      }
  
      if ((rv = ap_mpm_pod_open(pconf, &pod))) {
!         ap_log_error(APLOG_MARK, APLOG_CRIT|APLOG_STARTUP, rv, NULL,
!                 "Could not open pipe-of-death.");
          return DONE;
      }
      return OK;
--- 1219,1247 ----
   */
  static int prefork_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
  {
+     int startup = 0;
+     int level_flags = 0;
      apr_status_t rv;
  
      pconf = p;
! 
!     /* the reverse of pre_config, we want this only the first time around */
!     if (retained->module_loads == 1) {
!         startup = 1;
!         level_flags |= APLOG_STARTUP;
!     }
  
      if ((num_listensocks = ap_setup_listeners(ap_server_conf)) < 1) {
!         ap_log_error(APLOG_MARK, APLOG_ALERT | level_flags, 0,
!                      (startup ? NULL : s),
!                      "no listening sockets available, shutting down");
          return DONE;
      }
  
      if ((rv = ap_mpm_pod_open(pconf, &pod))) {
!         ap_log_error(APLOG_MARK, APLOG_CRIT | level_flags, rv,
!                      (startup ? NULL : s),
!                      "could not open pipe-of-death");
          return DONE;
      }
      return OK;
*************** static int prefork_open_logs(apr_pool_t
*** 1295,1303 ****
  
  static int prefork_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp)
  {
-     static int restart_num = 0;
      int no_detach, debug, foreground;
      apr_status_t rv;
  
      mpm_state = AP_MPMQ_STARTING;
  
--- 1249,1257 ----
  
  static int prefork_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp)
  {
      int no_detach, debug, foreground;
      apr_status_t rv;
+     const char *userdata_key = "mpm_prefork_module";
  
      mpm_state = AP_MPMQ_STARTING;
  
*************** static int prefork_pre_config(apr_pool_t
*** 1314,1321 ****
          foreground = ap_exists_config_define("FOREGROUND");
      }
  
      /* sigh, want this only the second time around */
!     if (restart_num++ == 1) {
          is_graceful = 0;
  
          if (!one_process && !foreground) {
--- 1268,1282 ----
          foreground = ap_exists_config_define("FOREGROUND");
      }
  
+     ap_mutex_register(p, ap_accept_mutex_type, NULL, APR_LOCK_DEFAULT, 0);
+ 
      /* sigh, want this only the second time around */
!     retained = ap_retained_data_get(userdata_key);
!     if (!retained) {
!         retained = ap_retained_data_create(userdata_key, sizeof(*retained));
!     }
!     ++retained->module_loads;
!     if (retained->module_loads == 2) {
          is_graceful = 0;
  
          if (!one_process && !foreground) {
*************** static int prefork_pre_config(apr_pool_t
*** 1331,1372 ****
          parent_pid = ap_my_pid = getpid();
      }
  
-     unixd_pre_config(ptemp);
      ap_listen_pre_config();
      ap_daemons_to_start = DEFAULT_START_DAEMON;
      ap_daemons_min_free = DEFAULT_MIN_FREE_DAEMON;
      ap_daemons_max_free = DEFAULT_MAX_FREE_DAEMON;
      ap_daemons_limit = server_limit;
      ap_pid_fname = DEFAULT_PIDLOG;
-     ap_lock_fname = DEFAULT_LOCKFILE;
      ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
      ap_extended_status = 0;
- #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
      ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
- #endif
  
      apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
  
      return OK;
  }
  
  static void prefork_hooks(apr_pool_t *p)
  {
!     /* The prefork open_logs phase must run before the core's, or stderr
       * will be redirected to a file, and the messages won't print to the
       * console.
       */
      static const char *const aszSucc[] = {"core.c", NULL};
  
! #ifdef AUX3
!     (void) set42sig();
! #endif
! 
!     ap_hook_open_logs(prefork_open_logs, NULL, aszSucc, APR_HOOK_MIDDLE);
      /* we need to set the MPM state before other pre-config hooks use MPM query
       * to retrieve it, so register as REALLY_FIRST
       */
      ap_hook_pre_config(prefork_pre_config, NULL, NULL, APR_HOOK_REALLY_FIRST);
  }
  
  static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy, const char *arg)
--- 1292,1453 ----
          parent_pid = ap_my_pid = getpid();
      }
  
      ap_listen_pre_config();
      ap_daemons_to_start = DEFAULT_START_DAEMON;
      ap_daemons_min_free = DEFAULT_MIN_FREE_DAEMON;
      ap_daemons_max_free = DEFAULT_MAX_FREE_DAEMON;
+     server_limit = DEFAULT_SERVER_LIMIT;
      ap_daemons_limit = server_limit;
      ap_pid_fname = DEFAULT_PIDLOG;
      ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
      ap_extended_status = 0;
      ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
  
      apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
  
      return OK;
  }
  
+ static int prefork_check_config(apr_pool_t *p, apr_pool_t *plog,
+                                 apr_pool_t *ptemp, server_rec *s)
+ {
+     int startup = 0;
+ 
+     /* the reverse of pre_config, we want this only the first time around */
+     if (retained->module_loads == 1) {
+         startup = 1;
+     }
+ 
+     if (server_limit > MAX_SERVER_LIMIT) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: ServerLimit of %d exceeds compile-time "
+                          "limit of", server_limit);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " %d servers, decreasing to %d.",
+                          MAX_SERVER_LIMIT, MAX_SERVER_LIMIT);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "ServerLimit of %d exceeds compile-time limit "
+                          "of %d, decreasing to match",
+                          server_limit, MAX_SERVER_LIMIT);
+         }
+         server_limit = MAX_SERVER_LIMIT;
+     }
+     else if (server_limit < 1) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: ServerLimit of %d not allowed, "
+                          "increasing to 1.", server_limit);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "ServerLimit of %d not allowed, increasing to 1",
+                          server_limit);
+         }
+         server_limit = 1;
+     }
+ 
+     /* you cannot change ServerLimit across a restart; ignore
+      * any such attempts
+      */
+     if (!retained->first_server_limit) {
+         retained->first_server_limit = server_limit;
+     }
+     else if (server_limit != retained->first_server_limit) {
+         /* don't need a startup console version here */
+         ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                      "changing ServerLimit to %d from original value of %d "
+                      "not allowed during restart",
+                      server_limit, retained->first_server_limit);
+         server_limit = retained->first_server_limit;
+     }
+ 
+     if (ap_daemons_limit > server_limit) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: MaxClients of %d exceeds ServerLimit "
+                          "value of", ap_daemons_limit);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " %d servers, decreasing MaxClients to %d.",
+                          server_limit, server_limit);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " To increase, please see the ServerLimit "
+                          "directive.");
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "MaxClients of %d exceeds ServerLimit value "
+                          "of %d, decreasing to match",
+                          ap_daemons_limit, server_limit);
+         }
+         ap_daemons_limit = server_limit;
+     }
+     else if (ap_daemons_limit < 1) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: MaxClients of %d not allowed, "
+                          "increasing to 1.", ap_daemons_limit);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "MaxClients of %d not allowed, increasing to 1",
+                          ap_daemons_limit);
+         }
+         ap_daemons_limit = 1;
+     }
+ 
+     /* ap_daemons_to_start > ap_daemons_limit checked in prefork_run() */
+     if (ap_daemons_to_start < 0) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: StartServers of %d not allowed, "
+                          "increasing to 1.", ap_daemons_to_start);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "StartServers of %d not allowed, increasing to 1",
+                          ap_daemons_to_start);
+         }
+         ap_daemons_to_start = 1;
+     }
+ 
+     if (ap_daemons_min_free < 1) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: MinSpareServers of %d not allowed, "
+                          "increasing to 1", ap_daemons_min_free);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " to avoid almost certain server failure.");
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " Please read the documentation.");
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "MinSpareServers of %d not allowed, increasing to 1",
+                          ap_daemons_min_free);
+         }
+         ap_daemons_min_free = 1;
+     }
+ 
+     /* ap_daemons_max_free < ap_daemons_min_free + 1 checked in prefork_run() */
+ 
+     return OK;
+ }
+ 
  static void prefork_hooks(apr_pool_t *p)
  {
!     /* Our open_logs hook function must run before the core's, or stderr
       * will be redirected to a file, and the messages won't print to the
       * console.
       */
      static const char *const aszSucc[] = {"core.c", NULL};
  
!     ap_hook_open_logs(prefork_open_logs, NULL, aszSucc, APR_HOOK_REALLY_FIRST);
      /* we need to set the MPM state before other pre-config hooks use MPM query
       * to retrieve it, so register as REALLY_FIRST
       */
      ap_hook_pre_config(prefork_pre_config, NULL, NULL, APR_HOOK_REALLY_FIRST);
+     ap_hook_check_config(prefork_check_config, NULL, NULL, APR_HOOK_MIDDLE);
+     ap_hook_mpm(prefork_run, NULL, NULL, APR_HOOK_MIDDLE);
+     ap_hook_mpm_query(prefork_query, NULL, NULL, APR_HOOK_MIDDLE);
+     ap_hook_mpm_note_child_killed(prefork_note_child_killed, NULL, NULL, APR_HOOK_MIDDLE);
+     ap_hook_mpm_get_name(prefork_get_name, NULL, NULL, APR_HOOK_MIDDLE);
  }
  
  static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy, const char *arg)
*************** static const char *set_min_free_servers(
*** 1388,1403 ****
      }
  
      ap_daemons_min_free = atoi(arg);
-     if (ap_daemons_min_free <= 0) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     "WARNING: detected MinSpareServers set to non-positive.");
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     "Resetting to 1 to avoid almost certain Apache failure.");
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     "Please read the documentation.");
-        ap_daemons_min_free = 1;
-     }
- 
      return NULL;
  }
  
--- 1469,1474 ----
*************** static const char *set_max_clients (cmd_
*** 1420,1486 ****
      }
  
      ap_daemons_limit = atoi(arg);
-     if (ap_daemons_limit > server_limit) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     "WARNING: MaxClients of %d exceeds ServerLimit value "
-                     "of %d servers,", ap_daemons_limit, server_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     " lowering MaxClients to %d.  To increase, please "
-                     "see the ServerLimit", server_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     " directive.");
-        ap_daemons_limit = server_limit;
-     }
-     else if (ap_daemons_limit < 1) {
-         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                      "WARNING: Require MaxClients > 0, setting to 1");
-         ap_daemons_limit = 1;
-     }
      return NULL;
  }
  
  static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg)
  {
-     int tmp_server_limit;
- 
      const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
      if (err != NULL) {
          return err;
      }
  
!     tmp_server_limit = atoi(arg);
!     /* you cannot change ServerLimit across a restart; ignore
!      * any such attempts
!      */
!     if (first_server_limit &&
!         tmp_server_limit != server_limit) {
!         /* how do we log a message?  the error log is a bit bucket at this
!          * point; we'll just have to set a flag so that ap_mpm_run()
!          * logs a warning later
!          */
!         changed_limit_at_restart = 1;
!         return NULL;
!     }
!     server_limit = tmp_server_limit;
! 
!     if (server_limit > MAX_SERVER_LIMIT) {
!        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                     "WARNING: ServerLimit of %d exceeds compile time limit "
!                     "of %d servers,", server_limit, MAX_SERVER_LIMIT);
!        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                     " lowering ServerLimit to %d.", MAX_SERVER_LIMIT);
!        server_limit = MAX_SERVER_LIMIT;
!     }
!     else if (server_limit < 1) {
!         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                      "WARNING: Require ServerLimit > 0, setting to 1");
!         server_limit = 1;
!     }
      return NULL;
  }
  
  static const command_rec prefork_cmds[] = {
- UNIX_DAEMON_COMMANDS,
  LISTEN_COMMANDS,
  AP_INIT_TAKE1("StartServers", set_daemons_to_start, NULL, RSRC_CONF,
                "Number of child processes launched at server startup"),
--- 1491,1511 ----
      }
  
      ap_daemons_limit = atoi(arg);
      return NULL;
  }
  
  static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg)
  {
      const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
      if (err != NULL) {
          return err;
      }
  
!     server_limit = atoi(arg);
      return NULL;
  }
  
  static const command_rec prefork_cmds[] = {
  LISTEN_COMMANDS,
  AP_INIT_TAKE1("StartServers", set_daemons_to_start, NULL, RSRC_CONF,
                "Number of child processes launched at server startup"),
*************** AP_GRACEFUL_SHUTDOWN_TIMEOUT_COMMAND,
*** 1498,1504 ****
  
  module AP_MODULE_DECLARE_DATA mpm_prefork_module = {
      MPM20_MODULE_STUFF,
!     ap_mpm_rewrite_args,        /* hook to run before apache parses args */
      NULL,                       /* create per-directory config structure */
      NULL,                       /* merge per-directory config structures */
      NULL,                       /* create per-server config structure */
--- 1523,1529 ----
  
  module AP_MODULE_DECLARE_DATA mpm_prefork_module = {
      MPM20_MODULE_STUFF,
!     NULL,                       /* hook to run before apache parses args */
      NULL,                       /* create per-directory config structure */
      NULL,                       /* merge per-directory config structures */
      NULL,                       /* create per-server config structure */
Only in /tmp/patch.inc.get2.9J0UCU/server/mpm: simple
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/mpm/worker/fdqueue.c /tmp/patch.inc.get2.9J0UCU/server/mpm/worker/fdqueue.c
*** /tmp/patch.inc.get1.AvnxJA/server/mpm/worker/fdqueue.c	2013-04-28 19:22:12.443306550 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/mpm/worker/fdqueue.c	2013-04-28 19:22:13.559312070 +0200
*************** static apr_status_t queue_info_cleanup(v
*** 43,49 ****
          if (first_pool == NULL) {
              break;
          }
!         if (apr_atomic_casptr((volatile void**)&(qi->recycled_pools), first_pool->next,
                                first_pool) == first_pool) {
              apr_pool_destroy(first_pool->pool);
          }
--- 43,49 ----
          if (first_pool == NULL) {
              break;
          }
!         if (apr_atomic_casptr((void*)&(qi->recycled_pools), first_pool->next,
                                first_pool) == first_pool) {
              apr_pool_destroy(first_pool->pool);
          }
*************** apr_status_t ap_queue_info_set_idle(fd_q
*** 100,106 ****
               */
              struct recycled_pool *next = queue_info->recycled_pools;
              new_recycle->next = next;
!             if (apr_atomic_casptr((volatile void**)&(queue_info->recycled_pools),
                                    new_recycle, next) == next) {
                  break;
              }
--- 100,106 ----
               */
              struct recycled_pool *next = queue_info->recycled_pools;
              new_recycle->next = next;
!             if (apr_atomic_casptr((void*)&(queue_info->recycled_pools),
                                    new_recycle, next) == next) {
                  break;
              }
*************** apr_status_t ap_queue_info_wait_for_idle
*** 209,215 ****
          if (first_pool == NULL) {
              break;
          }
!         if (apr_atomic_casptr((volatile void**)&(queue_info->recycled_pools), first_pool->next,
                                first_pool) == first_pool) {
              *recycled_pool = first_pool->pool;
              break;
--- 209,215 ----
          if (first_pool == NULL) {
              break;
          }
!         if (apr_atomic_casptr((void*)&(queue_info->recycled_pools), first_pool->next,
                                first_pool) == first_pool) {
              *recycled_pool = first_pool->pool;
              break;
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/mpm/worker/mpm_default.h /tmp/patch.inc.get2.9J0UCU/server/mpm/worker/mpm_default.h
*** /tmp/patch.inc.get1.AvnxJA/server/mpm/worker/mpm_default.h	2013-04-28 19:22:12.443306550 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/mpm/worker/mpm_default.h	2013-04-28 19:22:13.559312070 +0200
***************
*** 50,60 ****
  #define DEFAULT_THREADS_PER_CHILD 25
  #endif
  
- /* File used for accept locking, when we use a file */
- #ifndef DEFAULT_LOCKFILE
- #define DEFAULT_LOCKFILE DEFAULT_REL_RUNTIMEDIR "/accept.lock"
- #endif
- 
  /* Where the main/parent process's pid is logged */
  #ifndef DEFAULT_PIDLOG
  #define DEFAULT_PIDLOG DEFAULT_REL_RUNTIMEDIR "/httpd.pid"
--- 50,55 ----
Only in /tmp/patch.inc.get1.AvnxJA/server/mpm/worker: mpm.h
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/mpm/worker/pod.c /tmp/patch.inc.get2.9J0UCU/server/mpm/worker/pod.c
*** /tmp/patch.inc.get1.AvnxJA/server/mpm/worker/pod.c	2013-04-28 19:22:12.443306550 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/mpm/worker/pod.c	2013-04-28 19:22:13.559312070 +0200
***************
*** 14,26 ****
   * limitations under the License.
   */
  
  #include "pod.h"
  
  #if APR_HAVE_UNISTD_H
  #include <unistd.h>
  #endif
  
! AP_DECLARE(apr_status_t) ap_mpm_pod_open(apr_pool_t *p, ap_pod_t **pod)
  {
      apr_status_t rv;
  
--- 14,27 ----
   * limitations under the License.
   */
  
+ #include "apr_portable.h"
  #include "pod.h"
  
  #if APR_HAVE_UNISTD_H
  #include <unistd.h>
  #endif
  
! AP_DECLARE(apr_status_t) ap_worker_pod_open(apr_pool_t *p, ap_worker_pod_t **pod)
  {
      apr_status_t rv;
  
*************** AP_DECLARE(apr_status_t) ap_mpm_pod_open
*** 41,47 ****
      return APR_SUCCESS;
  }
  
! AP_DECLARE(int) ap_mpm_pod_check(ap_pod_t *pod)
  {
      char c;
      apr_os_file_t fd;
--- 42,48 ----
      return APR_SUCCESS;
  }
  
! AP_DECLARE(int) ap_worker_pod_check(ap_worker_pod_t *pod)
  {
      char c;
      apr_os_file_t fd;
*************** AP_DECLARE(int) ap_mpm_pod_check(ap_pod_
*** 63,69 ****
      return AP_NORESTART;
  }
  
! AP_DECLARE(apr_status_t) ap_mpm_pod_close(ap_pod_t *pod)
  {
      apr_status_t rv;
  
--- 64,70 ----
      return AP_NORESTART;
  }
  
! AP_DECLARE(apr_status_t) ap_worker_pod_close(ap_worker_pod_t *pod)
  {
      apr_status_t rv;
  
*************** AP_DECLARE(apr_status_t) ap_mpm_pod_clos
*** 79,85 ****
      return rv;
  }
  
! static apr_status_t pod_signal_internal(ap_pod_t *pod, int graceful)
  {
      apr_status_t rv;
      char char_of_death = graceful ? GRACEFUL_CHAR : RESTART_CHAR;
--- 80,86 ----
      return rv;
  }
  
! static apr_status_t pod_signal_internal(ap_worker_pod_t *pod, int graceful)
  {
      apr_status_t rv;
      char char_of_death = graceful ? GRACEFUL_CHAR : RESTART_CHAR;
*************** static apr_status_t pod_signal_internal(
*** 93,104 ****
      return rv;
  }
  
! AP_DECLARE(apr_status_t) ap_mpm_pod_signal(ap_pod_t *pod, int graceful)
  {
      return pod_signal_internal(pod, graceful);
  }
  
! AP_DECLARE(void) ap_mpm_pod_killpg(ap_pod_t *pod, int num, int graceful)
  {
      int i;
      apr_status_t rv = APR_SUCCESS;
--- 94,105 ----
      return rv;
  }
  
! AP_DECLARE(apr_status_t) ap_worker_pod_signal(ap_worker_pod_t *pod, int graceful)
  {
      return pod_signal_internal(pod, graceful);
  }
  
! AP_DECLARE(void) ap_worker_pod_killpg(ap_worker_pod_t *pod, int num, int graceful)
  {
      int i;
      apr_status_t rv = APR_SUCCESS;
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/mpm/worker/pod.h /tmp/patch.inc.get2.9J0UCU/server/mpm/worker/pod.h
*** /tmp/patch.inc.get1.AvnxJA/server/mpm/worker/pod.h	2013-04-28 19:22:12.443306550 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/mpm/worker/pod.h	2013-04-28 19:22:13.559312070 +0200
***************
*** 31,37 ****
  #include "http_config.h"
  #include "http_log.h"
  #include "http_main.h"
- #include "mpm.h"
  #include "mpm_common.h"
  #include "ap_mpm.h"
  #include "ap_listen.h"
--- 31,36 ----
***************
*** 43,59 ****
  #define AP_RESTART  0
  #define AP_GRACEFUL 1
  
! typedef struct ap_pod_t ap_pod_t;
  
! struct ap_pod_t {
      apr_file_t *pod_in;
      apr_file_t *pod_out;
      apr_pool_t *p;
  };
  
! AP_DECLARE(apr_status_t) ap_mpm_pod_open(apr_pool_t *p, ap_pod_t **pod);
! AP_DECLARE(int) ap_mpm_pod_check(ap_pod_t *pod);
! AP_DECLARE(apr_status_t) ap_mpm_pod_close(ap_pod_t *pod);
! AP_DECLARE(apr_status_t) ap_mpm_pod_signal(ap_pod_t *pod, int graceful);
! AP_DECLARE(void) ap_mpm_pod_killpg(ap_pod_t *pod, int num, int graceful);
  /** @} */
--- 42,58 ----
  #define AP_RESTART  0
  #define AP_GRACEFUL 1
  
! typedef struct ap_worker_pod_t ap_worker_pod_t;
  
! struct ap_worker_pod_t {
      apr_file_t *pod_in;
      apr_file_t *pod_out;
      apr_pool_t *p;
  };
  
! AP_DECLARE(apr_status_t) ap_worker_pod_open(apr_pool_t *p, ap_worker_pod_t **pod);
! AP_DECLARE(int) ap_worker_pod_check(ap_worker_pod_t *pod);
! AP_DECLARE(apr_status_t) ap_worker_pod_close(ap_worker_pod_t *pod);
! AP_DECLARE(apr_status_t) ap_worker_pod_signal(ap_worker_pod_t *pod, int graceful);
! AP_DECLARE(void) ap_worker_pod_killpg(ap_worker_pod_t *pod, int num, int graceful);
  /** @} */
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/mpm/worker/worker.c /tmp/patch.inc.get2.9J0UCU/server/mpm/worker/worker.c
*** /tmp/patch.inc.get1.AvnxJA/server/mpm/worker/worker.c	2013-04-28 19:22:12.443306550 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/mpm/worker/worker.c	2013-04-28 19:22:13.559312070 +0200
***************
*** 50,57 ****
  #error The Worker MPM requires APR threads, but they are unavailable.
  #endif
  
- #define CORE_PRIVATE
- 
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_main.h"
--- 50,55 ----
***************
*** 66,71 ****
--- 64,71 ----
  #include "scoreboard.h"
  #include "fdqueue.h"
  #include "mpm_default.h"
+ #include "util_mutex.h"
+ #include "unixd.h"
  
  #include <signal.h>
  #include <limits.h>             /* for INT_MAX */
***************
*** 114,130 ****
   * Actual definitions of config globals
   */
  
! int ap_threads_per_child = 0;         /* Worker threads per child */
  static int ap_daemons_to_start = 0;
  static int min_spare_threads = 0;
  static int max_spare_threads = 0;
  static int ap_daemons_limit = 0;
! static int server_limit = DEFAULT_SERVER_LIMIT;
! static int first_server_limit = 0;
! static int thread_limit = DEFAULT_THREAD_LIMIT;
! static int first_thread_limit = 0;
! static int changed_limit_at_restart;
! static int had_healthy_child = 0;
  static int dying = 0;
  static int workers_may_exit = 0;
  static int start_thread_may_exit = 0;
--- 114,127 ----
   * Actual definitions of config globals
   */
  
! static int threads_per_child = 0;     /* Worker threads per child */
  static int ap_daemons_to_start = 0;
  static int min_spare_threads = 0;
  static int max_spare_threads = 0;
  static int ap_daemons_limit = 0;
! static int max_clients = 0;
! static int server_limit = 0;
! static int thread_limit = 0;
  static int dying = 0;
  static int workers_may_exit = 0;
  static int start_thread_may_exit = 0;
*************** static fd_queue_t *worker_queue;
*** 136,141 ****
--- 133,152 ----
  static fd_queue_info_t *worker_queue_info;
  static int mpm_state = AP_MPMQ_STARTING;
  static int sick_child_detected;
+ static ap_generation_t volatile my_generation = 0;
+ 
+ /* data retained by worker across load/unload of the module
+  * allocated on first call to pre-config hook; located on
+  * subsequent calls to pre-config hook
+  */
+ typedef struct worker_retained_data {
+     int first_server_limit;
+     int first_thread_limit;
+     int module_loads;
+ } worker_retained_data;
+ static worker_retained_data *retained;
+ 
+ #define MPM_CHILD_PID(i) (ap_scoreboard_image->parent[i].pid)
  
  /* The structure used to pass unique initialization info to each thread */
  typedef struct {
*************** typedef struct {
*** 162,174 ****
   * use this value to optimize routines that have to scan the entire
   * scoreboard.
   */
! int ap_max_daemons_limit = -1;
! 
! static ap_pod_t *pod;
! 
! /* *Non*-shared http_main globals... */
  
! server_rec *ap_server_conf;
  
  /* The worker MPM respects a couple of runtime flags that can aid
   * in debugging. Setting the -DNO_DETACH flag will prevent the root process
--- 173,181 ----
   * use this value to optimize routines that have to scan the entire
   * scoreboard.
   */
! static int max_daemons_limit = -1;
  
! static ap_worker_pod_t *pod;
  
  /* The worker MPM respects a couple of runtime flags that can aid
   * in debugging. Setting the -DNO_DETACH flag will prevent the root process
*************** static apr_socket_t **worker_sockets;
*** 234,240 ****
  static void close_worker_sockets(void)
  {
      int i;
!     for (i = 0; i < ap_threads_per_child; i++) {
          if (worker_sockets[i]) {
              apr_socket_close(worker_sockets[i]);
              worker_sockets[i] = NULL;
--- 241,247 ----
  static void close_worker_sockets(void)
  {
      int i;
!     for (i = 0; i < threads_per_child; i++) {
          if (worker_sockets[i]) {
              apr_socket_close(worker_sockets[i]);
              worker_sockets[i] = NULL;
*************** static void wakeup_listener(void)
*** 253,258 ****
--- 260,269 ----
           */
          return;
      }
+ 
+     /* unblock the listener if it's waiting for a worker */
+     ap_queue_info_term(worker_queue_info); 
+ 
      /*
       * we should just be able to "kill(ap_my_pid, LISTENER_SIGNAL)" on all
       * platforms and wake up the listener thread since it is the only thread
*************** static void signal_threads(int mode)
*** 291,345 ****
      if (mode == ST_UNGRACEFUL) {
          workers_may_exit = 1;
          ap_queue_interrupt_all(worker_queue);
-         ap_queue_info_term(worker_queue_info);
          close_worker_sockets(); /* forcefully kill all current connections */
      }
  }
  
! AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
  {
!     switch(query_code){
          case AP_MPMQ_MAX_DAEMON_USED:
!             *result = ap_max_daemons_limit;
!             return APR_SUCCESS;
          case AP_MPMQ_IS_THREADED:
              *result = AP_MPMQ_STATIC;
!             return APR_SUCCESS;
          case AP_MPMQ_IS_FORKED:
              *result = AP_MPMQ_DYNAMIC;
!             return APR_SUCCESS;
          case AP_MPMQ_HARD_LIMIT_DAEMONS:
              *result = server_limit;
!             return APR_SUCCESS;
          case AP_MPMQ_HARD_LIMIT_THREADS:
              *result = thread_limit;
!             return APR_SUCCESS;
          case AP_MPMQ_MAX_THREADS:
!             *result = ap_threads_per_child;
!             return APR_SUCCESS;
          case AP_MPMQ_MIN_SPARE_DAEMONS:
              *result = 0;
!             return APR_SUCCESS;
          case AP_MPMQ_MIN_SPARE_THREADS:
              *result = min_spare_threads;
!             return APR_SUCCESS;
          case AP_MPMQ_MAX_SPARE_DAEMONS:
              *result = 0;
!             return APR_SUCCESS;
          case AP_MPMQ_MAX_SPARE_THREADS:
              *result = max_spare_threads;
!             return APR_SUCCESS;
          case AP_MPMQ_MAX_REQUESTS_DAEMON:
              *result = ap_max_requests_per_child;
!             return APR_SUCCESS;
          case AP_MPMQ_MAX_DAEMONS:
              *result = ap_daemons_limit;
!             return APR_SUCCESS;
          case AP_MPMQ_MPM_STATE:
              *result = mpm_state;
!             return APR_SUCCESS;
      }
!     return APR_ENOTIMPL;
  }
  
  /* a clean exit from a child with proper cleanup */
--- 302,373 ----
      if (mode == ST_UNGRACEFUL) {
          workers_may_exit = 1;
          ap_queue_interrupt_all(worker_queue);
          close_worker_sockets(); /* forcefully kill all current connections */
      }
  }
  
! static int worker_query(int query_code, int *result, apr_status_t *rv)
  {
!     *rv = APR_SUCCESS;
!     switch (query_code) {
          case AP_MPMQ_MAX_DAEMON_USED:
!             *result = max_daemons_limit;
!             break;
          case AP_MPMQ_IS_THREADED:
              *result = AP_MPMQ_STATIC;
!             break;
          case AP_MPMQ_IS_FORKED:
              *result = AP_MPMQ_DYNAMIC;
!             break;
          case AP_MPMQ_HARD_LIMIT_DAEMONS:
              *result = server_limit;
!             break;
          case AP_MPMQ_HARD_LIMIT_THREADS:
              *result = thread_limit;
!             break;
          case AP_MPMQ_MAX_THREADS:
!             *result = threads_per_child;
!             break;
          case AP_MPMQ_MIN_SPARE_DAEMONS:
              *result = 0;
!             break;
          case AP_MPMQ_MIN_SPARE_THREADS:
              *result = min_spare_threads;
!             break;
          case AP_MPMQ_MAX_SPARE_DAEMONS:
              *result = 0;
!             break;
          case AP_MPMQ_MAX_SPARE_THREADS:
              *result = max_spare_threads;
!             break;
          case AP_MPMQ_MAX_REQUESTS_DAEMON:
              *result = ap_max_requests_per_child;
!             break;
          case AP_MPMQ_MAX_DAEMONS:
              *result = ap_daemons_limit;
!             break;
          case AP_MPMQ_MPM_STATE:
              *result = mpm_state;
!             break;
!         case AP_MPMQ_GENERATION:
!             *result = my_generation;
!             break;
!         default:
!             *rv = APR_ENOTIMPL;
!             break;
      }
!     return OK;
! }
! 
! static apr_status_t worker_note_child_killed(int childnum)
! {
!     ap_scoreboard_image->parent[childnum].pid = 0;
!     return APR_SUCCESS;
! }
! 
! static const char *worker_get_name(void)
! {
!     return "worker";
  }
  
  /* a clean exit from a child with proper cleanup */
*************** static int volatile shutdown_pending;
*** 367,373 ****
  static int volatile restart_pending;
  static int volatile is_graceful;
  static volatile int child_fatal;
- ap_generation_t volatile ap_my_generation;
  
  /*
   * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
--- 395,400 ----
*************** static void set_signals(void)
*** 513,547 ****
   * Here follows a long bunch of generic server bookkeeping stuff...
   */
  
- int ap_graceful_stop_signalled(void)
-     /* XXX this is really a bad confusing obsolete name
-      * maybe it should be ap_mpm_process_exiting?
-      */
- {
-     /* note: for a graceful termination, listener_may_exit will be set before
-      *       workers_may_exit, so check listener_may_exit
-      */
-     return listener_may_exit;
- }
- 
  /*****************************************************************
   * Child process main loop.
   */
  
! static void process_socket(apr_pool_t *p, apr_socket_t *sock, int my_child_num,
                             int my_thread_num, apr_bucket_alloc_t *bucket_alloc)
  {
      conn_rec *current_conn;
      long conn_id = ID_FROM_CHILD_THREAD(my_child_num, my_thread_num);
-     int csd;
      ap_sb_handle_t *sbh;
  
      ap_create_sb_handle(&sbh, p, my_child_num, my_thread_num);
-     apr_os_sock_get(&csd, sock);
  
      current_conn = ap_run_create_connection(p, ap_server_conf, sock,
                                              conn_id, sbh, bucket_alloc);
      if (current_conn) {
          ap_process_connection(current_conn, sock);
          ap_lingering_close(current_conn);
      }
--- 540,563 ----
   * Here follows a long bunch of generic server bookkeeping stuff...
   */
  
  /*****************************************************************
   * Child process main loop.
   */
  
! static void process_socket(apr_thread_t *thd, apr_pool_t *p, apr_socket_t *sock,
!                            int my_child_num,
                             int my_thread_num, apr_bucket_alloc_t *bucket_alloc)
  {
      conn_rec *current_conn;
      long conn_id = ID_FROM_CHILD_THREAD(my_child_num, my_thread_num);
      ap_sb_handle_t *sbh;
  
      ap_create_sb_handle(&sbh, p, my_child_num, my_thread_num);
  
      current_conn = ap_run_create_connection(p, ap_server_conf, sock,
                                              conn_id, sbh, bucket_alloc);
      if (current_conn) {
+         current_conn->current_thread = thd;
          ap_process_connection(current_conn, sock);
          ap_lingering_close(current_conn);
      }
*************** static void check_infinite_requests(void
*** 556,572 ****
          signal_threads(ST_GRACEFUL);
      }
      else {
-         /* wow! if you're executing this code, you may have set a record.
-          * either this child process has served over 2 billion requests, or
-          * you're running a threaded 2.0 on a 16 bit machine.
-          *
-          * I'll buy pizza and beers at Apachecon for the first person to do
-          * the former without cheating (dorking with INT_MAX, or running with
-          * uncommitted performance patches, for example).
-          *
-          * for the latter case, you probably deserve a beer too.   Greg Ames
-          */
- 
          requests_this_child = INT_MAX;      /* keep going */
      }
  }
--- 572,577 ----
*************** static void dummy_signal_handler(int sig
*** 591,597 ****
       */
  }
  
! static void *listener_thread(apr_thread_t *thd, void * dummy)
  {
      proc_info * ti = dummy;
      int process_slot = ti->pid;
--- 596,625 ----
       */
  }
  
! static void accept_mutex_error(char *func, apr_status_t rv, int process_slot)
! {
!     int level = APLOG_EMERG;
! 
!     if (ap_scoreboard_image->parent[process_slot].generation !=
!         ap_scoreboard_image->global->running_generation) {
!         level = APLOG_DEBUG; /* common to get these at restart time */
!     } 
!     else if (requests_this_child == INT_MAX  
!         || ((requests_this_child == ap_max_requests_per_child)
!             && ap_max_requests_per_child)) { 
!         ap_log_error(APLOG_MARK, level, rv, ap_server_conf,
!                      "apr_proc_mutex_%s failed "
!                      "before this child process served any requests.",
!                      func);
!         clean_child_exit(APEXIT_CHILDSICK); 
!     }
!     ap_log_error(APLOG_MARK, level, rv, ap_server_conf,
!                  "apr_proc_mutex_%s failed. Attempting to "
!                  "shutdown process gracefully.", func);
!     signal_threads(ST_GRACEFUL);
! }
! 
! static void * APR_THREAD_FUNC listener_thread(apr_thread_t *thd, void * dummy)
  {
      proc_info * ti = dummy;
      int process_slot = ti->pid;
*************** static void *listener_thread(apr_thread_
*** 606,613 ****
  
      free(ti);
  
!     /* ### check the status */
!     (void) apr_pollset_create(&pollset, num_listensocks, tpool, 0);
  
      for (lr = ap_listeners; lr != NULL; lr = lr->next) {
          apr_pollfd_t pfd = { 0 };
--- 634,647 ----
  
      free(ti);
  
!     rv = apr_pollset_create(&pollset, num_listensocks, tpool, 0);
!     if (rv != APR_SUCCESS) {
!         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
!                      "Couldn't create pollset in thread;"
!                      " check system or user limits");
!         /* let the parent decide how bad this really is */
!         clean_child_exit(APEXIT_CHILDSICK);
!     }
  
      for (lr = ap_listeners; lr != NULL; lr = lr->next) {
          apr_pollfd_t pfd = { 0 };
*************** static void *listener_thread(apr_thread_
*** 617,624 ****
          pfd.reqevents = APR_POLLIN;
          pfd.client_data = lr;
  
!         /* ### check the status */
!         (void) apr_pollset_add(pollset, &pfd);
      }
  
      /* Unblock the signal used to wake this thread up, and set a handler for
--- 651,666 ----
          pfd.reqevents = APR_POLLIN;
          pfd.client_data = lr;
  
!         rv = apr_pollset_add(pollset, &pfd);
!         if (rv != APR_SUCCESS) {
!             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
!                          "Couldn't create add listener to pollset;"
!                          " check system or user limits");
!             /* let the parent decide how bad this really is */
!             clean_child_exit(APEXIT_CHILDSICK);
!         }
! 
!         lr->accept_func = ap_unixd_accept;
      }
  
      /* Unblock the signal used to wake this thread up, and set a handler for
*************** static void *listener_thread(apr_thread_
*** 660,678 ****
  
          if ((rv = SAFE_ACCEPT(apr_proc_mutex_lock(accept_mutex)))
              != APR_SUCCESS) {
-             int level = APLOG_EMERG;
  
!             if (listener_may_exit) {
!                 break;
              }
-             if (ap_scoreboard_image->parent[process_slot].generation !=
-                 ap_scoreboard_image->global->running_generation) {
-                 level = APLOG_DEBUG; /* common to get these at restart time */
-             }
-             ap_log_error(APLOG_MARK, level, rv, ap_server_conf,
-                          "apr_proc_mutex_lock failed. Attempting to shutdown "
-                          "process gracefully.");
-             signal_threads(ST_GRACEFUL);
              break;                    /* skip the lock release */
          }
  
--- 702,711 ----
  
          if ((rv = SAFE_ACCEPT(apr_proc_mutex_lock(accept_mutex)))
              != APR_SUCCESS) {
  
!             if (!listener_may_exit) {
!                 accept_mutex_error("lock", rv, process_slot);
              }
              break;                    /* skip the lock release */
          }
  
*************** static void *listener_thread(apr_thread_
*** 751,769 ****
              }
              if ((rv = SAFE_ACCEPT(apr_proc_mutex_unlock(accept_mutex)))
                  != APR_SUCCESS) {
-                 int level = APLOG_EMERG;
  
                  if (listener_may_exit) {
                      break;
                  }
!                 if (ap_scoreboard_image->parent[process_slot].generation !=
!                     ap_scoreboard_image->global->running_generation) {
!                     level = APLOG_DEBUG; /* common to get these at restart time */
!                 }
!                 ap_log_error(APLOG_MARK, level, rv, ap_server_conf,
!                              "apr_proc_mutex_unlock failed. Attempting to "
!                              "shutdown process gracefully.");
!                 signal_threads(ST_GRACEFUL);
              }
              if (csd != NULL) {
                  rv = ap_queue_push(worker_queue, csd, ptrans);
--- 784,794 ----
              }
              if ((rv = SAFE_ACCEPT(apr_proc_mutex_unlock(accept_mutex)))
                  != APR_SUCCESS) {
  
                  if (listener_may_exit) {
                      break;
                  }
!                 accept_mutex_error("unlock", rv, process_slot);
              }
              if (csd != NULL) {
                  rv = ap_queue_push(worker_queue, csd, ptrans);
*************** static void * APR_THREAD_FUNC worker_thr
*** 832,838 ****
      free(ti);
  
      ap_scoreboard_image->servers[process_slot][thread_slot].pid = ap_my_pid;
!     ap_scoreboard_image->servers[process_slot][thread_slot].generation = ap_my_generation;
      ap_update_child_status_from_indexes(process_slot, thread_slot, SERVER_STARTING, NULL);
  
  #ifdef HAVE_PTHREAD_KILL
--- 857,864 ----
      free(ti);
  
      ap_scoreboard_image->servers[process_slot][thread_slot].pid = ap_my_pid;
!     ap_scoreboard_image->servers[process_slot][thread_slot].tid = apr_os_thread_current();
!     ap_scoreboard_image->servers[process_slot][thread_slot].generation = my_generation;
      ap_update_child_status_from_indexes(process_slot, thread_slot, SERVER_STARTING, NULL);
  
  #ifdef HAVE_PTHREAD_KILL
*************** worker_pop:
*** 892,900 ****
          is_idle = 0;
          worker_sockets[thread_slot] = csd;
          bucket_alloc = apr_bucket_alloc_create(ptrans);
!         process_socket(ptrans, csd, process_slot, thread_slot, bucket_alloc);
          worker_sockets[thread_slot] = NULL;
!         requests_this_child--; /* FIXME: should be synchronized - aaron */
          apr_pool_clear(ptrans);
          last_ptrans = ptrans;
      }
--- 918,926 ----
          is_idle = 0;
          worker_sockets[thread_slot] = csd;
          bucket_alloc = apr_bucket_alloc_create(ptrans);
!         process_socket(thd, ptrans, csd, process_slot, thread_slot, bucket_alloc);
          worker_sockets[thread_slot] = NULL;
!         requests_this_child--; 
          apr_pool_clear(ptrans);
          last_ptrans = ptrans;
      }
*************** static void * APR_THREAD_FUNC start_thre
*** 961,967 ****
      /* We must create the fd queues before we start up the listener
       * and worker threads. */
      worker_queue = apr_pcalloc(pchild, sizeof(*worker_queue));
!     rv = ap_queue_init(worker_queue, ap_threads_per_child, pchild);
      if (rv != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
                       "ap_queue_init() failed");
--- 987,993 ----
      /* We must create the fd queues before we start up the listener
       * and worker threads. */
      worker_queue = apr_pcalloc(pchild, sizeof(*worker_queue));
!     rv = ap_queue_init(worker_queue, threads_per_child, pchild);
      if (rv != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
                       "ap_queue_init() failed");
*************** static void * APR_THREAD_FUNC start_thre
*** 969,988 ****
      }
  
      rv = ap_queue_info_create(&worker_queue_info, pchild,
!                               ap_threads_per_child);
      if (rv != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
                       "ap_queue_info_create() failed");
          clean_child_exit(APEXIT_CHILDFATAL);
      }
  
!     worker_sockets = apr_pcalloc(pchild, ap_threads_per_child
                                          * sizeof(apr_socket_t *));
  
      loops = prev_threads_created = 0;
      while (1) {
!         /* ap_threads_per_child does not include the listener thread */
!         for (i = 0; i < ap_threads_per_child; i++) {
              int status = ap_scoreboard_image->servers[child_num_arg][i].status;
  
              if (status != SERVER_GRACEFUL && status != SERVER_DEAD) {
--- 995,1014 ----
      }
  
      rv = ap_queue_info_create(&worker_queue_info, pchild,
!                               threads_per_child);
      if (rv != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
                       "ap_queue_info_create() failed");
          clean_child_exit(APEXIT_CHILDFATAL);
      }
  
!     worker_sockets = apr_pcalloc(pchild, threads_per_child
                                          * sizeof(apr_socket_t *));
  
      loops = prev_threads_created = 0;
      while (1) {
!         /* threads_per_child does not include the listener thread */
!         for (i = 0; i < threads_per_child; i++) {
              int status = ap_scoreboard_image->servers[child_num_arg][i].status;
  
              if (status != SERVER_GRACEFUL && status != SERVER_DEAD) {
*************** static void * APR_THREAD_FUNC start_thre
*** 1020,1026 ****
              create_listener_thread(ts);
              listener_started = 1;
          }
!         if (start_thread_may_exit || threads_created == ap_threads_per_child) {
              break;
          }
          /* wait for previous generation to clean up an entry */
--- 1046,1052 ----
              create_listener_thread(ts);
              listener_started = 1;
          }
!         if (start_thread_may_exit || threads_created == threads_per_child) {
              break;
          }
          /* wait for previous generation to clean up an entry */
*************** static void * APR_THREAD_FUNC start_thre
*** 1031,1037 ****
                  ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
                               "child %" APR_PID_T_FMT " isn't taking over "
                               "slots very quickly (%d of %d)",
!                              ap_my_pid, threads_created, ap_threads_per_child);
              }
              prev_threads_created = threads_created;
          }
--- 1057,1063 ----
                  ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
                               "child %" APR_PID_T_FMT " isn't taking over "
                               "slots very quickly (%d of %d)",
!                              ap_my_pid, threads_created, threads_per_child);
              }
              prev_threads_created = threads_created;
          }
*************** static void join_workers(apr_thread_t *l
*** 1093,1099 ****
          }
      }
  
!     for (i = 0; i < ap_threads_per_child; i++) {
          if (threads[i]) { /* if we ever created this thread */
  #ifdef HAVE_PTHREAD_KILL
              apr_os_thread_t *worker_os_thread;
--- 1119,1125 ----
          }
      }
  
!     for (i = 0; i < threads_per_child; i++) {
          if (threads[i]) { /* if we ever created this thread */
  #ifdef HAVE_PTHREAD_KILL
              apr_os_thread_t *worker_os_thread;
*************** static void child_main(int child_num_arg
*** 1147,1153 ****
      /*stuff to do before we switch id's, so we have permissions.*/
      ap_reopen_scoreboard(pchild, NULL, 0);
  
!     rv = SAFE_ACCEPT(apr_proc_mutex_child_init(&accept_mutex, ap_lock_fname,
                                                 pchild));
      if (rv != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
--- 1173,1180 ----
      /*stuff to do before we switch id's, so we have permissions.*/
      ap_reopen_scoreboard(pchild, NULL, 0);
  
!     rv = SAFE_ACCEPT(apr_proc_mutex_child_init(&accept_mutex,
!                                                apr_proc_mutex_lockfile(accept_mutex),
                                                 pchild));
      if (rv != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
*************** static void child_main(int child_num_arg
*** 1155,1161 ****
          clean_child_exit(APEXIT_CHILDFATAL);
      }
  
!     if (unixd_setup_child()) {
          clean_child_exit(APEXIT_CHILDFATAL);
      }
  
--- 1182,1188 ----
          clean_child_exit(APEXIT_CHILDFATAL);
      }
  
!     if (ap_run_drop_privileges(pchild, ap_server_conf)) {
          clean_child_exit(APEXIT_CHILDFATAL);
      }
  
*************** static void child_main(int child_num_arg
*** 1188,1194 ****
       * and we want a 0 entry to indicate a thread which was not created
       */
      threads = (apr_thread_t **)calloc(1,
!                                 sizeof(apr_thread_t *) * ap_threads_per_child);
      if (threads == NULL) {
          ap_log_error(APLOG_MARK, APLOG_ALERT, errno, ap_server_conf,
                       "malloc: out of memory");
--- 1215,1221 ----
       * and we want a 0 entry to indicate a thread which was not created
       */
      threads = (apr_thread_t **)calloc(1,
!                                 sizeof(apr_thread_t *) * threads_per_child);
      if (threads == NULL) {
          ap_log_error(APLOG_MARK, APLOG_ALERT, errno, ap_server_conf,
                       "malloc: out of memory");
*************** static void child_main(int child_num_arg
*** 1256,1262 ****
          apr_signal(SIGTERM, dummy_signal_handler);
          /* Watch for any messages from the parent over the POD */
          while (1) {
!             rv = ap_mpm_pod_check(pod);
              if (rv == AP_NORESTART) {
                  /* see if termination was triggered while we slept */
                  switch(terminate_mode) {
--- 1283,1289 ----
          apr_signal(SIGTERM, dummy_signal_handler);
          /* Watch for any messages from the parent over the POD */
          while (1) {
!             rv = ap_worker_pod_check(pod);
              if (rv == AP_NORESTART) {
                  /* see if termination was triggered while we slept */
                  switch(terminate_mode) {
*************** static int make_child(server_rec *s, int
*** 1297,1304 ****
  {
      int pid;
  
!     if (slot + 1 > ap_max_daemons_limit) {
!         ap_max_daemons_limit = slot + 1;
      }
  
      if (one_process) {
--- 1324,1331 ----
  {
      int pid;
  
!     if (slot + 1 > max_daemons_limit) {
!         max_daemons_limit = slot + 1;
      }
  
      if (one_process) {
*************** static int make_child(server_rec *s, int
*** 1310,1320 ****
      if ((pid = fork()) == -1) {
          ap_log_error(APLOG_MARK, APLOG_ERR, errno, s,
                       "fork: Unable to fork new process");
! 
!         /* fork didn't succeed. Fix the scoreboard or else
!          * it will say SERVER_STARTING forever and ever
           */
-         ap_update_child_status_from_indexes(slot, 0, SERVER_DEAD, NULL);
  
          /* In case system resources are maxxed out, we don't want
             Apache running away with the CPU trying to fork over and
--- 1337,1348 ----
      if ((pid = fork()) == -1) {
          ap_log_error(APLOG_MARK, APLOG_ERR, errno, s,
                       "fork: Unable to fork new process");
!         /* fork didn't succeed.  There's no need to touch the scoreboard;
!          * if we were trying to replace a failed child process, then
!          * server_main_loop() marked its workers SERVER_DEAD, and if
!          * we were trying to replace a child process that exited normally,
!          * its worker_thread()s left SERVER_DEAD or SERVER_GRACEFUL behind.
           */
  
          /* In case system resources are maxxed out, we don't want
             Apache running away with the CPU trying to fork over and
*************** static void perform_idle_server_maintena
*** 1415,1431 ****
  
      for (i = 0; i < ap_daemons_limit; ++i) {
          /* Initialization to satisfy the compiler. It doesn't know
!          * that ap_threads_per_child is always > 0 */
          int status = SERVER_DEAD;
          int any_dying_threads = 0;
          int any_dead_threads = 0;
          int all_dead_threads = 1;
-         int child_threads_active = 0;
  
!         if (i >= ap_max_daemons_limit && totally_free_length == idle_spawn_rate)
              break;
          ps = &ap_scoreboard_image->parent[i];
!         for (j = 0; j < ap_threads_per_child; j++) {
              ws = &ap_scoreboard_image->servers[i][j];
              status = ws->status;
  
--- 1443,1461 ----
  
      for (i = 0; i < ap_daemons_limit; ++i) {
          /* Initialization to satisfy the compiler. It doesn't know
!          * that threads_per_child is always > 0 */
          int status = SERVER_DEAD;
          int any_dying_threads = 0;
          int any_dead_threads = 0;
          int all_dead_threads = 1;
  
!         if (i >= max_daemons_limit && totally_free_length == idle_spawn_rate)
!             /* short cut if all active processes have been examined and
!              * enough empty scoreboard slots have been found
!              */
              break;
          ps = &ap_scoreboard_image->parent[i];
!         for (j = 0; j < threads_per_child; j++) {
              ws = &ap_scoreboard_image->servers[i][j];
              status = ws->status;
  
*************** static void perform_idle_server_maintena
*** 1447,1461 ****
                                     loop if no pid?  not much else matters */
                  if (status <= SERVER_READY && 
                          !ps->quiescing &&
!                         ps->generation == ap_my_generation) {
                      ++idle_thread_count;
                  }
                  if (status >= SERVER_READY && status < SERVER_GRACEFUL) {
!                     ++child_threads_active;
                  }
              }
          }
-         active_thread_count += child_threads_active;
          if (any_dead_threads && totally_free_length < idle_spawn_rate
                  && free_length < MAX_SPAWN_RATE
                  && (!ps->pid               /* no process in the slot */
--- 1477,1490 ----
                                     loop if no pid?  not much else matters */
                  if (status <= SERVER_READY && 
                          !ps->quiescing &&
!                         ps->generation == my_generation) {
                      ++idle_thread_count;
                  }
                  if (status >= SERVER_READY && status < SERVER_GRACEFUL) {
!                     ++active_thread_count;
                  }
              }
          }
          if (any_dead_threads && totally_free_length < idle_spawn_rate
                  && free_length < MAX_SPAWN_RATE
                  && (!ps->pid               /* no process in the slot */
*************** static void perform_idle_server_maintena
*** 1478,1486 ****
              }
              ++free_length;
          }
-         else if (child_threads_active == ap_threads_per_child) {
-             had_healthy_child = 1;
-         }
          /* XXX if (!ps->quiescing)     is probably more reliable  GLA */
          if (!any_dying_threads) {
              last_non_dead = i;
--- 1507,1512 ----
*************** static void perform_idle_server_maintena
*** 1489,1553 ****
      }
  
      if (sick_child_detected) {
!         if (had_healthy_child) {
!             /* Assume this is a transient error, even though it may not be.  Leave
!              * the server up in case it is able to serve some requests or the
!              * problem will be resolved.
               */
              sick_child_detected = 0;
          }
          else {
!             /* looks like a basket case, as no child ever fully initialized; give up.
               */
              shutdown_pending = 1;
              child_fatal = 1;
              ap_log_error(APLOG_MARK, APLOG_ALERT, 0,
                           ap_server_conf,
!                          "A resource shortage or other unrecoverable failure "
!                          "was encountered before any child process initialized "
!                          "successfully... httpd is exiting!");
              /* the child already logged the failure details */
              return;
          }
      }
  
!     ap_max_daemons_limit = last_non_dead + 1;
  
      if (idle_thread_count > max_spare_threads) {
          /* Kill off one child */
!         ap_mpm_pod_signal(pod, TRUE);
          idle_spawn_rate = 1;
      }
      else if (idle_thread_count < min_spare_threads) {
          /* terminate the free list */
!         if (free_length == 0) {
!             /* No room for more children, might warn about configuration */
!             if (active_thread_count >= ap_daemons_limit * ap_threads_per_child) {
!                 /* no threads are "inactive" - starting, stopping, etc. - which would confuse matters */
!                 /* Are all threads in use?  Then we're really at MaxClients */
!                 if (0 == idle_thread_count) {
!                     /* only report this condition once */
!                     static int reported = 0;
! 
!                     if (!reported) {
!                         ap_log_error(APLOG_MARK, APLOG_ERR, 0,
!                                      ap_server_conf,
!                                      "server reached MaxClients setting, consider"
!                                      " raising the MaxClients setting");
!                         reported = 1;
!                     }
!                 } else {
!                     static int reported = 0;
  
!                     if (!reported) {
!                         ap_log_error(APLOG_MARK, APLOG_ERR, 0,
!                                      ap_server_conf,
!                                      "server is within MinSpareThreads of MaxClients, consider"
!                                      " raising the MaxClients setting");
!                         reported = 1;
!                     }
                  }
              }
              idle_spawn_rate = 1;
          }
          else {
--- 1515,1567 ----
      }
  
      if (sick_child_detected) {
!         if (active_thread_count > 0) {
!             /* some child processes appear to be working.  don't kill the
!              * whole server.
               */
              sick_child_detected = 0;
          }
          else {
!             /* looks like a basket case.  give up.
               */
              shutdown_pending = 1;
              child_fatal = 1;
              ap_log_error(APLOG_MARK, APLOG_ALERT, 0,
                           ap_server_conf,
!                          "No active workers found..."
!                          " Apache is exiting!");
              /* the child already logged the failure details */
              return;
          }
      }
  
!     max_daemons_limit = last_non_dead + 1;
  
      if (idle_thread_count > max_spare_threads) {
          /* Kill off one child */
!         ap_worker_pod_signal(pod, TRUE);
          idle_spawn_rate = 1;
      }
      else if (idle_thread_count < min_spare_threads) {
          /* terminate the free list */
!         if (free_length == 0) { /* scoreboard is full, can't fork */
  
!             if (active_thread_count >= ap_daemons_limit * threads_per_child) { 
!                 static int reported = 0;
!                 if (!reported) {
!                     /* only report this condition once */
!                     ap_log_error(APLOG_MARK, APLOG_ERR, 0,
!                                  ap_server_conf,
!                                  "server reached MaxClients setting, consider"
!                                  " raising the MaxClients setting");
!                     reported = 1;
                  }
              }
+             else {
+                 ap_log_error(APLOG_MARK, APLOG_ERR, 0,
+                              ap_server_conf,
+                              "scoreboard is full, not at MaxClients");
+             }
              idle_spawn_rate = 1;
          }
          else {
*************** static void server_main_loop(int remaini
*** 1592,1598 ****
      int i;
  
      while (!restart_pending && !shutdown_pending) {
!         ap_wait_or_timeout(&exitwhy, &status, &pid, pconf);
  
          if (pid.pid != -1) {
              processed_status = ap_process_child_status(&pid, exitwhy, status);
--- 1606,1612 ----
      int i;
  
      while (!restart_pending && !shutdown_pending) {
!         ap_wait_or_timeout(&exitwhy, &status, &pid, pconf, ap_server_conf);
  
          if (pid.pid != -1) {
              processed_status = ap_process_child_status(&pid, exitwhy, status);
*************** static void server_main_loop(int remaini
*** 1608,1616 ****
                  sick_child_detected = 1;
              }
              /* non-fatal death... note that it's gone in the scoreboard. */
!             child_slot = find_child_by_pid(&pid);
              if (child_slot >= 0) {
!                 for (i = 0; i < ap_threads_per_child; i++)
                      ap_update_child_status_from_indexes(child_slot, i, SERVER_DEAD,
                                                          (request_rec *) NULL);
  
--- 1622,1630 ----
                  sick_child_detected = 1;
              }
              /* non-fatal death... note that it's gone in the scoreboard. */
!             child_slot = ap_find_child_by_pid(&pid);
              if (child_slot >= 0) {
!                 for (i = 0; i < threads_per_child; i++)
                      ap_update_child_status_from_indexes(child_slot, i, SERVER_DEAD,
                                                          (request_rec *) NULL);
  
*************** static void server_main_loop(int remaini
*** 1631,1645 ****
              }
              else if (ap_unregister_extra_mpm_process(pid.pid) == 1) {
                  /* handled */
-                 if (processed_status == APEXIT_CHILDSICK) {
-                     /* resource shortage, minimize the fork rate */
-                     /* 2.2.x note: Unlike 2.4+, there's no way to verify that 
-                      * this child was part of the current generation, so we 
-                      * can't leave the spawn rate alone for sick children of
-                      * previous generations.
-                      */
-                     idle_spawn_rate = 1;
-                 }
  #if APR_HAS_OTHER_CHILD
              }
              else if (apr_proc_other_child_alert(&pid, APR_OC_REASON_DEATH,
--- 1645,1650 ----
*************** static void server_main_loop(int remaini
*** 1681,1754 ****
      }
  }
  
! int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
  {
      int remaining_children_to_start;
      apr_status_t rv;
  
      ap_log_pid(pconf, ap_pid_fname);
  
-     first_server_limit = server_limit;
-     first_thread_limit = thread_limit;
-     if (changed_limit_at_restart) {
-         ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
-                      "WARNING: Attempt to change ServerLimit or ThreadLimit "
-                      "ignored during restart");
-         changed_limit_at_restart = 0;
-     }
- 
      /* Initialize cross-process accept lock */
!     ap_lock_fname = apr_psprintf(_pconf, "%s.%" APR_PID_T_FMT,
!                                  ap_server_root_relative(_pconf, ap_lock_fname),
!                                  ap_my_pid);
! 
!     rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname,
!                                ap_accept_lock_mech, _pconf);
      if (rv != APR_SUCCESS) {
-         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
-                      "Couldn't create accept lock");
          mpm_state = AP_MPMQ_STOPPING;
!         return 1;
!     }
! 
! #if APR_USE_SYSVSEM_SERIALIZE
!     if (ap_accept_lock_mech == APR_LOCK_DEFAULT ||
!         ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
! #else
!     if (ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
! #endif
!         rv = unixd_set_proc_mutex_perms(accept_mutex);
!         if (rv != APR_SUCCESS) {
!             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
!                          "Couldn't set permissions on cross-process lock; "
!                          "check User and Group directives");
!             mpm_state = AP_MPMQ_STOPPING;
!             return 1;
!         }
      }
  
      if (!is_graceful) {
          if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) {
              mpm_state = AP_MPMQ_STOPPING;
!             return 1;
          }
          /* fix the generation number in the global score; we just got a new,
           * cleared scoreboard
           */
!         ap_scoreboard_image->global->running_generation = ap_my_generation;
      }
  
      set_signals();
      /* Don't thrash... */
!     if (max_spare_threads < min_spare_threads + ap_threads_per_child)
!         max_spare_threads = min_spare_threads + ap_threads_per_child;
  
      /* If we're doing a graceful_restart then we're going to see a lot
       * of children exiting immediately when we get into the main loop
       * below (because we just sent them AP_SIG_GRACEFUL).  This happens pretty
!      * rapidly... and for each one that exits we'll start a new one until
!      * we reach at least daemons_min_free.  But we may be permitted to
!      * start more than that, so we'll just keep track of how many we're
       * supposed to start up without the 1 second penalty between each fork.
       */
      remaining_children_to_start = ap_daemons_to_start;
--- 1686,1729 ----
      }
  }
  
! static int worker_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
  {
      int remaining_children_to_start;
      apr_status_t rv;
  
      ap_log_pid(pconf, ap_pid_fname);
  
      /* Initialize cross-process accept lock */
!     rv = ap_proc_mutex_create(&accept_mutex, ap_accept_mutex_type, NULL, s,
!                               _pconf, 0);
      if (rv != APR_SUCCESS) {
          mpm_state = AP_MPMQ_STOPPING;
!         return DONE;
      }
  
      if (!is_graceful) {
          if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) {
              mpm_state = AP_MPMQ_STOPPING;
!             return DONE;
          }
          /* fix the generation number in the global score; we just got a new,
           * cleared scoreboard
           */
!         ap_scoreboard_image->global->running_generation = my_generation;
      }
  
      set_signals();
      /* Don't thrash... */
!     if (max_spare_threads < min_spare_threads + threads_per_child)
!         max_spare_threads = min_spare_threads + threads_per_child;
  
      /* If we're doing a graceful_restart then we're going to see a lot
       * of children exiting immediately when we get into the main loop
       * below (because we just sent them AP_SIG_GRACEFUL).  This happens pretty
!      * rapidly... and for each one that exits we may start a new one, until
!      * there are at least min_spare_threads idle threads, counting across
!      * all children.  But we may be permitted to start more children than
!      * that, so we'll just keep track of how many we're
       * supposed to start up without the 1 second penalty between each fork.
       */
      remaining_children_to_start = ap_daemons_to_start;
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1770,1781 ****
                  ap_get_server_description());
      ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
                  "Server built: %s", ap_get_server_built());
- #ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
      ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
!                 "AcceptMutex: %s (default: %s)",
                  apr_proc_mutex_name(accept_mutex),
                  apr_proc_mutex_defname());
- #endif
      restart_pending = shutdown_pending = 0;
      mpm_state = AP_MPMQ_RUNNING;
  
--- 1745,1754 ----
                  ap_get_server_description());
      ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
                  "Server built: %s", ap_get_server_built());
      ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
!                 "Accept mutex: %s (default: %s)",
                  apr_proc_mutex_name(accept_mutex),
                  apr_proc_mutex_defname());
      restart_pending = shutdown_pending = 0;
      mpm_state = AP_MPMQ_RUNNING;
  
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1786,1792 ****
          /* Time to shut down:
           * Kill child processes, tell them to call child_exit, etc...
           */
!         ap_mpm_pod_killpg(pod, ap_daemons_limit, FALSE);
          ap_reclaim_child_processes(1);                /* Start with SIGTERM */
  
          if (!child_fatal) {
--- 1759,1765 ----
          /* Time to shut down:
           * Kill child processes, tell them to call child_exit, etc...
           */
!         ap_worker_pod_killpg(pod, ap_daemons_limit, FALSE);
          ap_reclaim_child_processes(1);                /* Start with SIGTERM */
  
          if (!child_fatal) {
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1802,1808 ****
              ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
                           ap_server_conf, "caught SIGTERM, shutting down");
          }
!         return 1;
      } else if (shutdown_pending) {
          /* Time to gracefully shut down:
           * Kill child processes, tell them to call child_exit, etc...
--- 1775,1781 ----
              ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
                           ap_server_conf, "caught SIGTERM, shutting down");
          }
!         return DONE;
      } else if (shutdown_pending) {
          /* Time to gracefully shut down:
           * Kill child processes, tell them to call child_exit, etc...
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1813,1819 ****
  
          /* Close our listeners, and then ask our children to do same */
          ap_close_listeners();
!         ap_mpm_pod_killpg(pod, ap_daemons_limit, TRUE);
          ap_relieve_child_processes();
  
          if (!child_fatal) {
--- 1786,1792 ----
  
          /* Close our listeners, and then ask our children to do same */
          ap_close_listeners();
!         ap_worker_pod_killpg(pod, ap_daemons_limit, TRUE);
          ap_relieve_child_processes();
  
          if (!child_fatal) {
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1860,1869 ****
           * way, try and make sure that all of our processes are
           * really dead.
           */
!         ap_mpm_pod_killpg(pod, ap_daemons_limit, FALSE);
          ap_reclaim_child_processes(1);
  
!         return 1;
      }
  
      /* we've been told to restart */
--- 1833,1842 ----
           * way, try and make sure that all of our processes are
           * really dead.
           */
!         ap_worker_pod_killpg(pod, ap_daemons_limit, FALSE);
          ap_reclaim_child_processes(1);
  
!         return DONE;
      }
  
      /* we've been told to restart */
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1871,1891 ****
  
      if (one_process) {
          /* not worth thinking about */
!         return 1;
      }
  
      /* advance to the next generation */
      /* XXX: we really need to make sure this new generation number isn't in
       * use by any of the children.
       */
!     ++ap_my_generation;
!     ap_scoreboard_image->global->running_generation = ap_my_generation;
  
      if (is_graceful) {
          ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                       AP_SIG_GRACEFUL_STRING " received.  Doing graceful restart");
          /* wake up the children...time to die.  But we'll have more soon */
!         ap_mpm_pod_killpg(pod, ap_daemons_limit, TRUE);
  
  
          /* This is mostly for debugging... so that we know what is still
--- 1844,1864 ----
  
      if (one_process) {
          /* not worth thinking about */
!         return DONE;
      }
  
      /* advance to the next generation */
      /* XXX: we really need to make sure this new generation number isn't in
       * use by any of the children.
       */
!     ++my_generation;
!     ap_scoreboard_image->global->running_generation = my_generation;
  
      if (is_graceful) {
          ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                       AP_SIG_GRACEFUL_STRING " received.  Doing graceful restart");
          /* wake up the children...time to die.  But we'll have more soon */
!         ap_worker_pod_killpg(pod, ap_daemons_limit, TRUE);
  
  
          /* This is mostly for debugging... so that we know what is still
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1898,1911 ****
           * and a SIGHUP, we may as well use the same signal, because some user
           * pthreads are stealing signals from us left and right.
           */
!         ap_mpm_pod_killpg(pod, ap_daemons_limit, FALSE);
  
          ap_reclaim_child_processes(1);                /* Start with SIGTERM */
          ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                      "SIGHUP received.  Attempting to restart");
      }
  
!     return 0;
  }
  
  /* This really should be a post_config hook, but the error log is already
--- 1871,1884 ----
           * and a SIGHUP, we may as well use the same signal, because some user
           * pthreads are stealing signals from us left and right.
           */
!         ap_worker_pod_killpg(pod, ap_daemons_limit, FALSE);
  
          ap_reclaim_child_processes(1);                /* Start with SIGTERM */
          ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                      "SIGHUP received.  Attempting to restart");
      }
  
!     return OK;
  }
  
  /* This really should be a post_config hook, but the error log is already
*************** int ap_mpm_run(apr_pool_t *_pconf, apr_p
*** 1913,1933 ****
   */
  static int worker_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
  {
      apr_status_t rv;
  
      pconf = p;
!     ap_server_conf = s;
  
      if ((num_listensocks = ap_setup_listeners(ap_server_conf)) < 1) {
!         ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0,
!                      NULL, "no listening sockets available, shutting down");
          return DONE;
      }
  
      if (!one_process) {
!         if ((rv = ap_mpm_pod_open(pconf, &pod))) {
!             ap_log_error(APLOG_MARK, APLOG_CRIT|APLOG_STARTUP, rv, NULL,
!                     "Could not open pipe-of-death.");
              return DONE;
          }
      }
--- 1886,1915 ----
   */
  static int worker_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
  {
+     int startup = 0;
+     int level_flags = 0;
      apr_status_t rv;
  
      pconf = p;
! 
!     /* the reverse of pre_config, we want this only the first time around */
!     if (retained->module_loads == 1) {
!         startup = 1;
!         level_flags |= APLOG_STARTUP;
!     }
  
      if ((num_listensocks = ap_setup_listeners(ap_server_conf)) < 1) {
!         ap_log_error(APLOG_MARK, APLOG_ALERT | level_flags, 0,
!                      (startup ? NULL : s),
!                      "no listening sockets available, shutting down");
          return DONE;
      }
  
      if (!one_process) {
!         if ((rv = ap_worker_pod_open(pconf, &pod))) {
!             ap_log_error(APLOG_MARK, APLOG_CRIT | level_flags, rv,
!                          (startup ? NULL : s),
!                          "could not open pipe-of-death");
              return DONE;
          }
      }
*************** static int worker_open_logs(apr_pool_t *
*** 1937,1986 ****
  static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                               apr_pool_t *ptemp)
  {
-     static int restart_num = 0;
      int no_detach, debug, foreground;
-     ap_directive_t *pdir;
-     ap_directive_t *max_clients = NULL;
      apr_status_t rv;
  
      mpm_state = AP_MPMQ_STARTING;
  
-     /* make sure that "ThreadsPerChild" gets set before "MaxClients" */
-     for (pdir = ap_conftree; pdir != NULL; pdir = pdir->next) {
-         if (strncasecmp(pdir->directive, "ThreadsPerChild", 15) == 0) {
-             if (!max_clients) {
-                 break; /* we're in the clear, got ThreadsPerChild first */
-             }
-             else {
-                 /* now to swap the data */
-                 ap_directive_t temp;
- 
-                 temp.directive = pdir->directive;
-                 temp.args = pdir->args;
-                 /* Make sure you don't change 'next', or you may get loops! */
-                 /* XXX: first_child, parent, and data can never be set
-                  * for these directives, right? -aaron */
-                 temp.filename = pdir->filename;
-                 temp.line_num = pdir->line_num;
- 
-                 pdir->directive = max_clients->directive;
-                 pdir->args = max_clients->args;
-                 pdir->filename = max_clients->filename;
-                 pdir->line_num = max_clients->line_num;
- 
-                 max_clients->directive = temp.directive;
-                 max_clients->args = temp.args;
-                 max_clients->filename = temp.filename;
-                 max_clients->line_num = temp.line_num;
-                 break;
-             }
-         }
-         else if (!max_clients
-                  && strncasecmp(pdir->directive, "MaxClients", 10) == 0) {
-             max_clients = pdir;
-         }
-     }
- 
      debug = ap_exists_config_define("DEBUG");
  
      if (debug) {
--- 1919,1930 ----
  static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                               apr_pool_t *ptemp)
  {
      int no_detach, debug, foreground;
      apr_status_t rv;
+     const char *userdata_key = "mpm_worker_module";
  
      mpm_state = AP_MPMQ_STARTING;
  
      debug = ap_exists_config_define("DEBUG");
  
      if (debug) {
*************** static int worker_pre_config(apr_pool_t
*** 1993,2000 ****
          foreground = ap_exists_config_define("FOREGROUND");
      }
  
      /* sigh, want this only the second time around */
!     if (restart_num++ == 1) {
          is_graceful = 0;
  
          if (!one_process && !foreground) {
--- 1937,1951 ----
          foreground = ap_exists_config_define("FOREGROUND");
      }
  
+     ap_mutex_register(pconf, ap_accept_mutex_type, NULL, APR_LOCK_DEFAULT, 0);
+ 
      /* sigh, want this only the second time around */
!     retained = ap_retained_data_get(userdata_key);
!     if (!retained) {
!         retained = ap_retained_data_create(userdata_key, sizeof(*retained));
!     }
!     ++retained->module_loads;
!     if (retained->module_loads == 2) {
          is_graceful = 0;
  
          if (!one_process && !foreground) {
*************** static int worker_pre_config(apr_pool_t
*** 2009,2049 ****
          parent_pid = ap_my_pid = getpid();
      }
  
-     unixd_pre_config(ptemp);
      ap_listen_pre_config();
      ap_daemons_to_start = DEFAULT_START_DAEMON;
      min_spare_threads = DEFAULT_MIN_FREE_DAEMON * DEFAULT_THREADS_PER_CHILD;
      max_spare_threads = DEFAULT_MAX_FREE_DAEMON * DEFAULT_THREADS_PER_CHILD;
      ap_daemons_limit = server_limit;
!     ap_threads_per_child = DEFAULT_THREADS_PER_CHILD;
      ap_pid_fname = DEFAULT_PIDLOG;
-     ap_lock_fname = DEFAULT_LOCKFILE;
      ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
-     had_healthy_child = 0;
      ap_extended_status = 0;
! #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
!         ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
! #endif
  
      apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
  
      return OK;
  }
  
  static void worker_hooks(apr_pool_t *p)
  {
!     /* The worker open_logs phase must run before the core's, or stderr
       * will be redirected to a file, and the messages won't print to the
       * console.
       */
      static const char *const aszSucc[] = {"core.c", NULL};
      one_process = 0;
  
!     ap_hook_open_logs(worker_open_logs, NULL, aszSucc, APR_HOOK_MIDDLE);
      /* we need to set the MPM state before other pre-config hooks use MPM query
       * to retrieve it, so register as REALLY_FIRST
       */
      ap_hook_pre_config(worker_pre_config, NULL, NULL, APR_HOOK_REALLY_FIRST);
  }
  
  static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy,
--- 1960,2239 ----
          parent_pid = ap_my_pid = getpid();
      }
  
      ap_listen_pre_config();
      ap_daemons_to_start = DEFAULT_START_DAEMON;
      min_spare_threads = DEFAULT_MIN_FREE_DAEMON * DEFAULT_THREADS_PER_CHILD;
      max_spare_threads = DEFAULT_MAX_FREE_DAEMON * DEFAULT_THREADS_PER_CHILD;
+     server_limit = DEFAULT_SERVER_LIMIT;
+     thread_limit = DEFAULT_THREAD_LIMIT;
      ap_daemons_limit = server_limit;
!     threads_per_child = DEFAULT_THREADS_PER_CHILD;
!     max_clients = ap_daemons_limit * threads_per_child;
      ap_pid_fname = DEFAULT_PIDLOG;
      ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
      ap_extended_status = 0;
!     ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
  
      apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
  
      return OK;
  }
  
+ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
+                                apr_pool_t *ptemp, server_rec *s)
+ {
+     static int restart_num = 0;
+     int startup = 0;
+ 
+     /* the reverse of pre_config, we want this only the first time around */
+     if (restart_num++ == 0) {
+         startup = 1;
+     }
+ 
+     if (server_limit > MAX_SERVER_LIMIT) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: ServerLimit of %d exceeds compile-time "
+                          "limit of", server_limit);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " %d servers, decreasing to %d.",
+                          MAX_SERVER_LIMIT, MAX_SERVER_LIMIT);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "ServerLimit of %d exceeds compile-time limit "
+                          "of %d, decreasing to match",
+                          server_limit, MAX_SERVER_LIMIT);
+         }
+         server_limit = MAX_SERVER_LIMIT;
+     }
+     else if (server_limit < 1) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: ServerLimit of %d not allowed, "
+                          "increasing to 1.", server_limit);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "ServerLimit of %d not allowed, increasing to 1",
+                          server_limit);
+         }
+         server_limit = 1;
+     }
+ 
+     /* you cannot change ServerLimit across a restart; ignore
+      * any such attempts
+      */
+     if (!retained->first_server_limit) {
+         retained->first_server_limit = server_limit;
+     }
+     else if (server_limit != retained->first_server_limit) {
+         /* don't need a startup console version here */
+         ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                      "changing ServerLimit to %d from original value of %d "
+                      "not allowed during restart",
+                      server_limit, retained->first_server_limit);
+         server_limit = retained->first_server_limit;
+     }
+ 
+     if (thread_limit > MAX_THREAD_LIMIT) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: ThreadLimit of %d exceeds compile-time "
+                          "limit of", thread_limit);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " %d threads, decreasing to %d.",
+                          MAX_THREAD_LIMIT, MAX_THREAD_LIMIT);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "ThreadLimit of %d exceeds compile-time limit "
+                          "of %d, decreasing to match",
+                          thread_limit, MAX_THREAD_LIMIT);
+         }
+         thread_limit = MAX_THREAD_LIMIT;
+     }
+     else if (thread_limit < 1) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: ThreadLimit of %d not allowed, "
+                          "increasing to 1.", thread_limit);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "ThreadLimit of %d not allowed, increasing to 1",
+                          thread_limit);
+         }
+         thread_limit = 1;
+     }
+ 
+     /* you cannot change ThreadLimit across a restart; ignore
+      * any such attempts
+      */
+     if (!retained->first_thread_limit) {
+         retained->first_thread_limit = thread_limit;
+     }
+     else if (thread_limit != retained->first_thread_limit) {
+         /* don't need a startup console version here */
+         ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                      "changing ThreadLimit to %d from original value of %d "
+                      "not allowed during restart",
+                      thread_limit, retained->first_thread_limit);
+         thread_limit = retained->first_thread_limit;
+     }
+ 
+     if (threads_per_child > thread_limit) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
+                          "of", threads_per_child);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " %d threads, decreasing to %d.",
+                          thread_limit, thread_limit);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " To increase, please see the ThreadLimit "
+                          "directive.");
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "ThreadsPerChild of %d exceeds ThreadLimit "
+                          "of %d, decreasing to match",
+                          threads_per_child, thread_limit);
+         }
+         threads_per_child = thread_limit;
+     }
+     else if (threads_per_child < 1) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: ThreadsPerChild of %d not allowed, "
+                          "increasing to 1.", threads_per_child);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "ThreadsPerChild of %d not allowed, increasing to 1",
+                          threads_per_child);
+         }
+         threads_per_child = 1;
+     }
+ 
+     if (max_clients < threads_per_child) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: MaxClients of %d is less than "
+                          "ThreadsPerChild of", max_clients);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " %d, increasing to %d.  MaxClients must be at "
+                          "least as large",
+                          threads_per_child, threads_per_child);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " as the number of threads in a single server.");
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "MaxClients of %d is less than ThreadsPerChild "
+                          "of %d, increasing to match",
+                          max_clients, threads_per_child);
+         }
+         max_clients = threads_per_child;
+     }
+ 
+     ap_daemons_limit = max_clients / threads_per_child;
+ 
+     if (max_clients % threads_per_child) {
+         int tmp_max_clients = ap_daemons_limit * threads_per_child;
+ 
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: MaxClients of %d is not an integer "
+                          "multiple of", max_clients);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " ThreadsPerChild of %d, decreasing to nearest "
+                          "multiple %d,", threads_per_child,
+                          tmp_max_clients);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " for a maximum of %d servers.",
+                          ap_daemons_limit);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "MaxClients of %d is not an integer multiple of "
+                          "ThreadsPerChild of %d, decreasing to nearest "
+                          "multiple %d", max_clients, threads_per_child,
+                          tmp_max_clients);
+         }
+         max_clients = tmp_max_clients;
+     }
+ 
+     if (ap_daemons_limit > server_limit) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: MaxClients of %d would require %d "
+                          "servers and ", max_clients, ap_daemons_limit);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " would exceed ServerLimit of %d, decreasing to %d.",
+                          server_limit, server_limit * threads_per_child);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " To increase, please see the ServerLimit "
+                          "directive.");
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "MaxClients of %d would require %d servers and "
+                          "exceed ServerLimit of %d, decreasing to %d",
+                          max_clients, ap_daemons_limit, server_limit,
+                          server_limit * threads_per_child);
+         }
+         ap_daemons_limit = server_limit;
+     }
+ 
+     /* ap_daemons_to_start > ap_daemons_limit checked in worker_run() */
+     if (ap_daemons_to_start < 0) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: StartServers of %d not allowed, "
+                          "increasing to 1.", ap_daemons_to_start);
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "StartServers of %d not allowed, increasing to 1",
+                          ap_daemons_to_start);
+         }
+         ap_daemons_to_start = 1;
+     }
+ 
+     if (min_spare_threads < 1) {
+         if (startup) {
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          "WARNING: MinSpareThreads of %d not allowed, "
+                          "increasing to 1", min_spare_threads);
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " to avoid almost certain server failure.");
+             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+                          " Please read the documentation.");
+         } else {
+             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                          "MinSpareThreads of %d not allowed, increasing to 1",
+                          min_spare_threads);
+         }
+         min_spare_threads = 1;
+     }
+ 
+     /* max_spare_threads < min_spare_threads + threads_per_child
+      * checked in worker_run()
+      */
+ 
+     return OK;
+ }
+ 
  static void worker_hooks(apr_pool_t *p)
  {
!     /* Our open_logs hook function must run before the core's, or stderr
       * will be redirected to a file, and the messages won't print to the
       * console.
       */
      static const char *const aszSucc[] = {"core.c", NULL};
      one_process = 0;
  
!     ap_hook_open_logs(worker_open_logs, NULL, aszSucc, APR_HOOK_REALLY_FIRST);
      /* we need to set the MPM state before other pre-config hooks use MPM query
       * to retrieve it, so register as REALLY_FIRST
       */
      ap_hook_pre_config(worker_pre_config, NULL, NULL, APR_HOOK_REALLY_FIRST);
+     ap_hook_check_config(worker_check_config, NULL, NULL, APR_HOOK_MIDDLE);
+     ap_hook_mpm(worker_run, NULL, NULL, APR_HOOK_MIDDLE);
+     ap_hook_mpm_query(worker_query, NULL, NULL, APR_HOOK_MIDDLE);
+     ap_hook_mpm_note_child_killed(worker_note_child_killed, NULL, NULL, APR_HOOK_MIDDLE);
+     ap_hook_mpm_get_name(worker_get_name, NULL, NULL, APR_HOOK_MIDDLE);
  }
  
  static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy,
*************** static const char *set_min_spare_threads
*** 2067,2082 ****
      }
  
      min_spare_threads = atoi(arg);
-     if (min_spare_threads <= 0) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     "WARNING: detected MinSpareThreads set to non-positive.");
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     "Resetting to 1 to avoid almost certain Apache failure.");
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     "Please read the documentation.");
-        min_spare_threads = 1;
-     }
- 
      return NULL;
  }
  
--- 2257,2262 ----
*************** static const char *set_max_spare_threads
*** 2095,2154 ****
  static const char *set_max_clients (cmd_parms *cmd, void *dummy,
                                       const char *arg)
  {
-     int max_clients;
      const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
      if (err != NULL) {
          return err;
      }
  
-     /* It is ok to use ap_threads_per_child here because we are
-      * sure that it gets set before MaxClients in the pre_config stage. */
      max_clients = atoi(arg);
-     if (max_clients < ap_threads_per_child) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     "WARNING: MaxClients (%d) must be at least as large",
-                     max_clients);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     " as ThreadsPerChild (%d). Automatically",
-                     ap_threads_per_child);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     " increasing MaxClients to %d.",
-                     ap_threads_per_child);
-        max_clients = ap_threads_per_child;
-     }
-     ap_daemons_limit = max_clients / ap_threads_per_child;
-     if ((max_clients > 0) && (max_clients % ap_threads_per_child)) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     "WARNING: MaxClients (%d) is not an integer multiple",
-                     max_clients);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     " of ThreadsPerChild (%d), lowering MaxClients to %d",
-                     ap_threads_per_child,
-                     ap_daemons_limit * ap_threads_per_child);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     " for a maximum of %d child processes,",
-                     ap_daemons_limit);
-        max_clients = ap_daemons_limit * ap_threads_per_child;
-     }
-     if (ap_daemons_limit > server_limit) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     "WARNING: MaxClients of %d would require %d servers,",
-                     max_clients, ap_daemons_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     " and would exceed the ServerLimit value of %d.",
-                     server_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     " Automatically lowering MaxClients to %d.  To increase,",
-                     server_limit * ap_threads_per_child);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                     " please see the ServerLimit directive.");
-        ap_daemons_limit = server_limit;
-     }
-     else if (ap_daemons_limit < 1) {
-         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                      "WARNING: Require MaxClients > 0, setting to 1");
-         ap_daemons_limit = 1;
-     }
      return NULL;
  }
  
--- 2275,2286 ----
*************** static const char *set_threads_per_child
*** 2160,2268 ****
          return err;
      }
  
!     ap_threads_per_child = atoi(arg);
!     if (ap_threads_per_child > thread_limit) {
!         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                      "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
!                      "value of %d", ap_threads_per_child,
!                      thread_limit);
!         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                      "threads, lowering ThreadsPerChild to %d. To increase, please"
!                      " see the", thread_limit);
!         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                      " ThreadLimit directive.");
!         ap_threads_per_child = thread_limit;
!     }
!     else if (ap_threads_per_child < 1) {
!         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                      "WARNING: Require ThreadsPerChild > 0, setting to 1");
!         ap_threads_per_child = 1;
!     }
      return NULL;
  }
  
  static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg)
  {
-     int tmp_server_limit;
- 
      const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
      if (err != NULL) {
          return err;
      }
  
!     tmp_server_limit = atoi(arg);
!     /* you cannot change ServerLimit across a restart; ignore
!      * any such attempts
!      */
!     if (first_server_limit &&
!         tmp_server_limit != server_limit) {
!         /* how do we log a message?  the error log is a bit bucket at this
!          * point; we'll just have to set a flag so that ap_mpm_run()
!          * logs a warning later
!          */
!         changed_limit_at_restart = 1;
!         return NULL;
!     }
!     server_limit = tmp_server_limit;
! 
!     if (server_limit > MAX_SERVER_LIMIT) {
!        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                     "WARNING: ServerLimit of %d exceeds compile time limit "
!                     "of %d servers,", server_limit, MAX_SERVER_LIMIT);
!        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                     " lowering ServerLimit to %d.", MAX_SERVER_LIMIT);
!        server_limit = MAX_SERVER_LIMIT;
!     }
!     else if (server_limit < 1) {
!         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                      "WARNING: Require ServerLimit > 0, setting to 1");
!         server_limit = 1;
!     }
      return NULL;
  }
  
  static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg)
  {
-     int tmp_thread_limit;
- 
      const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
      if (err != NULL) {
          return err;
      }
  
!     tmp_thread_limit = atoi(arg);
!     /* you cannot change ThreadLimit across a restart; ignore
!      * any such attempts
!      */
!     if (first_thread_limit &&
!         tmp_thread_limit != thread_limit) {
!         /* how do we log a message?  the error log is a bit bucket at this
!          * point; we'll just have to set a flag so that ap_mpm_run()
!          * logs a warning later
!          */
!         changed_limit_at_restart = 1;
!         return NULL;
!     }
!     thread_limit = tmp_thread_limit;
! 
!     if (thread_limit > MAX_THREAD_LIMIT) {
!        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                     "WARNING: ThreadLimit of %d exceeds compile time limit "
!                     "of %d servers,", thread_limit, MAX_THREAD_LIMIT);
!        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                     " lowering ThreadLimit to %d.", MAX_THREAD_LIMIT);
!        thread_limit = MAX_THREAD_LIMIT;
!     }
!     else if (thread_limit < 1) {
!         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
!                      "WARNING: Require ThreadLimit > 0, setting to 1");
!         thread_limit = 1;
!     }
      return NULL;
  }
  
  static const command_rec worker_cmds[] = {
- UNIX_DAEMON_COMMANDS,
  LISTEN_COMMANDS,
  AP_INIT_TAKE1("StartServers", set_daemons_to_start, NULL, RSRC_CONF,
    "Number of child processes launched at server startup"),
--- 2292,2324 ----
          return err;
      }
  
!     threads_per_child = atoi(arg);
      return NULL;
  }
  
  static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg)
  {
      const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
      if (err != NULL) {
          return err;
      }
  
!     server_limit = atoi(arg);
      return NULL;
  }
  
  static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg)
  {
      const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
      if (err != NULL) {
          return err;
      }
  
!     thread_limit = atoi(arg);
      return NULL;
  }
  
  static const command_rec worker_cmds[] = {
  LISTEN_COMMANDS,
  AP_INIT_TAKE1("StartServers", set_daemons_to_start, NULL, RSRC_CONF,
    "Number of child processes launched at server startup"),
*************** AP_GRACEFUL_SHUTDOWN_TIMEOUT_COMMAND,
*** 2284,2290 ****
  
  module AP_MODULE_DECLARE_DATA mpm_worker_module = {
      MPM20_MODULE_STUFF,
!     ap_mpm_rewrite_args,        /* hook to run before apache parses args */
      NULL,                       /* create per-directory config structure */
      NULL,                       /* merge per-directory config structures */
      NULL,                       /* create per-server config structure */
--- 2340,2346 ----
  
  module AP_MODULE_DECLARE_DATA mpm_worker_module = {
      MPM20_MODULE_STUFF,
!     NULL,                       /* hook to run before apache parses args */
      NULL,                       /* create per-directory config structure */
      NULL,                       /* merge per-directory config structures */
      NULL,                       /* create per-server config structure */
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/mpm_common.c /tmp/patch.inc.get2.9J0UCU/server/mpm_common.c
*** /tmp/patch.inc.get1.AvnxJA/server/mpm_common.c	2013-04-28 19:22:12.451306580 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/mpm_common.c	2013-04-28 19:22:13.567312116 +0200
***************
*** 39,53 ****
  #include "http_config.h"
  #include "http_log.h"
  #include "http_main.h"
- #include "mpm.h"
  #include "mpm_common.h"
  #include "ap_mpm.h"
  #include "ap_listen.h"
! #include "mpm_default.h"
  
- #ifdef AP_MPM_WANT_SET_SCOREBOARD
  #include "scoreboard.h"
- #endif
  
  #ifdef HAVE_PWD_H
  #include <pwd.h>
--- 39,50 ----
  #include "http_config.h"
  #include "http_log.h"
  #include "http_main.h"
  #include "mpm_common.h"
  #include "ap_mpm.h"
  #include "ap_listen.h"
! #include "util_mutex.h"
  
  #include "scoreboard.h"
  
  #ifdef HAVE_PWD_H
  #include <pwd.h>
***************
*** 63,378 ****
  APR_HOOK_STRUCT(
      APR_HOOK_LINK(fatal_exception)
      APR_HOOK_LINK(monitor)
  )
  AP_IMPLEMENT_HOOK_RUN_ALL(int, fatal_exception,
                            (ap_exception_info_t *ei), (ei), OK, DECLINED)
  #else
  APR_HOOK_STRUCT(
      APR_HOOK_LINK(monitor)
  )
  #endif
  AP_IMPLEMENT_HOOK_RUN_ALL(int, monitor,
!                           (apr_pool_t *p), (p), OK, DECLINED)
! 
! 
! #ifdef AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
! 
! typedef enum {DO_NOTHING, SEND_SIGTERM, SEND_SIGKILL, GIVEUP} action_t;
! 
! typedef struct extra_process_t {
!     struct extra_process_t *next;
!     pid_t pid;
! } extra_process_t;
! 
! static extra_process_t *extras;
! 
! void ap_register_extra_mpm_process(pid_t pid)
! {
!     extra_process_t *p = (extra_process_t *)malloc(sizeof(extra_process_t));
! 
!     p->next = extras;
!     p->pid = pid;
!     extras = p;
! }
! 
! int ap_unregister_extra_mpm_process(pid_t pid)
! {
!     extra_process_t *cur = extras;
!     extra_process_t *prev = NULL;
! 
!     while (cur && cur->pid != pid) {
!         prev = cur;
!         cur = cur->next;
!     }
! 
!     if (cur) {
!         if (prev) {
!             prev->next = cur->next;
!         }
!         else {
!             extras = cur->next;
!         }
!         free(cur);
!         return 1; /* found */
!     }
!     else {
!         /* we don't know about any such process */
!         return 0;
!     }
! }
! 
! static int reclaim_one_pid(pid_t pid, action_t action)
! {
!     apr_proc_t proc;
!     apr_status_t waitret;
! 
!     /* Ensure pid sanity. */
!     if (pid < 1) {
!         return 1;
!     }        
! 
!     proc.pid = pid;
!     waitret = apr_proc_wait(&proc, NULL, NULL, APR_NOWAIT);
!     if (waitret != APR_CHILD_NOTDONE) {
!         return 1;
!     }
! 
!     switch(action) {
!     case DO_NOTHING:
!         break;
! 
!     case SEND_SIGTERM:
!         /* ok, now it's being annoying */
!         ap_log_error(APLOG_MARK, APLOG_WARNING,
!                      0, ap_server_conf,
!                      "child process %" APR_PID_T_FMT
!                      " still did not exit, "
!                      "sending a SIGTERM",
!                      pid);
!         kill(pid, SIGTERM);
!         break;
! 
!     case SEND_SIGKILL:
!         ap_log_error(APLOG_MARK, APLOG_ERR,
!                      0, ap_server_conf,
!                      "child process %" APR_PID_T_FMT
!                      " still did not exit, "
!                      "sending a SIGKILL",
!                      pid);
! #ifndef BEOS
!         kill(pid, SIGKILL);
! #else
!         /* sending a SIGKILL kills the entire team on BeOS, and as
!          * httpd thread is part of that team it removes any chance
!          * of ever doing a restart.  To counter this I'm changing to
!          * use a kinder, gentler way of killing a specific thread
!          * that is just as effective.
!          */
!         kill_thread(pid);
! #endif
!         break;
! 
!     case GIVEUP:
!         /* gave it our best shot, but alas...  If this really
!          * is a child we are trying to kill and it really hasn't
!          * exited, we will likely fail to bind to the port
!          * after the restart.
!          */
!         ap_log_error(APLOG_MARK, APLOG_ERR,
!                      0, ap_server_conf,
!                      "could not make child process %" APR_PID_T_FMT
!                      " exit, "
!                      "attempting to continue anyway",
!                      pid);
!         break;
!     }
! 
!     return 0;
! }
! 
! void ap_reclaim_child_processes(int terminate)
! {
!     apr_time_t waittime = 1024 * 16;
!     int i;
!     extra_process_t *cur_extra;
!     int not_dead_yet;
!     int max_daemons;
!     apr_time_t starttime = apr_time_now();
!     /* this table of actions and elapsed times tells what action is taken
!      * at which elapsed time from starting the reclaim
!      */
!     struct {
!         action_t action;
!         apr_time_t action_time;
!     } action_table[] = {
!         {DO_NOTHING, 0}, /* dummy entry for iterations where we reap
!                           * children but take no action against
!                           * stragglers
!                           */
!         {SEND_SIGTERM, apr_time_from_sec(3)},
!         {SEND_SIGTERM, apr_time_from_sec(5)},
!         {SEND_SIGTERM, apr_time_from_sec(7)},
!         {SEND_SIGKILL, apr_time_from_sec(9)},
!         {GIVEUP,       apr_time_from_sec(10)}
!     };
!     int cur_action;      /* index of action we decided to take this
!                           * iteration
!                           */
!     int next_action = 1; /* index of first real action */
! 
!     ap_mpm_query(AP_MPMQ_MAX_DAEMON_USED, &max_daemons);
! 
!     do {
!         apr_sleep(waittime);
!         /* don't let waittime get longer than 1 second; otherwise, we don't
!          * react quickly to the last child exiting, and taking action can
!          * be delayed
!          */
!         waittime = waittime * 4;
!         if (waittime > apr_time_from_sec(1)) {
!             waittime = apr_time_from_sec(1);
!         }
! 
!         /* see what action to take, if any */
!         if (action_table[next_action].action_time <= apr_time_now() - starttime) {
!             cur_action = next_action;
!             ++next_action;
!         }
!         else {
!             cur_action = 0; /* nothing to do */
!         }
! 
!         /* now see who is done */
!         not_dead_yet = 0;
!         for (i = 0; i < max_daemons; ++i) {
!             pid_t pid = MPM_CHILD_PID(i);
! 
!             if (pid == 0) {
!                 continue; /* not every scoreboard entry is in use */
!             }
! 
!             if (reclaim_one_pid(pid, action_table[cur_action].action)) {
!                 MPM_NOTE_CHILD_KILLED(i);
!             }
!             else {
!                 ++not_dead_yet;
!             }
!         }
! 
!         cur_extra = extras;
!         while (cur_extra) {
!             extra_process_t *next = cur_extra->next;
! 
!             if (reclaim_one_pid(cur_extra->pid, action_table[cur_action].action)) {
!                 AP_DEBUG_ASSERT(1 == ap_unregister_extra_mpm_process(cur_extra->pid));
!             }
!             else {
!                 ++not_dead_yet;
!             }
!             cur_extra = next;
!         }
! #if APR_HAS_OTHER_CHILD
!         apr_proc_other_child_refresh_all(APR_OC_REASON_RESTART);
! #endif
! 
!     } while (not_dead_yet > 0 &&
!              action_table[cur_action].action != GIVEUP);
! }
! 
! void ap_relieve_child_processes(void)
! {
!     int i;
!     extra_process_t *cur_extra;
!     int max_daemons;
! 
!     ap_mpm_query(AP_MPMQ_MAX_DAEMON_USED, &max_daemons);
! 
!     /* now see who is done */
!     for (i = 0; i < max_daemons; ++i) {
!         pid_t pid = MPM_CHILD_PID(i);
! 
!         if (pid == 0) {
!             continue; /* not every scoreboard entry is in use */
!         }
! 
!         if (reclaim_one_pid(pid, DO_NOTHING)) {
!             MPM_NOTE_CHILD_KILLED(i);
!         }
!     }
! 
!     cur_extra = extras;
!     while (cur_extra) {
!         extra_process_t *next = cur_extra->next;
! 
!         if (reclaim_one_pid(cur_extra->pid, DO_NOTHING)) {
!             AP_DEBUG_ASSERT(1 == ap_unregister_extra_mpm_process(cur_extra->pid));
!         }
!         cur_extra = next;
!     }
! }
! 
! /* Before sending the signal to the pid this function verifies that
!  * the pid is a member of the current process group; either using
!  * apr_proc_wait(), where waitpid() guarantees to fail for non-child
!  * processes; or by using getpgid() directly, if available. */
! apr_status_t ap_mpm_safe_kill(pid_t pid, int sig)
! {
! #ifndef HAVE_GETPGID
!     apr_proc_t proc;
!     apr_status_t rv;
!     apr_exit_why_e why;
!     int status;
! 
!     /* Ensure pid sanity */
!     if (pid < 1) {
!         return APR_EINVAL;
!     }
! 
!     proc.pid = pid;
!     rv = apr_proc_wait(&proc, &status, &why, APR_NOWAIT);
!     if (rv == APR_CHILD_DONE) {
! #ifdef AP_MPM_WANT_PROCESS_CHILD_STATUS
!         /* The child already died - log the termination status if
!          * necessary: */
!         ap_process_child_status(&proc, why, status);
! #endif
!         return APR_EINVAL;
!     }
!     else if (rv != APR_CHILD_NOTDONE) {
!         /* The child is already dead and reaped, or was a bogus pid -
!          * log this either way. */
!         ap_log_error(APLOG_MARK, APLOG_NOTICE, rv, ap_server_conf,
!                      "cannot send signal %d to pid %ld (non-child or "
!                      "already dead)", sig, (long)pid);
!         return APR_EINVAL;
!     }
! #else
!     pid_t pg;
! 
!     /* Ensure pid sanity. */
!     if (pid < 1) {
!         return APR_EINVAL;
!     }
! 
!     pg = getpgid(pid);    
!     if (pg == -1) {
!         /* Process already dead... */
!         return errno;
!     }
! 
!     if (pg != getpgrp()) {
!         ap_log_error(APLOG_MARK, APLOG_ALERT, 0, ap_server_conf,
!                      "refusing to send signal %d to pid %ld outside "
!                      "process group", sig, (long)pid);
!         return APR_EINVAL;
!     }
! #endif        
! 
!     return kill(pid, sig) ? errno : APR_SUCCESS;
! }
! #endif /* AP_MPM_WANT_RECLAIM_CHILD_PROCESSES */
! 
! #ifdef AP_MPM_WANT_WAIT_OR_TIMEOUT
  
  /* number of calls to wait_or_timeout between writable probes */
  #ifndef INTERVAL_OF_WRITABLE_PROBES
--- 60,105 ----
  APR_HOOK_STRUCT(
      APR_HOOK_LINK(fatal_exception)
      APR_HOOK_LINK(monitor)
+     APR_HOOK_LINK(drop_privileges)
+     APR_HOOK_LINK(mpm)
+     APR_HOOK_LINK(mpm_query)
+     APR_HOOK_LINK(mpm_note_child_killed)
+     APR_HOOK_LINK(mpm_register_timed_callback)
+     APR_HOOK_LINK(mpm_get_name)
  )
  AP_IMPLEMENT_HOOK_RUN_ALL(int, fatal_exception,
                            (ap_exception_info_t *ei), (ei), OK, DECLINED)
  #else
  APR_HOOK_STRUCT(
      APR_HOOK_LINK(monitor)
+     APR_HOOK_LINK(drop_privileges)
+     APR_HOOK_LINK(mpm)
+     APR_HOOK_LINK(mpm_query)
+     APR_HOOK_LINK(mpm_note_child_killed)
+     APR_HOOK_LINK(mpm_register_timed_callback)
+     APR_HOOK_LINK(mpm_get_name)
  )
  #endif
  AP_IMPLEMENT_HOOK_RUN_ALL(int, monitor,
!                           (apr_pool_t *p, server_rec *s), (p, s), OK, DECLINED)
! AP_IMPLEMENT_HOOK_RUN_ALL(int, drop_privileges,
!                           (apr_pool_t * pchild, server_rec * s),
!                           (pchild, s), OK, DECLINED)
! AP_IMPLEMENT_HOOK_RUN_FIRST(int, mpm,
!                             (apr_pool_t *pconf, apr_pool_t *plog, server_rec *s),
!                             (pconf, plog, s), DECLINED)
! AP_IMPLEMENT_HOOK_RUN_FIRST(int, mpm_query,
!                             (int query_code, int *result, apr_status_t *_rv),
!                             (query_code, result, _rv), DECLINED)
! AP_IMPLEMENT_HOOK_RUN_FIRST(apr_status_t, mpm_note_child_killed,
!                             (int childnum),
!                             (childnum), APR_ENOTIMPL)
! AP_IMPLEMENT_HOOK_RUN_FIRST(apr_status_t, mpm_register_timed_callback,
!                             (apr_time_t t, ap_mpm_callback_fn_t *cbfn, void *baton),
!                             (t, cbfn, baton), APR_ENOTIMPL)
! AP_IMPLEMENT_HOOK_RUN_FIRST(const char *, mpm_get_name,
!                             (void),
!                             (), NULL)
  
  /* number of calls to wait_or_timeout between writable probes */
  #ifndef INTERVAL_OF_WRITABLE_PROBES
*************** apr_status_t ap_mpm_safe_kill(pid_t pid,
*** 381,394 ****
  static int wait_or_timeout_counter;
  
  void ap_wait_or_timeout(apr_exit_why_e *status, int *exitcode, apr_proc_t *ret,
!                         apr_pool_t *p)
  {
      apr_status_t rv;
  
      ++wait_or_timeout_counter;
      if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {
          wait_or_timeout_counter = 0;
!         ap_run_monitor(p);
      }
  
      rv = apr_proc_wait_all_procs(ret, exitcode, status, APR_NOWAIT, p);
--- 108,121 ----
  static int wait_or_timeout_counter;
  
  void ap_wait_or_timeout(apr_exit_why_e *status, int *exitcode, apr_proc_t *ret,
!                         apr_pool_t *p, server_rec *s)
  {
      apr_status_t rv;
  
      ++wait_or_timeout_counter;
      if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {
          wait_or_timeout_counter = 0;
!         ap_run_monitor(p, s);
      }
  
      rv = apr_proc_wait_all_procs(ret, exitcode, status, APR_NOWAIT, p);
*************** void ap_wait_or_timeout(apr_exit_why_e *
*** 401,479 ****
          return;
      }
  
! #ifdef NEED_WAITPID
!     if ((ret = reap_children(exitcode, status)) > 0) {
!         return;
!     }
! #endif
! 
!     apr_sleep(SCOREBOARD_MAINTENANCE_INTERVAL);
      ret->pid = -1;
      return;
  }
- #endif /* AP_MPM_WANT_WAIT_OR_TIMEOUT */
- 
- #ifdef AP_MPM_WANT_PROCESS_CHILD_STATUS
- int ap_process_child_status(apr_proc_t *pid, apr_exit_why_e why, int status)
- {
-     int signum = status;
-     const char *sigdesc = apr_signal_description_get(signum);
  
!     /* Child died... if it died due to a fatal error,
!      * we should simply bail out.  The caller needs to
!      * check for bad rc from us and exit, running any
!      * appropriate cleanups.
!      *
!      * If the child died due to a resource shortage,
!      * the parent should limit the rate of forking
!      */
!     if (APR_PROC_CHECK_EXIT(why)) {
!         if (status == APEXIT_CHILDSICK) {
!             return status;
!         }
! 
!         if (status == APEXIT_CHILDFATAL) {
!             ap_log_error(APLOG_MARK, APLOG_ALERT,
!                          0, ap_server_conf,
!                          "Child %" APR_PID_T_FMT
!                          " returned a Fatal error... Apache is exiting!",
!                          pid->pid);
!             return APEXIT_CHILDFATAL;
!         }
! 
!         return 0;
!     }
! 
!     if (APR_PROC_CHECK_SIGNALED(why)) {
!         switch (signum) {
!         case SIGTERM:
!         case SIGHUP:
!         case AP_SIG_GRACEFUL:
!         case SIGKILL:
!             break;
! 
!         default:
!             if (APR_PROC_CHECK_CORE_DUMP(why)) {
!                 ap_log_error(APLOG_MARK, APLOG_NOTICE,
!                              0, ap_server_conf,
!                              "child pid %ld exit signal %s (%d), "
!                              "possible coredump in %s",
!                              (long)pid->pid, sigdesc, signum,
!                              ap_coredump_dir);
!             }
!             else {
!                 ap_log_error(APLOG_MARK, APLOG_NOTICE,
!                              0, ap_server_conf,
!                              "child pid %ld exit signal %s (%d)",
!                              (long)pid->pid, sigdesc, signum);
!             }
!         }
!     }
!     return 0;
! }
! #endif /* AP_MPM_WANT_PROCESS_CHILD_STATUS */
! 
! #if defined(TCP_NODELAY) && !defined(MPE) && !defined(TPF)
  void ap_sock_disable_nagle(apr_socket_t *s)
  {
      /* The Nagle algorithm says that we should delay sending partial
--- 128,139 ----
          return;
      }
  
!     apr_sleep(1000000);
      ret->pid = -1;
      return;
  }
  
! #if defined(TCP_NODELAY)
  void ap_sock_disable_nagle(apr_socket_t *s)
  {
      /* The Nagle algorithm says that we should delay sending partial
*************** AP_DECLARE(gid_t) ap_gname2id(const char
*** 533,542 ****
  #ifndef HAVE_INITGROUPS
  int initgroups(const char *name, gid_t basegid)
  {
! #if defined(QNX) || defined(MPE) || defined(BEOS) || defined(_OSD_POSIX) || defined(TPF) || defined(__TANDEM) || defined(OS2) || defined(WIN32) || defined(NETWARE)
! /* QNX, MPE and BeOS do not appear to support supplementary groups. */
      return 0;
! #else /* ndef QNX */
      gid_t groups[NGROUPS_MAX];
      struct group *g;
      int index = 0;
--- 193,201 ----
  #ifndef HAVE_INITGROUPS
  int initgroups(const char *name, gid_t basegid)
  {
! #if defined(_OSD_POSIX) || defined(OS2) || defined(WIN32) || defined(NETWARE)
      return 0;
! #else
      gid_t groups[NGROUPS_MAX];
      struct group *g;
      int index = 0;
*************** int initgroups(const char *name, gid_t b
*** 559,777 ****
      endgrent();
  
      return setgroups(index, groups);
! #endif /* def QNX */
! }
! #endif /* def HAVE_INITGROUPS */
! 
! #ifdef AP_MPM_USES_POD
! 
! AP_DECLARE(apr_status_t) ap_mpm_pod_open(apr_pool_t *p, ap_pod_t **pod)
! {
!     apr_status_t rv;
! 
!     *pod = apr_palloc(p, sizeof(**pod));
!     rv = apr_file_pipe_create(&((*pod)->pod_in), &((*pod)->pod_out), p);
!     if (rv != APR_SUCCESS) {
!         return rv;
!     }
! 
!     apr_file_pipe_timeout_set((*pod)->pod_in, 0);
!     (*pod)->p = p;
! 
!     /* close these before exec. */
!     apr_file_inherit_unset((*pod)->pod_in);
!     apr_file_inherit_unset((*pod)->pod_out);
! 
!     return APR_SUCCESS;
! }
! 
! AP_DECLARE(apr_status_t) ap_mpm_pod_check(ap_pod_t *pod)
! {
!     char c;
!     apr_size_t len = 1;
!     apr_status_t rv;
! 
!     rv = apr_file_read(pod->pod_in, &c, &len);
! 
!     if ((rv == APR_SUCCESS) && (len == 1)) {
!         return APR_SUCCESS;
!     }
! 
!     if (rv != APR_SUCCESS) {
!         return rv;
!     }
! 
!     return AP_NORESTART;
! }
! 
! AP_DECLARE(apr_status_t) ap_mpm_pod_close(ap_pod_t *pod)
! {
!     apr_status_t rv;
! 
!     rv = apr_file_close(pod->pod_out);
!     if (rv != APR_SUCCESS) {
!         return rv;
!     }
! 
!     rv = apr_file_close(pod->pod_in);
!     if (rv != APR_SUCCESS) {
!         return rv;
!     }
! 
!     return APR_SUCCESS;
! }
! 
! static apr_status_t pod_signal_internal(ap_pod_t *pod)
! {
!     apr_status_t rv;
!     char char_of_death = '!';
!     apr_size_t one = 1;
! 
!     rv = apr_file_write(pod->pod_out, &char_of_death, &one);
!     if (rv != APR_SUCCESS) {
!         ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
!                      "write pipe_of_death");
!     }
! 
!     return rv;
! }
! 
! /* This function connects to the server and sends enough data to
!  * ensure the child wakes up and processes a new connection.  This
!  * permits the MPM to skip the poll when there is only one listening
!  * socket, because it provides a alternate way to unblock an accept()
!  * when the pod is used.  */
! static apr_status_t dummy_connection(ap_pod_t *pod)
! {
!     const char *data;
!     apr_status_t rv;
!     apr_socket_t *sock;
!     apr_pool_t *p;
!     apr_size_t len;
! 
!     /* create a temporary pool for the socket.  pconf stays around too long */
!     rv = apr_pool_create(&p, pod->p);
!     if (rv != APR_SUCCESS) {
!         return rv;
!     }
! 
!     rv = apr_socket_create(&sock, ap_listeners->bind_addr->family,
!                            SOCK_STREAM, 0, p);
!     if (rv != APR_SUCCESS) {
!         ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
!                      "get socket to connect to listener");
!         apr_pool_destroy(p);
!         return rv;
!     }
! 
!     /* on some platforms (e.g., FreeBSD), the kernel won't accept many
!      * queued connections before it starts blocking local connects...
!      * we need to keep from blocking too long and instead return an error,
!      * because the MPM won't want to hold up a graceful restart for a
!      * long time
!      */
!     rv = apr_socket_timeout_set(sock, apr_time_from_sec(3));
!     if (rv != APR_SUCCESS) {
!         ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
!                      "set timeout on socket to connect to listener");
!         apr_socket_close(sock);
!         apr_pool_destroy(p);
!         return rv;
!     }
! 
!     rv = apr_socket_connect(sock, ap_listeners->bind_addr);
!     if (rv != APR_SUCCESS) {
!         int log_level = APLOG_WARNING;
! 
!         if (APR_STATUS_IS_TIMEUP(rv)) {
!             /* probably some server processes bailed out already and there
!              * is nobody around to call accept and clear out the kernel
!              * connection queue; usually this is not worth logging
!              */
!             log_level = APLOG_DEBUG;
!         }
! 
!         ap_log_error(APLOG_MARK, log_level, rv, ap_server_conf,
!                      "connect to listener on %pI", ap_listeners->bind_addr);
!         apr_pool_destroy(p);
!         return rv;
!     }
! 
!     if (ap_listeners->protocol && strcasecmp(ap_listeners->protocol, "https") == 0) {
!         /* Send a TLS 1.0 close_notify alert.  This is perhaps the
!          * "least wrong" way to open and cleanly terminate an SSL
!          * connection.  It should "work" without noisy error logs if
!          * the server actually expects SSLv3/TLSv1.  With
!          * SSLv23_server_method() OpenSSL's SSL_accept() fails
!          * ungracefully on receipt of this message, since it requires
!          * an 11-byte ClientHello message and this is too short. */
!         static const unsigned char tls10_close_notify[7] = {
!             '\x15',         /* TLSPlainText.type = Alert (21) */
!             '\x03', '\x01', /* TLSPlainText.version = {3, 1} */
!             '\x00', '\x02', /* TLSPlainText.length = 2 */
!             '\x01',         /* Alert.level = warning (1) */
!             '\x00'          /* Alert.description = close_notify (0) */
!         };
!         data = (const char *)tls10_close_notify;
!         len = sizeof(tls10_close_notify);
!     }
!     else /* ... XXX other request types here? */ {
!         /* Create an HTTP request string.  We include a User-Agent so
!          * that adminstrators can track down the cause of the
!          * odd-looking requests in their logs.  A complete request is
!          * used since kernel-level filtering may require that much
!          * data before returning from accept(). */
!         data = apr_pstrcat(p, "OPTIONS * HTTP/1.0\r\nUser-Agent: ",
!                            ap_get_server_banner(),
!                            " (internal dummy connection)\r\n\r\n", NULL);
!         len = strlen(data);
!     }
! 
!     apr_socket_send(sock, data, &len);
!     apr_socket_close(sock);
!     apr_pool_destroy(p);
! 
!     return rv;
! }
! 
! AP_DECLARE(apr_status_t) ap_mpm_pod_signal(ap_pod_t *pod)
! {
!     apr_status_t rv;
! 
!     rv = pod_signal_internal(pod);
!     if (rv != APR_SUCCESS) {
!         return rv;
!     }
! 
!     return dummy_connection(pod);
! }
! 
! void ap_mpm_pod_killpg(ap_pod_t *pod, int num)
! {
!     int i;
!     apr_status_t rv = APR_SUCCESS;
! 
!     /* we don't write anything to the pod here...  we assume
!      * that the would-be reader of the pod has another way to
!      * see that it is time to die once we wake it up
!      *
!      * writing lots of things to the pod at once is very
!      * problematic... we can fill the kernel pipe buffer and
!      * be blocked until somebody consumes some bytes or
!      * we hit a timeout...  if we hit a timeout we can't just
!      * keep trying because maybe we'll never successfully
!      * write again...  but then maybe we'll leave would-be
!      * readers stranded (a number of them could be tied up for
!      * a while serving time-consuming requests)
!      */
!     for (i = 0; i < num && rv == APR_SUCCESS; i++) {
!         rv = dummy_connection(pod);
!     }
  }
! #endif /* #ifdef AP_MPM_USES_POD */
  
  /* standard mpm configuration handling */
- #ifdef AP_MPM_WANT_SET_PIDFILE
  const char *ap_pid_fname = NULL;
  
  const char *ap_mpm_set_pidfile(cmd_parms *cmd, void *dummy,
--- 218,228 ----
      endgrent();
  
      return setgroups(index, groups);
! #endif
  }
! #endif /* def NEED_INITGROUPS */
  
  /* standard mpm configuration handling */
  const char *ap_pid_fname = NULL;
  
  const char *ap_mpm_set_pidfile(cmd_parms *cmd, void *dummy,
*************** const char *ap_mpm_set_pidfile(cmd_parms
*** 789,797 ****
      ap_pid_fname = arg;
      return NULL;
  }
- #endif
  
- #ifdef AP_MPM_WANT_SET_SCOREBOARD
  const char * ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
                                     const char *arg)
  {
--- 240,246 ----
*************** const char * ap_mpm_set_scoreboard(cmd_p
*** 803,827 ****
      ap_scoreboard_fname = arg;
      return NULL;
  }
- #endif
- 
- #ifdef AP_MPM_WANT_SET_LOCKFILE
- const char *ap_lock_fname = NULL;
  
- const char *ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
-                                 const char *arg)
- {
-     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-     if (err != NULL) {
-         return err;
-     }
- 
-     ap_lock_fname = arg;
-     return NULL;
- }
- #endif
- 
- #ifdef AP_MPM_WANT_SET_MAX_REQUESTS
  int ap_max_requests_per_child = 0;
  
  const char *ap_mpm_set_max_requests(cmd_parms *cmd, void *dummy,
--- 252,258 ----
*************** const char *ap_mpm_set_max_requests(cmd_
*** 836,844 ****
  
      return NULL;
  }
- #endif
  
- #ifdef AP_MPM_WANT_SET_COREDUMPDIR
  char ap_coredump_dir[MAX_STRING_LEN];
  int ap_coredumpdir_configured;
  
--- 267,273 ----
*************** const char *ap_mpm_set_coredumpdir(cmd_p
*** 870,878 ****
      ap_coredumpdir_configured = 1;
      return NULL;
  }
- #endif
  
- #ifdef AP_MPM_WANT_SET_GRACEFUL_SHUTDOWN
  int ap_graceful_shutdown_timeout = 0;
  
  const char * ap_mpm_set_graceful_shutdown(cmd_parms *cmd, void *dummy,
--- 299,305 ----
*************** const char * ap_mpm_set_graceful_shutdow
*** 885,1127 ****
      ap_graceful_shutdown_timeout = atoi(arg);
      return NULL;
  }
- #endif
- 
- #ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
- apr_lockmech_e ap_accept_lock_mech = APR_LOCK_DEFAULT;
- 
- const char ap_valid_accept_mutex_string[] =
-     "Valid accept mutexes for this platform and MPM are: default"
- #if APR_HAS_FLOCK_SERIALIZE
-     ", flock"
- #endif
- #if APR_HAS_FCNTL_SERIALIZE
-     ", fcntl"
- #endif
- #if APR_HAS_SYSVSEM_SERIALIZE && !defined(PERCHILD_MPM)
-     ", sysvsem"
- #endif
- #if APR_HAS_POSIXSEM_SERIALIZE
-     ", posixsem"
- #endif
- #if APR_HAS_PROC_PTHREAD_SERIALIZE
-     ", pthread"
- #endif
-     ".";
- 
- AP_DECLARE(const char *) ap_mpm_set_accept_lock_mech(cmd_parms *cmd,
-                                                      void *dummy,
-                                                      const char *arg)
- {
-     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-     if (err != NULL) {
-         return err;
-     }
- 
-     if (!strcasecmp(arg, "default")) {
-         ap_accept_lock_mech = APR_LOCK_DEFAULT;
-     }
- #if APR_HAS_FLOCK_SERIALIZE
-     else if (!strcasecmp(arg, "flock")) {
-         ap_accept_lock_mech = APR_LOCK_FLOCK;
-     }
- #endif
- #if APR_HAS_FCNTL_SERIALIZE
-     else if (!strcasecmp(arg, "fcntl")) {
-         ap_accept_lock_mech = APR_LOCK_FCNTL;
-     }
- #endif
- 
-     /* perchild can't use SysV sems because the permissions on the accept
-      * mutex can't be set to allow all processes to use the mutex and
-      * at the same time keep all users from being able to dink with the
-      * mutex
-      */
- #if APR_HAS_SYSVSEM_SERIALIZE && !defined(PERCHILD_MPM)
-     else if (!strcasecmp(arg, "sysvsem")) {
-         ap_accept_lock_mech = APR_LOCK_SYSVSEM;
-     }
- #endif
- #if APR_HAS_POSIXSEM_SERIALIZE
-     else if (!strcasecmp(arg, "posixsem")) {
-         ap_accept_lock_mech = APR_LOCK_POSIXSEM;
-     }
- #endif
- #if APR_HAS_PROC_PTHREAD_SERIALIZE
-     else if (!strcasecmp(arg, "pthread")) {
-         ap_accept_lock_mech = APR_LOCK_PROC_PTHREAD;
-     }
- #endif
-     else {
-         return apr_pstrcat(cmd->pool, arg, " is an invalid mutex mechanism; ",
-                            ap_valid_accept_mutex_string, NULL);
-     }
-     return NULL;
- }
- 
- #endif
- 
- #ifdef AP_MPM_WANT_SIGNAL_SERVER
- 
- static const char *dash_k_arg;
- 
- static int send_signal(pid_t pid, int sig)
- {
-     if (kill(pid, sig) < 0) {
-         ap_log_error(APLOG_MARK, APLOG_STARTUP, errno, NULL,
-                      "sending signal to server");
-         return 1;
-     }
-     return 0;
- }
- 
- int ap_signal_server(int *exit_status, apr_pool_t *pconf)
- {
-     apr_status_t rv;
-     pid_t otherpid;
-     int running = 0;
-     const char *status;
- 
-     *exit_status = 0;
- 
-     rv = ap_read_pid(pconf, ap_pid_fname, &otherpid);
-     if (rv != APR_SUCCESS) {
-         if (rv != APR_ENOENT) {
-             ap_log_error(APLOG_MARK, APLOG_STARTUP, rv, NULL,
-                          "Error retrieving pid file %s", ap_pid_fname);
-             ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                          "Remove it before continuing if it is corrupted.");
-             *exit_status = 1;
-             return 1;
-         }
-         status = "httpd (no pid file) not running";
-     }
-     else {
-         if (kill(otherpid, 0) == 0) {
-             running = 1;
-             status = apr_psprintf(pconf,
-                                   "httpd (pid %" APR_PID_T_FMT ") already "
-                                   "running", otherpid);
-         }
-         else {
-             status = apr_psprintf(pconf,
-                                   "httpd (pid %" APR_PID_T_FMT "?) not running",
-                                   otherpid);
-         }
-     }
- 
-     if (!strcmp(dash_k_arg, "start")) {
-         if (running) {
-             printf("%s\n", status);
-             return 1;
-         }
-     }
  
-     if (!strcmp(dash_k_arg, "stop")) {
-         if (!running) {
-             printf("%s\n", status);
-         }
-         else {
-             send_signal(otherpid, SIGTERM);
-         }
-         return 1;
-     }
- 
-     if (!strcmp(dash_k_arg, "restart")) {
-         if (!running) {
-             printf("httpd not running, trying to start\n");
-         }
-         else {
-             *exit_status = send_signal(otherpid, SIGHUP);
-             return 1;
-         }
-     }
- 
-     if (!strcmp(dash_k_arg, "graceful")) {
-         if (!running) {
-             printf("httpd not running, trying to start\n");
-         }
-         else {
-             *exit_status = send_signal(otherpid, AP_SIG_GRACEFUL);
-             return 1;
-         }
-     }
- 
-     if (!strcmp(dash_k_arg, "graceful-stop")) {
- #ifdef AP_MPM_WANT_SET_GRACEFUL_SHUTDOWN
-         if (!running) {
-             printf("%s\n", status);
-         }
-         else {
-             *exit_status = send_signal(otherpid, AP_SIG_GRACEFUL_STOP);
-         }
- #else
-         printf("httpd MPM \"" MPM_NAME "\" does not support graceful-stop\n");
- #endif
-         return 1;
-     }
- 
-     return 0;
- }
- 
- void ap_mpm_rewrite_args(process_rec *process)
- {
-     apr_array_header_t *mpm_new_argv;
-     apr_status_t rv;
-     apr_getopt_t *opt;
-     char optbuf[3];
-     const char *optarg;
- 
-     mpm_new_argv = apr_array_make(process->pool, process->argc,
-                                   sizeof(const char **));
-     *(const char **)apr_array_push(mpm_new_argv) = process->argv[0];
-     apr_getopt_init(&opt, process->pool, process->argc, process->argv);
-     opt->errfn = NULL;
-     optbuf[0] = '-';
-     /* option char returned by apr_getopt() will be stored in optbuf[1] */
-     optbuf[2] = '\0';
-     while ((rv = apr_getopt(opt, "k:" AP_SERVER_BASEARGS,
-                             optbuf + 1, &optarg)) == APR_SUCCESS) {
-         switch(optbuf[1]) {
-         case 'k':
-             if (!dash_k_arg) {
-                 if (!strcmp(optarg, "start") || !strcmp(optarg, "stop") ||
-                     !strcmp(optarg, "restart") || !strcmp(optarg, "graceful") ||
-                     !strcmp(optarg, "graceful-stop")) {
-                     dash_k_arg = optarg;
-                     break;
-                 }
-             }
-         default:
-             *(const char **)apr_array_push(mpm_new_argv) =
-                 apr_pstrdup(process->pool, optbuf);
-             if (optarg) {
-                 *(const char **)apr_array_push(mpm_new_argv) = optarg;
-             }
-         }
-     }
- 
-     /* back up to capture the bad argument */
-     if (rv == APR_BADCH || rv == APR_BADARG) {
-         opt->ind--;
-     }
- 
-     while (opt->ind < opt->argc) {
-         *(const char **)apr_array_push(mpm_new_argv) =
-             apr_pstrdup(process->pool, opt->argv[opt->ind++]);
-     }
- 
-     process->argc = mpm_new_argv->nelts;
-     process->argv = (const char * const *)mpm_new_argv->elts;
- 
-     if (dash_k_arg) {
-         APR_REGISTER_OPTIONAL_FN(ap_signal_server);
-     }
- }
- 
- #endif /* AP_MPM_WANT_SIGNAL_SERVER */
- 
- #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
  apr_uint32_t ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
  
  const char *ap_mpm_set_max_mem_free(cmd_parms *cmd, void *dummy,
--- 312,318 ----
*************** const char *ap_mpm_set_max_mem_free(cmd_
*** 1143,1151 ****
      return NULL;
  }
  
- #endif /* AP_MPM_WANT_SET_MAX_MEM_FREE */
- 
- #ifdef AP_MPM_WANT_SET_STACKSIZE
  apr_size_t ap_thread_stacksize = 0; /* use system default */
  
  const char *ap_mpm_set_thread_stacksize(cmd_parms *cmd, void *dummy,
--- 334,339 ----
*************** const char *ap_mpm_set_thread_stacksize(
*** 1167,1328 ****
      return NULL;
  }
  
! #endif /* AP_MPM_WANT_SET_STACKSIZE */
! 
! #ifdef AP_MPM_WANT_FATAL_SIGNAL_HANDLER
! 
! static pid_t parent_pid, my_pid;
! apr_pool_t *pconf;
! 
! #if AP_ENABLE_EXCEPTION_HOOK
! 
! static int exception_hook_enabled;
! 
! const char *ap_mpm_set_exception_hook(cmd_parms *cmd, void *dummy,
!                                       const char *arg)
  {
!     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
!     if (err != NULL) {
!         return err;
!     }
! 
!     if (cmd->server->is_virtual) {
!         return "EnableExceptionHook directive not allowed in <VirtualHost>";
!     }
  
!     if (strcasecmp(arg, "on") == 0) {
!         exception_hook_enabled = 1;
!     }
!     else if (strcasecmp(arg, "off") == 0) {
!         exception_hook_enabled = 0;
!     }
!     else {
!         return "parameter must be 'on' or 'off'";
      }
  
!     return NULL;
! }
! 
! static void run_fatal_exception_hook(int sig)
! {
!     ap_exception_info_t ei = {0};
! 
!     if (exception_hook_enabled &&
!         geteuid() != 0 &&
!         my_pid != parent_pid) {
!         ei.sig = sig;
!         ei.pid = my_pid;
!         ap_run_fatal_exception(&ei);
!     }
  }
- #endif /* AP_ENABLE_EXCEPTION_HOOK */
  
! /* handle all varieties of core dumping signals */
! static void sig_coredump(int sig)
  {
!     apr_filepath_set(ap_coredump_dir, pconf);
!     apr_signal(sig, SIG_DFL);
! #if AP_ENABLE_EXCEPTION_HOOK
!     run_fatal_exception_hook(sig);
! #endif
!     /* linuxthreads issue calling getpid() here:
!      *   This comparison won't match if the crashing thread is
!      *   some module's thread that runs in the parent process.
!      *   The fallout, which is limited to linuxthreads:
!      *   The special log message won't be written when such a
!      *   thread in the parent causes the parent to crash.
!      */
!     if (getpid() == parent_pid) {
!         ap_log_error(APLOG_MARK, APLOG_NOTICE,
!                      0, ap_server_conf,
!                      "seg fault or similar nasty error detected "
!                      "in the parent process");
!         /* XXX we can probably add some rudimentary cleanup code here,
!          * like getting rid of the pid file.  If any additional bad stuff
!          * happens, we are protected from recursive errors taking down the
!          * system since this function is no longer the signal handler   GLA
!          */
!     }
!     kill(getpid(), sig);
!     /* At this point we've got sig blocked, because we're still inside
!      * the signal handler.  When we leave the signal handler it will
!      * be unblocked, and we'll take the signal... and coredump or whatever
!      * is appropriate for this particular Unix.  In addition the parent
!      * will see the real signal we received -- whereas if we called
!      * abort() here, the parent would only see SIGABRT.
!      */
  }
  
! apr_status_t ap_fatal_signal_child_setup(server_rec *s)
  {
!     my_pid = getpid();
!     return APR_SUCCESS;
  }
  
! apr_status_t ap_fatal_signal_setup(server_rec *s, apr_pool_t *in_pconf)
  {
! #ifndef NO_USE_SIGACTION
!     struct sigaction sa;
! 
!     sigemptyset(&sa.sa_mask);
! 
! #if defined(SA_ONESHOT)
!     sa.sa_flags = SA_ONESHOT;
! #elif defined(SA_RESETHAND)
!     sa.sa_flags = SA_RESETHAND;
! #else
!     sa.sa_flags = 0;
! #endif
! 
!     sa.sa_handler = sig_coredump;
!     if (sigaction(SIGSEGV, &sa, NULL) < 0)
!         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGSEGV)");
! #ifdef SIGBUS
!     if (sigaction(SIGBUS, &sa, NULL) < 0)
!         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGBUS)");
! #endif
! #ifdef SIGABORT
!     if (sigaction(SIGABORT, &sa, NULL) < 0)
!         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGABORT)");
! #endif
! #ifdef SIGABRT
!     if (sigaction(SIGABRT, &sa, NULL) < 0)
!         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGABRT)");
! #endif
! #ifdef SIGILL
!     if (sigaction(SIGILL, &sa, NULL) < 0)
!         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGILL)");
! #endif
! #ifdef SIGFPE
!     if (sigaction(SIGFPE, &sa, NULL) < 0)
!         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGFPE)");
! #endif
  
! #else /* NO_USE_SIGACTION */
! 
!     apr_signal(SIGSEGV, sig_coredump);
! #ifdef SIGBUS
!     apr_signal(SIGBUS, sig_coredump);
! #endif /* SIGBUS */
! #ifdef SIGABORT
!     apr_signal(SIGABORT, sig_coredump);
! #endif /* SIGABORT */
! #ifdef SIGABRT
!     apr_signal(SIGABRT, sig_coredump);
! #endif /* SIGABRT */
! #ifdef SIGILL
!     apr_signal(SIGILL, sig_coredump);
! #endif /* SIGILL */
! #ifdef SIGFPE
!     apr_signal(SIGFPE, sig_coredump);
! #endif /* SIGFPE */
! 
! #endif /* NO_USE_SIGACTION */
! 
!     pconf = in_pconf;
!     parent_pid = my_pid = getpid();
  
!     return APR_SUCCESS;
  }
- 
- #endif /* AP_MPM_WANT_FATAL_SIGNAL_HANDLER */
--- 355,388 ----
      return NULL;
  }
  
! AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
  {
!     apr_status_t rv;
  
!     if (ap_run_mpm_query(query_code, result, &rv) == DECLINED) {
!         rv = APR_EGENERAL;
      }
  
!     return rv;
  }
  
! AP_DECLARE(apr_status_t) ap_mpm_note_child_killed(int childnum)
  {
!     return ap_run_mpm_note_child_killed(childnum);
  }
  
! AP_DECLARE(apr_status_t) ap_mpm_register_timed_callback(apr_time_t t, ap_mpm_callback_fn_t *cbfn, void *baton)
  {
!     return ap_run_mpm_register_timed_callback(t, cbfn, baton);
  }
  
! AP_DECLARE(const char *)ap_show_mpm(void)
  {
!     const char *name = ap_run_mpm_get_name();
  
!     if (!name) {
!         name = "";
!     }
  
!     return name;
  }
Only in /tmp/patch.inc.get2.9J0UCU/server: mpm_unix.c
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/protocol.c /tmp/patch.inc.get2.9J0UCU/server/protocol.c
*** /tmp/patch.inc.get1.AvnxJA/server/protocol.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/protocol.c	2013-04-28 19:22:13.551312047 +0200
***************
*** 15,21 ****
   */
  
  /*
!  * protocol.c --- routines which directly communicate with the client.
   *
   * Code originally by Rob McCool; much redone by Robert S. Thau
   * and the Apache Software Foundation.
--- 15,21 ----
   */
  
  /*
!  * http_protocol.c --- routines which directly communicate with the client.
   *
   * Code originally by Rob McCool; much redone by Robert S. Thau
   * and the Apache Software Foundation.
***************
*** 33,39 ****
  #define APR_WANT_MEMFUNC
  #include "apr_want.h"
  
- #define CORE_PRIVATE
  #include "util_filter.h"
  #include "ap_config.h"
  #include "httpd.h"
--- 33,38 ----
*************** AP_DECLARE(void) ap_setup_make_content_t
*** 95,101 ****
  /*
   * Builds the content-type that should be sent to the client from the
   * content-type specified.  The following rules are followed:
!  *    - if type is NULL, type is set to ap_default_type(r)
   *    - if charset adding is disabled, stop processing and return type.
   *    - then, if there are no parameters on type, add the default charset
   *    - return type
--- 94,100 ----
  /*
   * Builds the content-type that should be sent to the client from the
   * content-type specified.  The following rules are followed:
!  *    - if type is NULL or "", return NULL (do not set content-type).
   *    - if charset adding is disabled, stop processing and return type.
   *    - then, if there are no parameters on type, add the default charset
   *    - return type
*************** AP_DECLARE(const char *)ap_make_content_
*** 109,116 ****
      core_request_config *request_conf;
      apr_size_t type_len;
  
!     if (!type) {
!         type = ap_default_type(r);
      }
  
      if (conf->add_default_charset != ADD_DEFAULT_CHARSET_ON) {
--- 108,115 ----
      core_request_config *request_conf;
      apr_size_t type_len;
  
!     if (!type || *type == '\0') {
!         return NULL;
      }
  
      if (conf->add_default_charset != ADD_DEFAULT_CHARSET_ON) {
*************** AP_DECLARE(apr_status_t) ap_rgetline_cor
*** 222,230 ****
       * against APR_ASCII_LF at the end of the loop if bb only contains
       * zero-length buckets.
       */
!     if (last_char) {
          *last_char = '\0';
-     }
  
      for (;;) {
          apr_brigade_cleanup(bb);
--- 221,228 ----
       * against APR_ASCII_LF at the end of the loop if bb only contains
       * zero-length buckets.
       */
!     if (last_char)
          *last_char = '\0';
  
      for (;;) {
          apr_brigade_cleanup(bb);
*************** static int read_request_line(request_rec
*** 608,614 ****
                  r->proto_num = HTTP_VERSION(1,0);
                  r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
              }
!             else if (APR_STATUS_IS_TIMEUP(rv)) {
                  r->status = HTTP_REQUEST_TIME_OUT;
              }
              return 0;
--- 606,612 ----
                  r->proto_num = HTTP_VERSION(1,0);
                  r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
              }
!             else if (rv == APR_TIMEUP) {
                  r->status = HTTP_REQUEST_TIME_OUT;
              }
              return 0;
*************** static int read_request_line(request_rec
*** 670,685 ****
      return 1;
  }
  
- /* get the length of the field name for logging, but no more than 80 bytes */
- #define LOG_NAME_MAX_LEN 80
- static int field_name_len(const char *field)
- {
-     const char *end = ap_strchr_c(field, ':');
-     if (end == NULL || end - field > LOG_NAME_MAX_LEN)
-         return LOG_NAME_MAX_LEN;
-     return end - field;
- }
- 
  AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb)
  {
      char *last_field = NULL;
--- 668,673 ----
*************** AP_DECLARE(void) ap_get_mime_headers_cor
*** 704,710 ****
                           &len, r, 0, bb);
  
          if (rv != APR_SUCCESS) {
!             if (APR_STATUS_IS_TIMEUP(rv)) {
                  r->status = HTTP_REQUEST_TIME_OUT;
              }
              else {
--- 692,698 ----
                           &len, r, 0, bb);
  
          if (rv != APR_SUCCESS) {
!             if (rv == APR_TIMEUP) {
                  r->status = HTTP_REQUEST_TIME_OUT;
              }
              else {
*************** AP_DECLARE(void) ap_get_mime_headers_cor
*** 719,733 ****
                  /* insure ap_escape_html will terminate correctly */
                  field[len - 1] = '\0';
                  apr_table_setn(r->notes, "error-notes",
!                                apr_psprintf(r->pool,
                                             "Size of a request header field "
                                             "exceeds server limit.<br />\n"
!                                            "<pre>\n%.*s\n</pre>/n",
!                                            field_name_len(field), 
!                                            ap_escape_html(r->pool, field)));
!                 ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, 
!                               "Request header exceeds LimitRequestFieldSize: "
!                               "%.*s", field_name_len(field), field);
              }
              return;
          }
--- 707,718 ----
                  /* insure ap_escape_html will terminate correctly */
                  field[len - 1] = '\0';
                  apr_table_setn(r->notes, "error-notes",
!                                apr_pstrcat(r->pool,
                                             "Size of a request header field "
                                             "exceeds server limit.<br />\n"
!                                            "<pre>\n",
!                                            ap_escape_html(r->pool, field),
!                                            "</pre>\n", NULL));
              }
              return;
          }
*************** AP_DECLARE(void) ap_get_mime_headers_cor
*** 748,764 ****
                       * overflow (last_field) as the field with the problem
                       */
                      apr_table_setn(r->notes, "error-notes",
!                                    apr_psprintf(r->pool,
                                                 "Size of a request header field "
                                                 "after folding "
                                                 "exceeds server limit.<br />\n"
!                                                "<pre>\n%.*s\n</pre>\n",
!                                                field_name_len(last_field),
!                                                ap_escape_html(r->pool, last_field)));
!                     ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
!                                   "Request header exceeds LimitRequestFieldSize "
!                                   "after folding: %.*s",
!                                   field_name_len(last_field), last_field);
                      return;
                  }
  
--- 733,745 ----
                       * overflow (last_field) as the field with the problem
                       */
                      apr_table_setn(r->notes, "error-notes",
!                                    apr_pstrcat(r->pool,
                                                 "Size of a request header field "
                                                 "after folding "
                                                 "exceeds server limit.<br />\n"
!                                                "<pre>\n",
!                                                ap_escape_html(r->pool, last_field),
!                                                "</pre>\n", NULL));
                      return;
                  }
  
*************** AP_DECLARE(void) ap_get_mime_headers_cor
*** 790,807 ****
                  if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                      r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                      apr_table_setn(r->notes, "error-notes",
!                                    apr_psprintf(r->pool,
                                                 "Request header field is "
                                                 "missing ':' separator.<br />\n"
!                                                "<pre>\n%.*s</pre>\n",
!                                                (int)LOG_NAME_MAX_LEN,
                                                 ap_escape_html(r->pool,
!                                                               last_field)));
!                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
!                                   "Request header field is missing ':' "
!                                   "separator: %.*s", (int)LOG_NAME_MAX_LEN,
!                                   last_field);
! 
                      return;
                  }
  
--- 771,783 ----
                  if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                      r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                      apr_table_setn(r->notes, "error-notes",
!                                    apr_pstrcat(r->pool,
                                                 "Request header field is "
                                                 "missing ':' separator.<br />\n"
!                                                "<pre>\n",
                                                 ap_escape_html(r->pool,
!                                                               last_field),
!                                                "</pre>\n", NULL));
                      return;
                  }
  
*************** request_rec *ap_read_request(conn_rec *c
*** 874,882 ****
--- 850,860 ----
      apr_socket_t *csd;
      apr_interval_time_t cur_timeout;
  
+ 
      apr_pool_create(&p, conn->pool);
      apr_pool_tag(p, "request");
      r = apr_pcalloc(p, sizeof(request_rec));
+     AP_READ_REQUEST_ENTRY((intptr_t)r, (uintptr_t)conn);
      r->pool            = p;
      r->connection      = conn;
      r->server          = conn->base_server;
*************** request_rec *ap_read_request(conn_rec *c
*** 926,944 ****
              ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
              ap_run_log_transaction(r);
              apr_brigade_destroy(tmp_bb);
!             return r;
          }
          else if (r->status == HTTP_REQUEST_TIME_OUT) {
              ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
!             if (!r->connection->keepalives) {
!                 ap_run_log_transaction(r);
!             }
              apr_brigade_destroy(tmp_bb);
!             return r;
          }
  
          apr_brigade_destroy(tmp_bb);
!         return NULL;
      }
  
      /* We may have been in keep_alive_timeout mode, so toggle back
--- 904,921 ----
              ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
              ap_run_log_transaction(r);
              apr_brigade_destroy(tmp_bb);
!             goto traceout;
          }
          else if (r->status == HTTP_REQUEST_TIME_OUT) {
              ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
!             ap_run_log_transaction(r);
              apr_brigade_destroy(tmp_bb);
!             goto traceout;
          }
  
          apr_brigade_destroy(tmp_bb);
!         r = NULL;
!         goto traceout;
      }
  
      /* We may have been in keep_alive_timeout mode, so toggle back
*************** request_rec *ap_read_request(conn_rec *c
*** 961,967 ****
              ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
              ap_run_log_transaction(r);
              apr_brigade_destroy(tmp_bb);
!             return r;
          }
  
          if (apr_table_get(r->headers_in, "Transfer-Encoding")
--- 938,944 ----
              ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
              ap_run_log_transaction(r);
              apr_brigade_destroy(tmp_bb);
!             goto traceout;
          }
  
          if (apr_table_get(r->headers_in, "Transfer-Encoding")
*************** request_rec *ap_read_request(conn_rec *c
*** 989,995 ****
              ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
              ap_run_log_transaction(r);
              apr_brigade_destroy(tmp_bb);
!             return r;
          }
      }
  
--- 966,972 ----
              ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
              ap_run_log_transaction(r);
              apr_brigade_destroy(tmp_bb);
!             goto traceout;
          }
      }
  
*************** request_rec *ap_read_request(conn_rec *c
*** 1041,1054 ****
          ap_send_error_response(r, 0);
          ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
          ap_run_log_transaction(r);
!         return r;
      }
  
      if ((access_status = ap_run_post_read_request(r))) {
          ap_die(access_status, r);
          ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
          ap_run_log_transaction(r);
!         return NULL;
      }
  
      if (((expect = apr_table_get(r->headers_in, "Expect")) != NULL)
--- 1018,1032 ----
          ap_send_error_response(r, 0);
          ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
          ap_run_log_transaction(r);
!         goto traceout;
      }
  
      if ((access_status = ap_run_post_read_request(r))) {
          ap_die(access_status, r);
          ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
          ap_run_log_transaction(r);
!         r = NULL;
!         goto traceout;
      }
  
      if (((expect = apr_table_get(r->headers_in, "Expect")) != NULL)
*************** request_rec *ap_read_request(conn_rec *c
*** 1070,1089 ****
              ap_send_error_response(r, 0);
              ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
              ap_run_log_transaction(r);
!             return r;
          }
      }
  
      return r;
  }
  
! /* if a request with a body creates a subrequest, remove original request's
!  * input headers which pertain to the body which has already been read.
!  * out-of-line helper function for ap_set_sub_req_protocol.
   */
  
! static void strip_headers_request_body(request_rec *rnew)
  {
      apr_table_unset(rnew->headers_in, "Content-Encoding");
      apr_table_unset(rnew->headers_in, "Content-Language");
      apr_table_unset(rnew->headers_in, "Content-Length");
--- 1048,1073 ----
              ap_send_error_response(r, 0);
              ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
              ap_run_log_transaction(r);
!             goto traceout;
          }
      }
  
+     AP_READ_REQUEST_SUCCESS((uintptr_t)r, (char *)r->method, (char *)r->uri, (char *)r->server->defn_name, r->status);
+     return r;
+     traceout:
+     AP_READ_REQUEST_FAILURE((uintptr_t)r);
      return r;
  }
  
! /* if a request with a body creates a subrequest, clone the original request's
!  * input headers minus any headers pertaining to the body which has already
!  * been read.  out-of-line helper function for ap_set_sub_req_protocol.
   */
  
! static void clone_headers_no_body(request_rec *rnew,
!                                   const request_rec *r)
  {
+     rnew->headers_in = apr_table_copy(rnew->pool, r->headers_in);
      apr_table_unset(rnew->headers_in, "Content-Encoding");
      apr_table_unset(rnew->headers_in, "Content-Language");
      apr_table_unset(rnew->headers_in, "Content-Length");
*************** AP_DECLARE(void) ap_set_sub_req_protocol
*** 1117,1130 ****
  
      rnew->status          = HTTP_OK;
  
-     rnew->headers_in = apr_table_copy(rnew->pool, r->headers_in);
- 
      /* did the original request have a body?  (e.g. POST w/SSI tags)
       * if so, make sure the subrequest doesn't inherit body headers
       */
!     if (apr_table_get(r->headers_in, "Content-Length")
!         || apr_table_get(r->headers_in, "Transfer-Encoding")) {
!         strip_headers_request_body(rnew);
      }
      rnew->subprocess_env  = apr_table_copy(rnew->pool, r->subprocess_env);
      rnew->headers_out     = apr_table_make(rnew->pool, 5);
--- 1101,1115 ----
  
      rnew->status          = HTTP_OK;
  
      /* did the original request have a body?  (e.g. POST w/SSI tags)
       * if so, make sure the subrequest doesn't inherit body headers
       */
!     if (!r->kept_body && (apr_table_get(r->headers_in, "Content-Length")
!         || apr_table_get(r->headers_in, "Transfer-Encoding"))) {
!         clone_headers_no_body(rnew, r);
!     } else {
!         /* no body (common case).  clone headers the cheap way */
!         rnew->headers_in      = r->headers_in;
      }
      rnew->subprocess_env  = apr_table_copy(rnew->pool, r->subprocess_env);
      rnew->headers_out     = apr_table_make(rnew->pool, 5);
*************** struct content_length_ctx {
*** 1266,1271 ****
--- 1251,1257 ----
                       * least one bucket on to the next output filter
                       * for this request
                       */
+     apr_bucket_brigade *tmpbb;
  };
  
  /* This filter computes the content length, but it also computes the number
*************** AP_CORE_DECLARE_NONSTD(apr_status_t) ap_
*** 1286,1291 ****
--- 1272,1278 ----
      if (!ctx) {
          f->ctx = ctx = apr_palloc(r->pool, sizeof(*ctx));
          ctx->data_sent = 0;
+         ctx->tmpbb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
      }
  
      /* Loop through this set of buckets to compute their length
*************** AP_CORE_DECLARE_NONSTD(apr_status_t) ap_
*** 1315,1330 ****
                   * do a blocking read on the next batch.
                   */
                  if (e != APR_BRIGADE_FIRST(b)) {
!                     apr_bucket_brigade *split = apr_brigade_split(b, e);
!                     apr_bucket *flush = apr_bucket_flush_create(r->connection->bucket_alloc);
  
                      APR_BRIGADE_INSERT_TAIL(b, flush);
                      rv = ap_pass_brigade(f->next, b);
                      if (rv != APR_SUCCESS || f->c->aborted) {
-                         apr_brigade_destroy(split);
                          return rv;
                      }
!                     b = split;
                      e = APR_BRIGADE_FIRST(b);
  
                      ctx->data_sent = 1;
--- 1302,1318 ----
                   * do a blocking read on the next batch.
                   */
                  if (e != APR_BRIGADE_FIRST(b)) {
!                     apr_bucket *flush;
!                     apr_brigade_split_ex(b, e, ctx->tmpbb);
!                     flush = apr_bucket_flush_create(r->connection->bucket_alloc);
  
                      APR_BRIGADE_INSERT_TAIL(b, flush);
                      rv = ap_pass_brigade(f->next, b);
                      if (rv != APR_SUCCESS || f->c->aborted) {
                          return rv;
                      }
!                     apr_brigade_cleanup(b);
!                     APR_BRIGADE_CONCAT(b, ctx->tmpbb);
                      e = APR_BRIGADE_FIRST(b);
  
                      ctx->data_sent = 1;
*************** AP_CORE_DECLARE_NONSTD(apr_status_t) ap_
*** 1356,1368 ****
           * by something like proxy.  the brigade only has an EOS bucket
           * in this case, making r->bytes_sent zero.
           *
!          * if r->bytes_sent > 0 we have a (temporary) body whose length may 
!          * have been changed by a filter.  the C-L header might not have been 
!          * updated so we do it here.  long term it would be cleaner to have 
!          * such filters update or remove the C-L header, and just use it 
           * if present.
           */
!         !(r->header_only && r->bytes_sent == 0 &&   
              apr_table_get(r->headers_out, "Content-Length"))) {
          ap_set_content_length(r, r->bytes_sent);
      }
--- 1344,1356 ----
           * by something like proxy.  the brigade only has an EOS bucket
           * in this case, making r->bytes_sent zero.
           *
!          * if r->bytes_sent > 0 we have a (temporary) body whose length may
!          * have been changed by a filter.  the C-L header might not have been
!          * updated so we do it here.  long term it would be cleaner to have
!          * such filters update or remove the C-L header, and just use it
           * if present.
           */
!         !(r->header_only && r->bytes_sent == 0 &&
              apr_table_get(r->headers_out, "Content-Length"))) {
          ap_set_content_length(r, r->bytes_sent);
      }
*************** AP_DECLARE(apr_status_t) ap_send_fd(apr_
*** 1380,1391 ****
  {
      conn_rec *c = r->connection;
      apr_bucket_brigade *bb = NULL;
-     apr_bucket *b;
      apr_status_t rv;
  
      bb = apr_brigade_create(r->pool, c->bucket_alloc);
!     b = apr_bucket_file_create(fd, offset, len, r->pool, c->bucket_alloc);
!     APR_BRIGADE_INSERT_TAIL(bb, b);
  
      rv = ap_pass_brigade(r->output_filters, bb);
      if (rv != APR_SUCCESS) {
--- 1368,1378 ----
  {
      conn_rec *c = r->connection;
      apr_bucket_brigade *bb = NULL;
      apr_status_t rv;
  
      bb = apr_brigade_create(r->pool, c->bucket_alloc);
!     
!     apr_brigade_insert_file(bb, fd, 0, len, r->pool);
  
      rv = ap_pass_brigade(r->output_filters, bb);
      if (rv != APR_SUCCESS) {
*************** AP_DECLARE(size_t) ap_send_mmap(apr_mmap
*** 1418,1423 ****
--- 1405,1411 ----
  
  typedef struct {
      apr_bucket_brigade *bb;
+     apr_bucket_brigade *tmpbb;
  } old_write_filter_ctx;
  
  AP_CORE_DECLARE_NONSTD(apr_status_t) ap_old_write_filter(
*************** AP_CORE_DECLARE_NONSTD(apr_status_t) ap_
*** 1427,1433 ****
  
      AP_DEBUG_ASSERT(ctx);
  
!     if (ctx->bb != 0) {
          /* whatever is coming down the pipe (we don't care), we
           * can simply insert our buffered data at the front and
           * pass the whole bundle down the chain.
--- 1415,1421 ----
  
      AP_DEBUG_ASSERT(ctx);
  
!     if (ctx->bb != NULL) {
          /* whatever is coming down the pipe (we don't care), we
           * can simply insert our buffered data at the front and
           * pass the whole bundle down the chain.
*************** AP_CORE_DECLARE_NONSTD(apr_status_t) ap_
*** 1438,1453 ****
      return ap_pass_brigade(f->next, bb);
  }
  
! static apr_status_t buffer_output(request_rec *r,
!                                   const char *str, apr_size_t len)
  {
-     conn_rec *c = r->connection;
      ap_filter_t *f;
      old_write_filter_ctx *ctx;
  
-     if (len == 0)
-         return APR_SUCCESS;
- 
      /* future optimization: record some flags in the request_rec to
       * say whether we've added our filter, and whether it is first.
       */
--- 1426,1436 ----
      return ap_pass_brigade(f->next, bb);
  }
  
! static ap_filter_t *insert_old_write_filter(request_rec *r)
  {
      ap_filter_t *f;
      old_write_filter_ctx *ctx;
  
      /* future optimization: record some flags in the request_rec to
       * say whether we've added our filter, and whether it is first.
       */
*************** static apr_status_t buffer_output(reques
*** 1461,1484 ****
      if (f == NULL) {
          /* our filter hasn't been added yet */
          ctx = apr_pcalloc(r->pool, sizeof(*ctx));
          ap_add_output_filter("OLD_WRITE", ctx, r, r->connection);
          f = r->output_filters;
      }
  
      /* if the first filter is not our buffering filter, then we have to
       * deliver the content through the normal filter chain
       */
      if (f != r->output_filters) {
!         apr_bucket_brigade *bb = apr_brigade_create(r->pool, c->bucket_alloc);
          apr_bucket *b = apr_bucket_transient_create(str, len, c->bucket_alloc);
!         APR_BRIGADE_INSERT_TAIL(bb, b);
  
!         return ap_pass_brigade(r->output_filters, bb);
      }
  
-     /* grab the context from our filter */
-     ctx = r->output_filters->ctx;
- 
      if (ctx->bb == NULL) {
          ctx->bb = apr_brigade_create(r->pool, c->bucket_alloc);
      }
--- 1444,1484 ----
      if (f == NULL) {
          /* our filter hasn't been added yet */
          ctx = apr_pcalloc(r->pool, sizeof(*ctx));
+         ctx->tmpbb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
+ 
          ap_add_output_filter("OLD_WRITE", ctx, r, r->connection);
          f = r->output_filters;
      }
  
+     return f;
+ }
+ 
+ static apr_status_t buffer_output(request_rec *r,
+                                   const char *str, apr_size_t len)
+ {
+     conn_rec *c = r->connection;
+     ap_filter_t *f;
+     old_write_filter_ctx *ctx;
+ 
+     if (len == 0)
+         return APR_SUCCESS;
+ 
+     f = insert_old_write_filter(r);
+     ctx = f->ctx;
+ 
      /* if the first filter is not our buffering filter, then we have to
       * deliver the content through the normal filter chain
       */
      if (f != r->output_filters) {
!         apr_status_t rv;
          apr_bucket *b = apr_bucket_transient_create(str, len, c->bucket_alloc);
!         APR_BRIGADE_INSERT_TAIL(ctx->tmpbb, b);
  
!         rv = ap_pass_brigade(r->output_filters, ctx->tmpbb);
!         apr_brigade_cleanup(ctx->tmpbb);
!         return rv;
      }
  
      if (ctx->bb == NULL) {
          ctx->bb = apr_brigade_create(r->pool, c->bucket_alloc);
      }
*************** AP_DECLARE_NONSTD(int) ap_rvputs(request
*** 1633,1645 ****
  AP_DECLARE(int) ap_rflush(request_rec *r)
  {
      conn_rec *c = r->connection;
-     apr_bucket_brigade *bb;
      apr_bucket *b;
  
-     bb = apr_brigade_create(r->pool, c->bucket_alloc);
      b = apr_bucket_flush_create(c->bucket_alloc);
!     APR_BRIGADE_INSERT_TAIL(bb, b);
!     if (ap_pass_brigade(r->output_filters, bb) != APR_SUCCESS)
          return -1;
  
      return 0;
--- 1633,1652 ----
  AP_DECLARE(int) ap_rflush(request_rec *r)
  {
      conn_rec *c = r->connection;
      apr_bucket *b;
+     ap_filter_t *f;
+     old_write_filter_ctx *ctx;
+     apr_status_t rv;
+ 
+     f = insert_old_write_filter(r);
+     ctx = f->ctx;
  
      b = apr_bucket_flush_create(c->bucket_alloc);
!     APR_BRIGADE_INSERT_TAIL(ctx->tmpbb, b);
! 
!     rv = ap_pass_brigade(r->output_filters, ctx->tmpbb);
!     apr_brigade_cleanup(ctx->tmpbb);
!     if (rv != APR_SUCCESS)
          return -1;
  
      return 0;
*************** typedef struct hdr_ptr {
*** 1665,1700 ****
      ap_filter_t *f;
      apr_bucket_brigade *bb;
  } hdr_ptr;
- 
  static int send_header(void *data, const char *key, const char *val)
  {
      ap_fputstrs(((hdr_ptr*)data)->f, ((hdr_ptr*)data)->bb,
                  key, ": ", val, CRLF, NULL);
      return 1;
  }
- 
  AP_DECLARE(void) ap_send_interim_response(request_rec *r, int send_headers)
  {
      hdr_ptr x;
      char *status_line = NULL;
-     request_rec *rr;
  
      if (r->proto_num < 1001) {
          /* don't send interim response to HTTP/1.0 Client */
          return;
      }
      if (!ap_is_HTTP_INFO(r->status)) {
!         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                        "Status is %d - not sending interim response", r->status);
          return;
      }
! 
!     /* if we send an interim response, we're no longer in a state of
!      * expecting one.  Also, this could feasibly be in a subrequest,
!      * so we need to propagate the fact that we responded.
!      */
!     for (rr = r; rr != NULL; rr = rr->main) {
!         rr->expecting_100 = 0;
      }
  
      status_line = apr_pstrcat(r->pool, AP_SERVER_PROTOCOL, " ", r->status_line, CRLF, NULL);
--- 1672,1704 ----
      ap_filter_t *f;
      apr_bucket_brigade *bb;
  } hdr_ptr;
  static int send_header(void *data, const char *key, const char *val)
  {
      ap_fputstrs(((hdr_ptr*)data)->f, ((hdr_ptr*)data)->bb,
                  key, ": ", val, CRLF, NULL);
      return 1;
  }
  AP_DECLARE(void) ap_send_interim_response(request_rec *r, int send_headers)
  {
      hdr_ptr x;
      char *status_line = NULL;
  
      if (r->proto_num < 1001) {
          /* don't send interim response to HTTP/1.0 Client */
          return;
      }
      if (!ap_is_HTTP_INFO(r->status)) {
!         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                        "Status is %d - not sending interim response", r->status);
          return;
      }
!     if ((r->status == HTTP_CONTINUE) && !r->expecting_100) {
!         /*
!          * Don't send 100-Continue when there was no Expect: 100-continue
!          * in the request headers. For origin servers this is a SHOULD NOT
!          * for proxies it is a MUST NOT according to RFC 2616 8.2.3
!          */
!         return;
      }
  
      status_line = apr_pstrcat(r->pool, AP_SERVER_PROTOCOL, " ", r->status_line, CRLF, NULL);
*************** AP_DECLARE(void) ap_send_interim_respons
*** 1708,1718 ****
          apr_table_do(send_header, &x, r->headers_out, NULL);
          apr_table_clear(r->headers_out);
      }
!     ap_fputs(x.f, x.bb, CRLF);
      ap_fflush(x.f, x.bb);
      apr_brigade_destroy(x.bb);
  }
  
  AP_IMPLEMENT_HOOK_RUN_ALL(int,post_read_request,
                            (request_rec *r), (r), OK, DECLINED)
  AP_IMPLEMENT_HOOK_RUN_ALL(int,log_transaction,
--- 1712,1723 ----
          apr_table_do(send_header, &x, r->headers_out, NULL);
          apr_table_clear(r->headers_out);
      }
!     ap_fputs(x.f, x.bb, CRLF_ASCII);
      ap_fflush(x.f, x.bb);
      apr_brigade_destroy(x.bb);
  }
  
+ 
  AP_IMPLEMENT_HOOK_RUN_ALL(int,post_read_request,
                            (request_rec *r), (r), OK, DECLINED)
  AP_IMPLEMENT_HOOK_RUN_ALL(int,log_transaction,
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/request.c /tmp/patch.inc.get2.9J0UCU/server/request.c
*** /tmp/patch.inc.get1.AvnxJA/server/request.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/request.c	2013-04-28 19:22:13.551312047 +0200
***************
*** 32,39 ****
  #define APR_WANT_STRFUNC
  #include "apr_want.h"
  
- #define CORE_PRIVATE
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_config.h"
  #include "http_request.h"
--- 32,39 ----
  #define APR_WANT_STRFUNC
  #include "apr_want.h"
  
  #include "ap_config.h"
+ #include "ap_provider.h"
  #include "httpd.h"
  #include "http_config.h"
  #include "http_request.h"
***************
*** 44,51 ****
--- 44,54 ----
  #include "util_filter.h"
  #include "util_charset.h"
  #include "util_script.h"
+ #include "ap_expr.h"
+ #include "mod_request.h"
  
  #include "mod_core.h"
+ #include "mod_auth.h"
  
  #if APR_HAVE_STDARG_H
  #include <stdarg.h>
*************** AP_IMPLEMENT_HOOK_VOID(insert_filter, (r
*** 81,86 ****
--- 84,93 ----
  AP_IMPLEMENT_HOOK_RUN_ALL(int, create_request,
                            (request_rec *r), (r), OK, DECLINED)
  
+ static int auth_internal_per_conf = 0;
+ static int auth_internal_per_conf_hooks = 0;
+ static int auth_internal_per_conf_providers = 0;
+ 
  
  static int decl_die(int status, char *phase, request_rec *r)
  {
*************** AP_DECLARE(int) ap_process_request_inter
*** 109,115 ****
          core_dir_config *d;
          d = ap_get_module_config(r->per_dir_config, &core_module);
          if (d->allow_encoded_slashes) {
!             access_status = ap_unescape_url_keep2f_ex(r->parsed_uri.path, d->decode_encoded_slashes);
          }
          else {
              access_status = ap_unescape_url(r->parsed_uri.path);
--- 116,122 ----
          core_dir_config *d;
          d = ap_get_module_config(r->per_dir_config, &core_module);
          if (d->allow_encoded_slashes) {
!             access_status = ap_unescape_url_keep2f(r->parsed_uri.path);
          }
          else {
              access_status = ap_unescape_url(r->parsed_uri.path);
*************** AP_DECLARE(int) ap_process_request_inter
*** 170,244 ****
       * functions in map_to_storage that use the same merge results given
       * identical input.)  If the config changes, we must re-auth.
       */
!     if (r->main && (r->main->per_dir_config == r->per_dir_config)) {
!         r->user = r->main->user;
!         r->ap_auth_type = r->main->ap_auth_type;
!     }
!     else if (r->prev && (r->prev->per_dir_config == r->per_dir_config)) {
          r->user = r->prev->user;
          r->ap_auth_type = r->prev->ap_auth_type;
      }
      else {
          switch (ap_satisfies(r)) {
          case SATISFY_ALL:
          case SATISFY_NOSPEC:
!             if ((access_status = ap_run_access_checker(r)) != 0) {
                  return decl_die(access_status, "check access", r);
              }
  
!             if (ap_some_auth_required(r)) {
!                 if (((access_status = ap_run_check_user_id(r)) != 0)
!                     || !ap_auth_type(r)) {
!                     return decl_die(access_status, ap_auth_type(r)
!                                   ? "check user.  Check your authn provider!"
!                                   : "perform authentication. AuthType not set!",
!                                   r);
!                 }
  
!                 if (((access_status = ap_run_auth_checker(r)) != 0)
!                     || !ap_auth_type(r)) {
!                     return decl_die(access_status, ap_auth_type(r)
!                                   ? "check access.  Check your 'Require' directive"
!                                   : "perform authentication. AuthType not set!",
!                                    r);
!                 }
              }
              break;
- 
          case SATISFY_ANY:
!             if (((access_status = ap_run_access_checker(r)) != 0)) {
!                 if (!ap_some_auth_required(r)) {
!                     return decl_die(access_status, "check access", r);
!                 }
! 
!                 if (((access_status = ap_run_check_user_id(r)) != 0)
!                     || !ap_auth_type(r)) {
!                     return decl_die(access_status, ap_auth_type(r)
!                                   ? "check user.  Check your authn provider!"
!                                   : "perform authentication. AuthType not set!",
!                                   r);
!                 }
! 
!                 if (((access_status = ap_run_auth_checker(r)) != 0)
!                     || !ap_auth_type(r)) {
!                     return decl_die(access_status, ap_auth_type(r)
!                                   ? "check access.  Check your 'Require' directive"
!                                   : "perform authentication. AuthType not set!",
!                                   r);
                  }
              }
              break;
          }
      }
      /* XXX Must make certain the ap_run_type_checker short circuits mime
       * in mod-proxy for r->proxyreq && r->parsed_uri.scheme
       *                              && !strcmp(r->parsed_uri.scheme, "http")
       */
!     if ((access_status = ap_run_type_checker(r)) != 0) {
          return decl_die(access_status, "find types", r);
      }
  
!     if ((access_status = ap_run_fixups(r)) != 0) {
          return access_status;
      }
  
--- 177,231 ----
       * functions in map_to_storage that use the same merge results given
       * identical input.)  If the config changes, we must re-auth.
       */
!     if (r->prev && (r->prev->per_dir_config == r->per_dir_config)) {
          r->user = r->prev->user;
          r->ap_auth_type = r->prev->ap_auth_type;
      }
+     else if (r->main && (r->main->per_dir_config == r->per_dir_config)) {
+         r->user = r->main->user;
+         r->ap_auth_type = r->main->ap_auth_type;
+     }
      else {
          switch (ap_satisfies(r)) {
          case SATISFY_ALL:
          case SATISFY_NOSPEC:
!             if ((access_status = ap_run_access_checker(r)) != OK) {
                  return decl_die(access_status, "check access", r);
              }
  
!             if ((access_status = ap_run_check_user_id(r)) != OK) {
!                 return decl_die(access_status, "check user", r);
!             }
  
!             if ((access_status = ap_run_auth_checker(r)) != OK) {
!                 return decl_die(access_status, "check authorization", r);
              }
              break;
          case SATISFY_ANY:
!             if ((access_status = ap_run_access_checker(r)) != OK) {
! 
!                 if ((access_status = ap_run_check_user_id(r)) != OK) {
!                     return decl_die(access_status, "check user", r);
!                 }
! 
!                 if ((access_status = ap_run_auth_checker(r)) != OK) {
!                     return decl_die(access_status, "check authorization", r);
                  }
              }
              break;
          }
+ 
+ 
      }
      /* XXX Must make certain the ap_run_type_checker short circuits mime
       * in mod-proxy for r->proxyreq && r->parsed_uri.scheme
       *                              && !strcmp(r->parsed_uri.scheme, "http")
       */
!     if ((access_status = ap_run_type_checker(r)) != OK) {
          return decl_die(access_status, "find types", r);
      }
  
!     if ((access_status = ap_run_fixups(r)) != OK) {
          return access_status;
      }
  
*************** typedef struct walk_cache_t {
*** 267,310 ****
      ap_conf_vector_t   *dir_conf_merged; /* Base per_dir_config */
      ap_conf_vector_t   *per_dir_result;  /* per_dir_config += walked result */
      apr_array_header_t *walked;          /* The list of walk_walked_t results */
  } walk_cache_t;
  
  static walk_cache_t *prep_walk_cache(apr_size_t t, request_rec *r)
  {
!     walk_cache_t *cache;
!     void **note;
! 
!     /* Find the most relevant, recent entry to work from.  That would be
!      * this request (on the second call), or the parent request of a
!      * subrequest, or the prior request of an internal redirect.  Provide
!      * this _walk()er with a copy it is allowed to munge.  If there is no
!      * parent or prior cached request, then create a new walk cache.
       */
      note = ap_get_request_note(r, t);
      if (!note) {
          return NULL;
      }
  
!     if (!(cache = *note)) {
!         void **inherit_note;
  
!         if ((r->main
!              && ((inherit_note = ap_get_request_note(r->main, t)))
!              && *inherit_note)
!             || (r->prev
!                 && ((inherit_note = ap_get_request_note(r->prev, t)))
!                 && *inherit_note)) {
!             cache = apr_pmemdup(r->pool, *inherit_note,
!                                 sizeof(*cache));
!             cache->walked = apr_array_copy(r->pool, cache->walked);
!         }
!         else {
!             cache = apr_pcalloc(r->pool, sizeof(*cache));
!             cache->walked = apr_array_make(r->pool, 4, sizeof(walk_walked_t));
          }
  
!         *note = cache;
      }
      return cache;
  }
  
--- 254,314 ----
      ap_conf_vector_t   *dir_conf_merged; /* Base per_dir_config */
      ap_conf_vector_t   *per_dir_result;  /* per_dir_config += walked result */
      apr_array_header_t *walked;          /* The list of walk_walked_t results */
+     struct walk_cache_t *prev; /* Prev cache of same call in this (sub)req */
+     int count; /* Number of prev invocations of same call in this (sub)req */
  } walk_cache_t;
  
  static walk_cache_t *prep_walk_cache(apr_size_t t, request_rec *r)
  {
!     void **note, **inherit_note;
!     walk_cache_t *cache, *prev_cache, *copy_cache;
!     int count;
! 
!     /* Find the most relevant, recent walk cache to work from and provide
!      * a copy the caller is allowed to munge.  In the case of a sub-request
!      * or internal redirect, this is the cache corresponding to the equivalent
!      * invocation of the same function call in the "parent" request, if such
!      * a cache exists.  Otherwise it is the walk cache of the previous
!      * invocation of the same function call in the current request, if
!      * that exists; if not, then create a new walk cache.
       */
      note = ap_get_request_note(r, t);
      if (!note) {
          return NULL;
      }
  
!     copy_cache = prev_cache = *note;
!     count = prev_cache ? (prev_cache->count + 1) : 0;
  
!     if ((r->prev
!          && (inherit_note = ap_get_request_note(r->prev, t))
!          && *inherit_note)
!         || (r->main
!             && (inherit_note = ap_get_request_note(r->main, t))
!             && *inherit_note)) {
!         walk_cache_t *inherit_cache = *inherit_note;
! 
!         while (inherit_cache->count > count) {
!             inherit_cache = inherit_cache->prev;
!         }
!         if (inherit_cache->count == count) {
!             copy_cache = inherit_cache;
          }
+     }
  
!     if (copy_cache) {
!         cache = apr_pmemdup(r->pool, copy_cache, sizeof(*cache));
!         cache->walked = apr_array_copy(r->pool, cache->walked);
!         cache->prev = prev_cache;
!         cache->count = count;
!     }
!     else {
!         cache = apr_pcalloc(r->pool, sizeof(*cache));
!         cache->walked = apr_array_make(r->pool, 4, sizeof(walk_walked_t));
      }
+ 
+     *note = cache;
+ 
      return cache;
  }
  
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 473,478 ****
--- 477,483 ----
      walk_cache_t *cache;
      char *entry_dir;
      apr_status_t rv;
+     int cached;
  
      /* XXX: Better (faster) tests needed!!!
       *
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 510,515 ****
--- 515,521 ----
      r->filename = entry_dir;
  
      cache = prep_walk_cache(AP_NOTE_DIRECTORY_WALK, r);
+     cached = (cache->cached != NULL);
  
      /* If this is not a dirent subrequest with a preconstructed
       * r->finfo value, then we can simply stat the filename to
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 553,565 ****
       * and the vhost's list of directory sections hasn't changed,
       * we can skip rewalking the directory_walk entries.
       */
!     if (cache->cached
          && ((r->finfo.filetype == APR_REG)
              || ((r->finfo.filetype == APR_DIR)
                  && (!r->path_info || !*r->path_info)))
          && (cache->dir_conf_tested == sec_ent)
          && (strcmp(entry_dir, cache->cached) == 0)) {
- 
          int familiar = 0;
  
          /* Well this looks really familiar!  If our end-result (per_dir_result)
--- 559,570 ----
       * and the vhost's list of directory sections hasn't changed,
       * we can skip rewalking the directory_walk entries.
       */
!     if (cached
          && ((r->finfo.filetype == APR_REG)
              || ((r->finfo.filetype == APR_DIR)
                  && (!r->path_info || !*r->path_info)))
          && (cache->dir_conf_tested == sec_ent)
          && (strcmp(entry_dir, cache->cached) == 0)) {
          int familiar = 0;
  
          /* Well this looks really familiar!  If our end-result (per_dir_result)
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 571,580 ****
              familiar = 1;
          }
  
!         else if (r->per_dir_config == cache->dir_conf_merged) {
              r->per_dir_config = cache->per_dir_result;
              familiar = 1;
          }
          if (familiar) {
              apr_finfo_t thisinfo;
              int res;
--- 576,586 ----
              familiar = 1;
          }
  
!         if (r->per_dir_config == cache->dir_conf_merged) {
              r->per_dir_config = cache->per_dir_result;
              familiar = 1;
          }
+ 
          if (familiar) {
              apr_finfo_t thisinfo;
              int res;
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 638,643 ****
--- 644,650 ----
           */
          int sec_idx;
          int matches = cache->walked->nelts;
+         int cached_matches = matches;
          walk_walked_t *last_walk = (walk_walked_t*)cache->walked->elts;
          core_dir_config *this_dir;
          core_opts_t opts;
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 655,660 ****
--- 662,669 ----
          apr_size_t canonical_len;
  #endif
  
+         cached &= auth_internal_per_conf;
+ 
          /*
           * We must play our own mini-merge game here, for the few
           * running dir_config values we care about within dir_walk.
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 670,676 ****
  
          /* Set aside path_info to merge back onto path_info later.
           * If r->filename is a directory, we must remerge the path_info,
!          * before we continue!  [Directories cannot, by definition, have
           * path info.  Either the next segment is not-found, or a file.]
           *
           * r->path_info tracks the unconsumed source path.
--- 679,685 ----
  
          /* Set aside path_info to merge back onto path_info later.
           * If r->filename is a directory, we must remerge the path_info,
!          * before we continue!  [Directories cannot, by defintion, have
           * path info.  Either the next segment is not-found, or a file.]
           *
           * r->path_info tracks the unconsumed source path.
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 846,851 ****
--- 855,861 ----
                       */
                      cache->walked->nelts -= matches;
                      matches = 0;
+                     cached = 0;
                  }
  
                  if (now_merged) {
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 913,918 ****
--- 923,929 ----
                       */
                      cache->walked->nelts -= matches;
                      matches = 0;
+                     cached = 0;
                  }
  
                  if (now_merged) {
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 1011,1019 ****
              }
              else if (APR_STATUS_IS_EACCES(rv)) {
                  ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
!                               "access to %s denied (filesystem path '%s') "
!                               "because search permissions are missing on a "
!                               "component of the path", r->uri, r->filename);
                  return r->status = HTTP_FORBIDDEN;
              }
              else if ((rv != APR_SUCCESS && rv != APR_INCOMPLETE)
--- 1022,1028 ----
              }
              else if (APR_STATUS_IS_EACCES(rv)) {
                  ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
!                               "access to %s denied", r->uri);
                  return r->status = HTTP_FORBIDDEN;
              }
              else if ((rv != APR_SUCCESS && rv != APR_INCOMPLETE)
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 1022,1029 ****
                   * rather than assume not found.
                   */
                  ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
!                               "access to %s failed (filesystem path '%s')", 
!                               r->uri, r->filename);
                  return r->status = HTTP_FORBIDDEN;
              }
  
--- 1031,1037 ----
                   * rather than assume not found.
                   */
                  ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
!                               "access to %s failed", r->uri);
                  return r->status = HTTP_FORBIDDEN;
              }
  
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 1128,1133 ****
--- 1136,1142 ----
                   */
                  cache->walked->nelts -= matches;
                  matches = 0;
+                 cached = 0;
              }
  
              if (now_merged) {
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 1144,1154 ****
              last_walk->merged = now_merged;
          }
  
!         /* Whoops - everything matched in sequence, but the original walk
!          * found some additional matches.  Truncate them.
           */
          if (matches) {
              cache->walked->nelts -= matches;
          }
      }
  
--- 1153,1168 ----
              last_walk->merged = now_merged;
          }
  
!         /* Whoops - everything matched in sequence, but either the original
!          * walk found some additional matches (which we need to truncate), or
!          * this walk found some additional matches.
           */
          if (matches) {
              cache->walked->nelts -= matches;
+             cached = 0;
+         }
+         else if (cache->walked->nelts > cached_matches) {
+             cached = 0;
          }
      }
  
*************** AP_DECLARE(int) ap_directory_walk(reques
*** 1188,1193 ****
--- 1202,1213 ----
          cache->cached = ap_make_dirstr_parent(r->pool, r->filename);
      }
  
+     if (cached
+         && r->per_dir_config == cache->dir_conf_merged) {
+         r->per_dir_config = cache->per_dir_result;
+         return OK;
+     }
+ 
      cache->dir_conf_tested = sec_ent;
      cache->dir_conf_merged = r->per_dir_config;
  
*************** AP_DECLARE(int) ap_location_walk(request
*** 1214,1219 ****
--- 1234,1240 ----
      int num_sec = sconf->sec_url->nelts;
      walk_cache_t *cache;
      const char *entry_uri;
+     int cached;
  
      /* No tricks here, there are no <Locations > to parse in this vhost.
       * We won't destroy the cache, just in case _this_ redirect is later
*************** AP_DECLARE(int) ap_location_walk(request
*** 1224,1229 ****
--- 1245,1251 ----
      }
  
      cache = prep_walk_cache(AP_NOTE_LOCATION_WALK, r);
+     cached = (cache->cached != NULL);
  
      /* Location and LocationMatch differ on their behaviour w.r.t. multiple
       * slashes.  Location matches multiple slashes with a single slash,
*************** AP_DECLARE(int) ap_location_walk(request
*** 1243,1249 ****
       * and the vhost's list of locations hasn't changed, we can skip
       * rewalking the location_walk entries.
       */
!     if (cache->cached
          && (cache->dir_conf_tested == sec_ent)
          && (strcmp(entry_uri, cache->cached) == 0)) {
          /* Well this looks really familiar!  If our end-result (per_dir_result)
--- 1265,1271 ----
       * and the vhost's list of locations hasn't changed, we can skip
       * rewalking the location_walk entries.
       */
!     if (cached
          && (cache->dir_conf_tested == sec_ent)
          && (strcmp(entry_uri, cache->cached) == 0)) {
          /* Well this looks really familiar!  If our end-result (per_dir_result)
*************** AP_DECLARE(int) ap_location_walk(request
*** 1255,1265 ****
              return OK;
          }
  
-         if (r->per_dir_config == cache->dir_conf_merged) {
-             r->per_dir_config = cache->per_dir_result;
-             return OK;
-         }
- 
          if (cache->walked->nelts) {
              now_merged = ((walk_walked_t*)cache->walked->elts)
                                              [cache->walked->nelts - 1].merged;
--- 1277,1282 ----
*************** AP_DECLARE(int) ap_location_walk(request
*** 1271,1277 ****
--- 1288,1297 ----
           */
          int len, sec_idx;
          int matches = cache->walked->nelts;
+         int cached_matches = matches;
          walk_walked_t *last_walk = (walk_walked_t*)cache->walked->elts;
+ 
+         cached &= auth_internal_per_conf;
          cache->cached = entry_uri;
  
          /* Go through the location entries, and check for matches.
*************** AP_DECLARE(int) ap_location_walk(request
*** 1296,1302 ****
                  : (entry_core->d_is_fnmatch
                     ? apr_fnmatch(entry_core->d, cache->cached, APR_FNM_PATHNAME)
                     : (strncmp(entry_core->d, cache->cached, len)
!                       || (entry_core->d[len - 1] != '/'
                            && cache->cached[len] != '/'
                            && cache->cached[len] != '\0')))) {
                  continue;
--- 1316,1323 ----
                  : (entry_core->d_is_fnmatch
                     ? apr_fnmatch(entry_core->d, cache->cached, APR_FNM_PATHNAME)
                     : (strncmp(entry_core->d, cache->cached, len)
!                       || (len > 0
!                           && entry_core->d[len - 1] != '/'
                            && cache->cached[len] != '/'
                            && cache->cached[len] != '\0')))) {
                  continue;
*************** AP_DECLARE(int) ap_location_walk(request
*** 1317,1322 ****
--- 1338,1344 ----
                   */
                  cache->walked->nelts -= matches;
                  matches = 0;
+                 cached = 0;
              }
  
              if (now_merged) {
*************** AP_DECLARE(int) ap_location_walk(request
*** 1333,1346 ****
              last_walk->merged = now_merged;
          }
  
!         /* Whoops - everything matched in sequence, but the original walk
!          * found some additional matches.  Truncate them.
           */
          if (matches) {
              cache->walked->nelts -= matches;
          }
      }
  
      cache->dir_conf_tested = sec_ent;
      cache->dir_conf_merged = r->per_dir_config;
  
--- 1355,1379 ----
              last_walk->merged = now_merged;
          }
  
!         /* Whoops - everything matched in sequence, but either the original
!          * walk found some additional matches (which we need to truncate), or
!          * this walk found some additional matches.
           */
          if (matches) {
              cache->walked->nelts -= matches;
+             cached = 0;
+         }
+         else if (cache->walked->nelts > cached_matches) {
+             cached = 0;
          }
      }
  
+     if (cached
+         && r->per_dir_config == cache->dir_conf_merged) {
+         r->per_dir_config = cache->per_dir_result;
+         return OK;
+     }
+ 
      cache->dir_conf_tested = sec_ent;
      cache->dir_conf_merged = r->per_dir_config;
  
*************** AP_DECLARE(int) ap_file_walk(request_rec
*** 1366,1371 ****
--- 1399,1405 ----
      int num_sec = dconf->sec_file->nelts;
      walk_cache_t *cache;
      const char *test_file;
+     int cached;
  
      /* To allow broken modules to proceed, we allow missing filenames to pass.
       * We will catch it later if it's heading for the core handler.
*************** AP_DECLARE(int) ap_file_walk(request_rec
*** 1376,1381 ****
--- 1410,1416 ----
      }
  
      cache = prep_walk_cache(AP_NOTE_FILE_WALK, r);
+     cached = (cache->cached != NULL);
  
      /* No tricks here, there are just no <Files > to parse in this context.
       * We won't destroy the cache, just in case _this_ redirect is later
*************** AP_DECLARE(int) ap_file_walk(request_rec
*** 1400,1406 ****
       * and the directory's list of file sections hasn't changed, we
       * can skip rewalking the file_walk entries.
       */
!     if (cache->cached
          && (cache->dir_conf_tested == sec_ent)
          && (strcmp(test_file, cache->cached) == 0)) {
          /* Well this looks really familiar!  If our end-result (per_dir_result)
--- 1435,1441 ----
       * and the directory's list of file sections hasn't changed, we
       * can skip rewalking the file_walk entries.
       */
!     if (cached
          && (cache->dir_conf_tested == sec_ent)
          && (strcmp(test_file, cache->cached) == 0)) {
          /* Well this looks really familiar!  If our end-result (per_dir_result)
*************** AP_DECLARE(int) ap_file_walk(request_rec
*** 1412,1422 ****
              return OK;
          }
  
-         if (r->per_dir_config == cache->dir_conf_merged) {
-             r->per_dir_config = cache->per_dir_result;
-             return OK;
-         }
- 
          if (cache->walked->nelts) {
              now_merged = ((walk_walked_t*)cache->walked->elts)
                  [cache->walked->nelts - 1].merged;
--- 1447,1452 ----
*************** AP_DECLARE(int) ap_file_walk(request_rec
*** 1428,1434 ****
--- 1458,1467 ----
           */
          int sec_idx;
          int matches = cache->walked->nelts;
+         int cached_matches = matches;
          walk_walked_t *last_walk = (walk_walked_t*)cache->walked->elts;
+ 
+         cached &= auth_internal_per_conf;
          cache->cached = test_file;
  
          /* Go through the location entries, and check for matches.
*************** AP_DECLARE(int) ap_file_walk(request_rec
*** 1436,1451 ****
           * really try them with the most general first.
           */
          for (sec_idx = 0; sec_idx < num_sec; ++sec_idx) {
! 
              core_dir_config *entry_core;
              entry_core = ap_get_module_config(sec_ent[sec_idx], &core_module);
  
!             if (entry_core->r
!                 ? ap_regexec(entry_core->r, cache->cached , 0, NULL, 0)
!                 : (entry_core->d_is_fnmatch
!                    ? apr_fnmatch(entry_core->d, cache->cached, APR_FNM_PATHNAME)
!                    : strcmp(entry_core->d, cache->cached))) {
!                 continue;
              }
  
              /* If we merged this same section last time, reuse it
--- 1469,1492 ----
           * really try them with the most general first.
           */
          for (sec_idx = 0; sec_idx < num_sec; ++sec_idx) {
!             int err = 0;
              core_dir_config *entry_core;
              entry_core = ap_get_module_config(sec_ent[sec_idx], &core_module);
  
!             if (entry_core->condition) {
!                 if (!ap_expr_eval(r, entry_core->condition, &err, NULL,
!                                   ap_expr_string, NULL)) {
!                     continue;
!                 }
!             }
!             else {
!                 if (entry_core->r
!                     ? ap_regexec(entry_core->r, cache->cached , 0, NULL, 0)
!                     : (entry_core->d_is_fnmatch
!                        ? apr_fnmatch(entry_core->d, cache->cached, APR_FNM_PATHNAME)
!                        : strcmp(entry_core->d, cache->cached))) {
!                     continue;
!                 }
              }
  
              /* If we merged this same section last time, reuse it
*************** AP_DECLARE(int) ap_file_walk(request_rec
*** 1463,1468 ****
--- 1504,1510 ----
                   */
                  cache->walked->nelts -= matches;
                  matches = 0;
+                 cached = 0;
              }
  
              if (now_merged) {
*************** AP_DECLARE(int) ap_file_walk(request_rec
*** 1479,1492 ****
              last_walk->merged = now_merged;
          }
  
!         /* Whoops - everything matched in sequence, but the original walk
!          * found some additional matches.  Truncate them.
           */
          if (matches) {
              cache->walked->nelts -= matches;
          }
      }
  
      cache->dir_conf_tested = sec_ent;
      cache->dir_conf_merged = r->per_dir_config;
  
--- 1521,1545 ----
              last_walk->merged = now_merged;
          }
  
!         /* Whoops - everything matched in sequence, but either the original
!          * walk found some additional matches (which we need to truncate), or
!          * this walk found some additional matches.
           */
          if (matches) {
              cache->walked->nelts -= matches;
+             cached = 0;
+         }
+         else if (cache->walked->nelts > cached_matches) {
+             cached = 0;
          }
      }
  
+     if (cached
+         && r->per_dir_config == cache->dir_conf_merged) {
+         r->per_dir_config = cache->per_dir_result;
+         return OK;
+     }
+ 
      cache->dir_conf_tested = sec_ent;
      cache->dir_conf_merged = r->per_dir_config;
  
*************** static request_rec *make_sub_request(con
*** 1590,1595 ****
--- 1643,1651 ----
       * until some module interjects and changes the value.
       */
      rnew->used_path_info = AP_REQ_DEFAULT_PATH_INFO;
+     
+     /* Pass on the kept body (if any) into the new request. */
+     rnew->kept_body = r->kept_body;
  
      return rnew;
  }
*************** AP_CORE_DECLARE_NONSTD(apr_status_t) ap_
*** 1610,1639 ****
      return APR_SUCCESS;
  }
  
  
  AP_DECLARE(int) ap_some_auth_required(request_rec *r)
  {
      /* Is there a require line configured for the type of *this* req? */
  
!     const apr_array_header_t *reqs_arr = ap_requires(r);
!     require_line *reqs;
!     int i;
  
!     if (!reqs_arr) {
!         return 0;
      }
  
!     reqs = (require_line *) reqs_arr->elts;
  
!     for (i = 0; i < reqs_arr->nelts; ++i) {
!         if (reqs[i].method_mask & (AP_METHOD_BIT << r->method_number)) {
!             return 1;
!         }
      }
  
!     return 0;
  }
  
  
  AP_DECLARE(request_rec *) ap_sub_req_method_uri(const char *method,
                                                  const char *new_uri,
--- 1666,1774 ----
      return APR_SUCCESS;
  }
  
+ extern APR_OPTIONAL_FN_TYPE(authz_some_auth_required) *ap__authz_ap_some_auth_required;
  
  AP_DECLARE(int) ap_some_auth_required(request_rec *r)
  {
      /* Is there a require line configured for the type of *this* req? */
+     if (ap__authz_ap_some_auth_required) {
+         return ap__authz_ap_some_auth_required(r);
+     }
+     else
+         return 0;
+ }
+ 
+ AP_DECLARE(void) ap_clear_auth_internal(void)
+ {
+     auth_internal_per_conf_hooks = 0;
+     auth_internal_per_conf_providers = 0;
+ }
  
! AP_DECLARE(void) ap_setup_auth_internal(apr_pool_t *ptemp)
! {
!     int total_auth_hooks = 0;
!     int total_auth_providers = 0;
  
!     auth_internal_per_conf = 0;
! 
!     if (_hooks.link_access_checker) {
!         total_auth_hooks += _hooks.link_access_checker->nelts;
!     }
!     if (_hooks.link_check_user_id) {
!         total_auth_hooks += _hooks.link_check_user_id->nelts;
!     }
!     if (_hooks.link_auth_checker) {
!         total_auth_hooks += _hooks.link_auth_checker->nelts;
      }
  
!     if (total_auth_hooks > auth_internal_per_conf_hooks) {
!         return;
!     }
  
!     total_auth_providers +=
!         ap_list_provider_names(ptemp, AUTHN_PROVIDER_GROUP,
!                                AUTHN_PROVIDER_VERSION)->nelts;
!     total_auth_providers +=
!         ap_list_provider_names(ptemp, AUTHZ_PROVIDER_GROUP,
!                                AUTHZ_PROVIDER_VERSION)->nelts;
! 
!     if (total_auth_providers > auth_internal_per_conf_providers) {
!         return;
      }
  
!     auth_internal_per_conf = 1;
  }
  
+ AP_DECLARE(apr_status_t) ap_register_auth_provider(apr_pool_t *pool,
+                                                    const char *provider_group,
+                                                    const char *provider_name,
+                                                    const char *provider_version,
+                                                    const void *provider,
+                                                    int type)
+ {
+     if ((type & AP_AUTH_INTERNAL_MASK) == AP_AUTH_INTERNAL_PER_CONF) {
+         ++auth_internal_per_conf_providers;
+     }
+ 
+     return ap_register_provider(pool, provider_group, provider_name,
+                                 provider_version, provider);
+ }
+ 
+ AP_DECLARE(void) ap_hook_check_access(ap_HOOK_access_checker_t *pf,
+                                       const char * const *aszPre,
+                                       const char * const *aszSucc,
+                                       int nOrder, int type)
+ {
+     if ((type & AP_AUTH_INTERNAL_MASK) == AP_AUTH_INTERNAL_PER_CONF) {
+         ++auth_internal_per_conf_hooks;
+     }
+ 
+     ap_hook_access_checker(pf, aszPre, aszSucc, nOrder);
+ }
+ 
+ AP_DECLARE(void) ap_hook_check_authn(ap_HOOK_check_user_id_t *pf,
+                                      const char * const *aszPre,
+                                      const char * const *aszSucc,
+                                      int nOrder, int type)
+ {
+     if ((type & AP_AUTH_INTERNAL_MASK) == AP_AUTH_INTERNAL_PER_CONF) {
+         ++auth_internal_per_conf_hooks;
+     }
+ 
+     ap_hook_check_user_id(pf, aszPre, aszSucc, nOrder);
+ }
+ 
+ AP_DECLARE(void) ap_hook_check_authz(ap_HOOK_auth_checker_t *pf,
+                                      const char * const *aszPre,
+                                      const char * const *aszSucc,
+                                      int nOrder, int type)
+ {
+     if ((type & AP_AUTH_INTERNAL_MASK) == AP_AUTH_INTERNAL_PER_CONF) {
+         ++auth_internal_per_conf_hooks;
+     }
+ 
+     ap_hook_auth_checker(pf, aszPre, aszSucc, nOrder);
+ }
  
  AP_DECLARE(request_rec *) ap_sub_req_method_uri(const char *method,
                                                  const char *new_uri,
*************** AP_DECLARE(int) ap_is_initial_req(reques
*** 1965,1967 ****
--- 2100,2103 ----
      return (r->main == NULL)       /* otherwise, this is a sub-request */
             && (r->prev == NULL);   /* otherwise, this is an internal redirect */
  }
+ 
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/scoreboard.c /tmp/patch.inc.get2.9J0UCU/server/scoreboard.c
*** /tmp/patch.inc.get1.AvnxJA/server/scoreboard.c	2013-04-28 19:22:12.451306580 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/scoreboard.c	2013-04-28 19:22:13.567312116 +0200
***************
*** 34,40 ****
  #include "http_config.h"
  #include "ap_mpm.h"
  
- #include "mpm.h"
  #include "scoreboard.h"
  
  AP_DECLARE_DATA scoreboard *ap_scoreboard_image = NULL;
--- 34,39 ----
*************** AP_DECLARE_DATA const char *ap_scoreboar
*** 42,49 ****
  AP_DECLARE_DATA int ap_extended_status = 0;
  AP_DECLARE_DATA int ap_mod_status_reqtail = 0;
  
- static ap_scoreboard_e scoreboard_type;
- 
  #if APR_HAS_SHARED_MEMORY
  
  #include "apr_shm.h"
--- 41,46 ----
*************** AP_IMPLEMENT_HOOK_RUN_ALL(int,pre_mpm,
*** 64,77 ****
                            (p, sb_type),OK,DECLINED)
  
  static APR_OPTIONAL_FN_TYPE(ap_proxy_lb_workers)
!                                 *proxy_lb_workers;
  
  struct ap_sb_handle_t {
      int child_num;
      int thread_num;
  };
  
! static int server_limit, thread_limit, lb_limit;
  static apr_size_t scoreboard_size;
  
  /*
--- 61,78 ----
                            (p, sb_type),OK,DECLINED)
  
  static APR_OPTIONAL_FN_TYPE(ap_proxy_lb_workers)
!                                 *pfn_proxy_lb_workers;
! static APR_OPTIONAL_FN_TYPE(ap_proxy_lb_worker_size)
!                                 *pfn_proxy_lb_worker_size;
! static APR_OPTIONAL_FN_TYPE(ap_logio_get_last_bytes)
!                                 *pfn_ap_logio_get_last_bytes;
  
  struct ap_sb_handle_t {
      int child_num;
      int thread_num;
  };
  
! static int server_limit, thread_limit, lb_limit, lb_size;
  static apr_size_t scoreboard_size;
  
  /*
*************** AP_DECLARE(int) ap_calc_scoreboard_size(
*** 97,114 ****
      ap_mpm_query(AP_MPMQ_HARD_LIMIT_THREADS, &thread_limit);
      ap_mpm_query(AP_MPMQ_HARD_LIMIT_DAEMONS, &server_limit);
  
!     if (!proxy_lb_workers)
!         proxy_lb_workers = APR_RETRIEVE_OPTIONAL_FN(ap_proxy_lb_workers);
!     if (proxy_lb_workers)
!         lb_limit = proxy_lb_workers();
      else
          lb_limit = 0;
  
      scoreboard_size = sizeof(global_score);
      scoreboard_size += sizeof(process_score) * server_limit;
      scoreboard_size += sizeof(worker_score) * server_limit * thread_limit;
!     if (lb_limit)
!         scoreboard_size += sizeof(lb_score) * lb_limit;
  
      return scoreboard_size;
  }
--- 98,124 ----
      ap_mpm_query(AP_MPMQ_HARD_LIMIT_THREADS, &thread_limit);
      ap_mpm_query(AP_MPMQ_HARD_LIMIT_DAEMONS, &server_limit);
  
!     if (!pfn_proxy_lb_workers)
!         pfn_proxy_lb_workers = APR_RETRIEVE_OPTIONAL_FN(ap_proxy_lb_workers);
!     if (pfn_proxy_lb_workers)
!         lb_limit = pfn_proxy_lb_workers();
      else
          lb_limit = 0;
  
+     if (!pfn_proxy_lb_worker_size)
+         pfn_proxy_lb_worker_size = APR_RETRIEVE_OPTIONAL_FN(ap_proxy_lb_worker_size);
+     if (pfn_proxy_lb_worker_size)
+         lb_size = pfn_proxy_lb_worker_size();
+     else
+         lb_size = sizeof(lb_score);
+ 
      scoreboard_size = sizeof(global_score);
      scoreboard_size += sizeof(process_score) * server_limit;
      scoreboard_size += sizeof(worker_score) * server_limit * thread_limit;
!     if (lb_limit && lb_size)
!         scoreboard_size += lb_size * lb_limit;
! 
!     pfn_ap_logio_get_last_bytes = APR_RETRIEVE_OPTIONAL_FN(ap_logio_get_last_bytes);
  
      return scoreboard_size;
  }
*************** void ap_init_scoreboard(void *shared_sco
*** 132,140 ****
          ap_scoreboard_image->servers[i] = (worker_score *)more_storage;
          more_storage += thread_limit * sizeof(worker_score);
      }
!     if (lb_limit) {
!         ap_scoreboard_image->balancers = (lb_score *)more_storage;
!         more_storage += lb_limit * sizeof(lb_score);
      }
      ap_assert(more_storage == (char*)shared_score + scoreboard_size);
      ap_scoreboard_image->global->server_limit = server_limit;
--- 142,150 ----
          ap_scoreboard_image->servers[i] = (worker_score *)more_storage;
          more_storage += thread_limit * sizeof(worker_score);
      }
!     if (lb_limit && lb_size) {
!         ap_scoreboard_image->balancers = (void *)more_storage;
!         more_storage += lb_limit * lb_size;
      }
      ap_assert(more_storage == (char*)shared_score + scoreboard_size);
      ap_scoreboard_image->global->server_limit = server_limit;
*************** static apr_status_t open_scoreboard(apr_
*** 185,191 ****
      if (rv != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                       "Fatal error: unable to create global pool "
!                      "for use with the scoreboard");
          return rv;
      }
  
--- 195,201 ----
      if (rv != APR_SUCCESS) {
          ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                       "Fatal error: unable to create global pool "
!                      "for use by the scoreboard");
          return rv;
      }
  
*************** static apr_status_t open_scoreboard(apr_
*** 223,229 ****
      return APR_SUCCESS;
  }
  
! /* If detach is non-zero, this is a separate child process,
   * if zero, it is a forked child.
   */
  apr_status_t ap_reopen_scoreboard(apr_pool_t *p, apr_shm_t **shm, int detached)
--- 233,239 ----
      return APR_SUCCESS;
  }
  
! /* If detach is non-zero, this is a seperate child process,
   * if zero, it is a forked child.
   */
  apr_status_t ap_reopen_scoreboard(apr_pool_t *p, apr_shm_t **shm, int detached)
*************** apr_status_t ap_cleanup_scoreboard(void
*** 252,258 ****
      if (ap_scoreboard_image == NULL) {
          return APR_SUCCESS;
      }
!     if (scoreboard_type == SB_SHARED) {
          ap_cleanup_shared_mem(NULL);
      }
      else {
--- 262,268 ----
      if (ap_scoreboard_image == NULL) {
          return APR_SUCCESS;
      }
!     if (ap_scoreboard_image->global->sb_type == SB_SHARED) {
          ap_cleanup_shared_mem(NULL);
      }
      else {
*************** apr_status_t ap_cleanup_scoreboard(void
*** 268,279 ****
--- 278,291 ----
   */
  int ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
  {
+     int running_gen = 0;
      int i;
  #if APR_HAS_SHARED_MEMORY
      apr_status_t rv;
  #endif
  
      if (ap_scoreboard_image) {
+         running_gen = ap_scoreboard_image->global->running_generation;
          ap_scoreboard_image->global->restart_time = apr_time_now();
          memset(ap_scoreboard_image->parent, 0,
                 sizeof(process_score) * server_limit);
*************** int ap_create_scoreboard(apr_pool_t *p,
*** 282,290 ****
                     sizeof(worker_score) * thread_limit);
          }
          /* Clean up the lb workers data */
!         if (lb_limit) {
              memset(ap_scoreboard_image->balancers, 0,
!                    sizeof(lb_score) * lb_limit);
          }
          return OK;
      }
--- 294,302 ----
                     sizeof(worker_score) * thread_limit);
          }
          /* Clean up the lb workers data */
!         if (lb_limit && lb_size) {
              memset(ap_scoreboard_image->balancers, 0,
!                    lb_size * lb_limit);
          }
          return OK;
      }
*************** int ap_create_scoreboard(apr_pool_t *p,
*** 314,321 ****
          ap_init_scoreboard(sb_mem);
      }
  
!     ap_scoreboard_image->global->sb_type = scoreboard_type = sb_type;
!     ap_scoreboard_image->global->running_generation = 0;
      ap_scoreboard_image->global->restart_time = apr_time_now();
  
      apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
--- 326,333 ----
          ap_init_scoreboard(sb_mem);
      }
  
!     ap_scoreboard_image->global->sb_type = sb_type;
!     ap_scoreboard_image->global->running_generation = running_gen;
      ap_scoreboard_image->global->restart_time = apr_time_now();
  
      apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
*************** AP_DECLARE(int) ap_exists_scoreboard_ima
*** 342,352 ****
--- 354,374 ----
  AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)
  {
      worker_score *ws;
+     apr_off_t bytes;
  
      if (!sb)
          return;
  
      ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];
+     if (pfn_ap_logio_get_last_bytes != NULL) {
+         bytes = pfn_ap_logio_get_last_bytes(r->connection);
+     }
+     else if (r->method_number == M_GET && r->method[0] == 'H') {
+         bytes = 0;
+     }
+     else {
+         bytes = r->bytes_sent;
+     }
  
  #ifdef HAVE_TIMES
      times(&ws->times);
*************** AP_DECLARE(void) ap_increment_counts(ap_
*** 354,365 ****
      ws->access_count++;
      ws->my_access_count++;
      ws->conn_count++;
!     ws->bytes_served += r->bytes_sent;
!     ws->my_bytes_served += r->bytes_sent;
!     ws->conn_bytes += r->bytes_sent;
  }
  
! int find_child_by_pid(apr_proc_t *pid)
  {
      int i;
      int max_daemons_limit;
--- 376,387 ----
      ws->access_count++;
      ws->my_access_count++;
      ws->conn_count++;
!     ws->bytes_served += bytes;
!     ws->my_bytes_served += bytes;
!     ws->conn_bytes += bytes;
  }
  
! AP_DECLARE(int) ap_find_child_by_pid(apr_proc_t *pid)
  {
      int i;
      int max_daemons_limit;
*************** static void copy_request(char *rbuf, apr
*** 419,436 ****
      }
  }
  
! AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num,
!                                                     int thread_num,
!                                                     int status,
!                                                     request_rec *r)
  {
      int old_status;
      worker_score *ws;
      process_score *ps;
! 
!     if (child_num < 0) {
!         return -1;
!     }
  
      ws = &ap_scoreboard_image->servers[child_num][thread_num];
      old_status = ws->status;
--- 441,456 ----
      }
  }
  
! static int update_child_status_internal(int child_num,
!                                         int thread_num,
!                                         int status,
!                                         conn_rec *c,
!                                         request_rec *r)
  {
      int old_status;
      worker_score *ws;
      process_score *ps;
!     int mpm_generation;
  
      ws = &ap_scoreboard_image->servers[child_num][thread_num];
      old_status = ws->status;
*************** AP_DECLARE(int) ap_update_child_status_f
*** 441,447 ****
      if (status == SERVER_READY
          && old_status == SERVER_STARTING) {
          ws->thread_num = child_num * thread_limit + thread_num;
!         ps->generation = ap_my_generation;
      }
  
      if (ap_extended_status) {
--- 461,468 ----
      if (status == SERVER_READY
          && old_status == SERVER_STARTING) {
          ws->thread_num = child_num * thread_limit + thread_num;
!         ap_mpm_query(AP_MPMQ_GENERATION, &mpm_generation);
!         ps->generation = mpm_generation;
      }
  
      if (ap_extended_status) {
*************** AP_DECLARE(int) ap_update_child_status_f
*** 458,486 ****
              ws->conn_bytes = 0;
          }
          if (r) {
-             conn_rec *c = r->connection;
              apr_cpystrn(ws->client, ap_get_remote_host(c, r->per_dir_config,
                          REMOTE_NOLOOKUP, NULL), sizeof(ws->client));
              copy_request(ws->request, sizeof(ws->request), r);
!             apr_cpystrn(ws->vhost, r->server->server_hostname,
!                         sizeof(ws->vhost));
          }
      }
  
      return old_status;
  }
  
  AP_DECLARE(int) ap_update_child_status(ap_sb_handle_t *sbh, int status,
                                        request_rec *r)
  {
      if (!sbh)
          return -1;
  
!     return ap_update_child_status_from_indexes(sbh->child_num, sbh->thread_num,
!                                                status, r);
  }
  
! void ap_time_process_request(ap_sb_handle_t *sbh, int status)
  {
      worker_score *ws;
  
--- 479,540 ----
              ws->conn_bytes = 0;
          }
          if (r) {
              apr_cpystrn(ws->client, ap_get_remote_host(c, r->per_dir_config,
                          REMOTE_NOLOOKUP, NULL), sizeof(ws->client));
              copy_request(ws->request, sizeof(ws->request), r);
!             if (r->server) {
!             	apr_cpystrn(ws->vhost, r->server->server_hostname,
!                             sizeof(ws->vhost));
!             }
!         }
!         else if (c) {
!             apr_cpystrn(ws->client, ap_get_remote_host(c, NULL,
!                         REMOTE_NOLOOKUP, NULL), sizeof(ws->client));
!             ws->request[0]='\0';
!             ws->vhost[0]='\0';
          }
      }
  
      return old_status;
  }
  
+ AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num,
+                                                     int thread_num,
+                                                     int status,
+                                                     request_rec *r)
+ {
+     if (child_num < 0) {
+         return -1;
+     }
+ 
+     return update_child_status_internal(child_num, thread_num, status,
+                                         r ? r->connection : NULL,
+                                         r);
+ }
+ 
  AP_DECLARE(int) ap_update_child_status(ap_sb_handle_t *sbh, int status,
                                        request_rec *r)
  {
      if (!sbh)
          return -1;
  
!     return update_child_status_internal(sbh->child_num, sbh->thread_num,
!                                         status,
!                                         r ? r->connection : NULL,
!                                         r);
  }
  
! AP_DECLARE(int) ap_update_child_status_from_conn(ap_sb_handle_t *sbh, int status,
!                                        conn_rec *c)
! {
!     if (!sbh)
!         return -1;
!     
!     return update_child_status_internal(sbh->child_num, sbh->thread_num,
!                                         status, c, NULL);
! }
! 
! AP_DECLARE(void) ap_time_process_request(ap_sb_handle_t *sbh, int status)
  {
      worker_score *ws;
  
*************** void ap_time_process_request(ap_sb_handl
*** 501,518 ****
      }
  }
  
! AP_DECLARE(worker_score *) ap_get_scoreboard_worker(int x, int y)
  {
!     if (((x < 0) || (server_limit < x)) ||
!         ((y < 0) || (thread_limit < y))) {
          return(NULL); /* Out of range */
      }
      return &ap_scoreboard_image->servers[x][y];
  }
  
  AP_DECLARE(process_score *) ap_get_scoreboard_process(int x)
  {
!     if ((x < 0) || (server_limit < x)) {
          return(NULL); /* Out of range */
      }
      return &ap_scoreboard_image->parent[x];
--- 555,581 ----
      }
  }
  
! AP_DECLARE(worker_score *) ap_get_scoreboard_worker_from_indexes(int x, int y)
  {
!     if (((x < 0) || (x >= server_limit)) ||
!         ((y < 0) || (y >= thread_limit))) {
          return(NULL); /* Out of range */
      }
      return &ap_scoreboard_image->servers[x][y];
  }
  
+ AP_DECLARE(worker_score *) ap_get_scoreboard_worker(ap_sb_handle_t *sbh)
+ {
+     if (!sbh)
+         return NULL;
+ 
+     return ap_get_scoreboard_worker_from_indexes(sbh->child_num,
+                                                  sbh->thread_num);
+ }
+ 
  AP_DECLARE(process_score *) ap_get_scoreboard_process(int x)
  {
!     if ((x < 0) || (x >= server_limit)) {
          return(NULL); /* Out of range */
      }
      return &ap_scoreboard_image->parent[x];
*************** AP_DECLARE(global_score *) ap_get_scoreb
*** 525,532 ****
  
  AP_DECLARE(lb_score *) ap_get_scoreboard_lb(int lb_num)
  {
!     if (((lb_num < 0) || (lb_limit < lb_num))) {
          return(NULL); /* Out of range */
      }
!     return &ap_scoreboard_image->balancers[lb_num];
  }
--- 588,596 ----
  
  AP_DECLARE(lb_score *) ap_get_scoreboard_lb(int lb_num)
  {
!     if ( (lb_num < 0) || (lb_limit < lb_num) || (lb_size==0) ) {
          return(NULL); /* Out of range */
      }
!     return (lb_score *) ( ((char *) ap_scoreboard_image->balancers) +
!                           (lb_num*lb_size) );
  }
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/util.c /tmp/patch.inc.get2.9J0UCU/server/util.c
*** /tmp/patch.inc.get1.AvnxJA/server/util.c	2013-04-28 19:22:12.451306580 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/util.c	2013-04-28 19:22:13.567312116 +0200
***************
*** 42,49 ****
  #include <netdb.h>              /* for gethostbyname() */
  #endif
  
- #define CORE_PRIVATE
- 
  #include "ap_config.h"
  #include "apr_base64.h"
  #include "httpd.h"
--- 42,47 ----
***************
*** 82,89 ****
  #define IS_SLASH(s) (s == '/')
  #endif
  
- /* same as APR_SIZE_MAX which doesn't appear until APR 1.3 */
- #define UTIL_SIZE_MAX (~((apr_size_t)0))
  
  /*
   * Examine a field value (such as a media-/content-type) string and return
--- 80,85 ----
*************** AP_DECLARE(char *) ap_pregsub(apr_pool_t
*** 368,374 ****
      char *dest, *dst;
      char c;
      size_t no;
!     apr_size_t len;
  
      if (!source)
          return NULL;
--- 364,370 ----
      char *dest, *dst;
      char c;
      size_t no;
!     int len;
  
      if (!source)
          return NULL;
*************** AP_DECLARE(char *) ap_pregsub(apr_pool_t
*** 389,403 ****
  
          if (no > 9) {                /* Ordinary character. */
              if (c == '\\' && (*src == '$' || *src == '&'))
!                 src++;
              len++;
          }
          else if (no < nmatch && pmatch[no].rm_so < pmatch[no].rm_eo) {
-             if (UTIL_SIZE_MAX - len <= pmatch[no].rm_eo - pmatch[no].rm_so) {
-                 ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
-                              "integer overflow or out of memory condition." );
-                 return NULL;
-             }
              len += pmatch[no].rm_eo - pmatch[no].rm_so;
          }
  
--- 385,394 ----
  
          if (no > 9) {                /* Ordinary character. */
              if (c == '\\' && (*src == '$' || *src == '&'))
!                 c = *src++;
              len++;
          }
          else if (no < nmatch && pmatch[no].rm_so < pmatch[no].rm_eo) {
              len += pmatch[no].rm_eo - pmatch[no].rm_so;
          }
  
*************** AP_DECLARE(char *) ap_make_dirstr_parent
*** 587,595 ****
          return apr_pstrdup(p, "");
      }
      l = (last_slash - s) + 1;
!     d = apr_palloc(p, l + 1);
!     memcpy(d, s, l);
!     d[l] = 0;
      return (d);
  }
  
--- 578,585 ----
          return apr_pstrdup(p, "");
      }
      l = (last_slash - s) + 1;
!     d = apr_pstrmemdup(p, s, l);
! 
      return (d);
  }
  
*************** AP_DECLARE(char *) ap_getword(apr_pool_t
*** 620,628 ****
      }
  
      len = pos - *line;
!     res = (char *)apr_palloc(atrans, len + 1);
!     memcpy(res, *line, len);
!     res[len] = 0;
  
      if (stop) {
          while (*pos == stop) {
--- 610,616 ----
      }
  
      len = pos - *line;
!     res = apr_pstrmemdup(atrans, *line, len);
  
      if (stop) {
          while (*pos == stop) {
*************** AP_DECLARE(char *) ap_getword_white(apr_
*** 650,658 ****
      }
  
      len = pos - *line;
!     res = (char *)apr_palloc(atrans, len + 1);
!     memcpy(res, *line, len);
!     res[len] = 0;
  
      while (apr_isspace(*pos)) {
          ++pos;
--- 638,644 ----
      }
  
      len = pos - *line;
!     res = apr_pstrmemdup(atrans, *line, len);
  
      while (apr_isspace(*pos)) {
          ++pos;
*************** static char x2c(const char *what)
*** 1549,1602 ****
  }
  
  /*
!  * Unescapes a URL.
   * Returns 0 on success, non-zero on error
   * Failure is due to
   *   bad % escape       returns HTTP_BAD_REQUEST
   *
!  *   decoding %00 -> \0  (the null character)
!  *   decoding %2f -> /   (a special character)
!  *                      returns HTTP_NOT_FOUND
   */
- AP_DECLARE(int) ap_unescape_url(char *url)
- {
-     register int badesc, badpath;
-     char *x, *y;
  
!     badesc = 0;
!     badpath = 0;
!     /* Initial scan for first '%'. Don't bother writing values before
!      * seeing a '%' */
!     y = strchr(url, '%');
!     if (y == NULL) {
!         return OK;
!     }
!     for (x = y; *y; ++x, ++y) {
!         if (*y != '%')
!             *x = *y;
!         else {
!             if (!apr_isxdigit(*(y + 1)) || !apr_isxdigit(*(y + 2))) {
!                 badesc = 1;
!                 *x = '%';
!             }
!             else {
!                 *x = x2c(y + 1);
!                 y += 2;
!                 if (IS_SLASH(*x) || *x == '\0')
!                     badpath = 1;
!             }
!         }
!     }
!     *x = '\0';
!     if (badesc)
!         return HTTP_BAD_REQUEST;
!     else if (badpath)
!         return HTTP_NOT_FOUND;
!     else
!         return OK;
! }
! 
! AP_DECLARE(int) ap_unescape_url_keep2f_ex(char *url, int decode_2f)
  {
      register int badesc, badpath;
      char *x, *y;
--- 1535,1549 ----
  }
  
  /*
!  * Unescapes a URL, leaving reserved characters intact.
   * Returns 0 on success, non-zero on error
   * Failure is due to
   *   bad % escape       returns HTTP_BAD_REQUEST
   *
!  *   decoding %00 or a forbidden character returns HTTP_NOT_FOUND
   */
  
! static int unescape_url(char *url, const char *forbid, const char *reserved)
  {
      register int badesc, badpath;
      char *x, *y;
*************** AP_DECLARE(int) ap_unescape_url_keep2f_e
*** 1621,1631 ****
              else {
                  char decoded;
                  decoded = x2c(y + 1);
!                 if (decoded == '\0') {
                      badpath = 1;
                  }
!                 else if (IS_SLASH(decoded) && !decode_2f) {
!                     /* do not decode, just let it go by as-is */
                      *x = *y;
                  }
                  else {
--- 1568,1582 ----
              else {
                  char decoded;
                  decoded = x2c(y + 1);
!                 if ((decoded == '\0')
!                     || (forbid && ap_strchr_c(forbid, decoded))) {
                      badpath = 1;
+                     *x = decoded;
+                     y += 2;
                  }
!                 else if (reserved && ap_strchr_c(reserved, decoded)) {
!                     *x++ = *y++;
!                     *x++ = *y++;
                      *x = *y;
                  }
                  else {
*************** AP_DECLARE(int) ap_unescape_url_keep2f_e
*** 1646,1656 ****
          return OK;
      }
  }
! 
  AP_DECLARE(int) ap_unescape_url_keep2f(char *url)
  {
!     return ap_unescape_url_keep2f_ex(url, 1);
  }
  
  AP_DECLARE(char *) ap_construct_server(apr_pool_t *p, const char *hostname,
                                         apr_port_t port, const request_rec *r)
--- 1597,1632 ----
          return OK;
      }
  }
! AP_DECLARE(int) ap_unescape_url(char *url)
! {
!     /* Traditional */
! #ifdef CASE_BLIND_FILESYSTEM
!     return unescape_url(url, "/\\", NULL);
! #else
!     return unescape_url(url, "/", NULL);
! #endif
! }
  AP_DECLARE(int) ap_unescape_url_keep2f(char *url)
  {
!     /* AllowEncodedSlashes (corrected) */
!     return unescape_url(url, NULL, "/");
! }
! #ifdef NEW_APIS
! /* IFDEF these out until they've been thought through.
!  * Just a germ of an API extension for now
!  */
! AP_DECLARE(int) ap_unescape_url_proxy(char *url)
! {
!     /* leave RFC1738 reserved characters intact, * so proxied URLs
!      * don't get mangled.  Where does that leave encoded '&' ?
!      */
!     return unescape_url(url, NULL, "/;?");
! }
! AP_DECLARE(int) ap_unescape_url_reserved(char *url, const char *reserved)
! {
!     return unescape_url(url, NULL, reserved);
  }
+ #endif
  
  AP_DECLARE(char *) ap_construct_server(apr_pool_t *p, const char *hostname,
                                         apr_port_t port, const request_rec *r)
*************** AP_DECLARE(char *) ap_construct_server(a
*** 1663,1668 ****
--- 1639,1649 ----
      }
  }
  
+ AP_DECLARE(int) ap_unescape_all(char *url)
+ {
+     return unescape_url(url, NULL, NULL);
+ }
+ 
  /* c2x takes an unsigned, and expects the caller has guaranteed that
   * 0 <= what < 256... which usually means that you have to cast to
   * unsigned char first, because (unsigned)(char)(x) first goes through
*************** static APR_INLINE unsigned char *c2x(uns
*** 1702,1710 ****
   * something with a '/' in it (and thus does not prefix "./").
   */
  
! AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
  {
-     char *copy = apr_palloc(p, 3 * strlen(segment) + 1);
      const unsigned char *s = (const unsigned char *)segment;
      unsigned char *d = (unsigned char *)copy;
      unsigned c;
--- 1683,1690 ----
   * something with a '/' in it (and thus does not prefix "./").
   */
  
! AP_DECLARE(char *) ap_escape_path_segment_buffer(char *copy, const char *segment)
  {
      const unsigned char *s = (const unsigned char *)segment;
      unsigned char *d = (unsigned char *)copy;
      unsigned c;
*************** AP_DECLARE(char *) ap_escape_path_segmen
*** 1722,1727 ****
--- 1702,1712 ----
      return copy;
  }
  
+ AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
+ {
+     return ap_escape_path_segment_buffer(apr_palloc(p, 3 * strlen(segment) + 1), segment);
+ }
+ 
  AP_DECLARE(char *) ap_os_escape_path(apr_pool_t *p, const char *path, int partial)
  {
      char *copy = apr_palloc(p, 3 * strlen(path) + 3);
*************** AP_DECLARE(char *) ap_escape_html2(apr_p
*** 1801,1810 ****
      x[j] = '\0';
      return x;
  }
- AP_DECLARE(char *) ap_escape_html(apr_pool_t *p, const char *s)
- {
-     return ap_escape_html2(p, s, 0);
- }
  AP_DECLARE(char *) ap_escape_logitem(apr_pool_t *p, const char *str)
  {
      char *ret;
--- 1786,1791 ----
*************** AP_DECLARE(apr_status_t) ap_timeout_para
*** 2222,2228 ****
          break;
      case 'm':
          switch (*(++time_str)) {
!         /* Time is in miliseconds */
          case 's':
              *timeout = (apr_interval_time_t) tout * 1000;
              break;
--- 2203,2209 ----
          break;
      case 'm':
          switch (*(++time_str)) {
!         /* Time is in milliseconds */
          case 's':
              *timeout = (apr_interval_time_t) tout * 1000;
              break;
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/util_cfgtree.c /tmp/patch.inc.get2.9J0UCU/server/util_cfgtree.c
*** /tmp/patch.inc.get1.AvnxJA/server/util_cfgtree.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/util_cfgtree.c	2013-04-28 19:22:13.551312047 +0200
***************
*** 14,20 ****
   * limitations under the License.
   */
  
- #define CORE_PRIVATE
  #include "util_cfgtree.h"
  #include <stdlib.h>
  
--- 14,19 ----
Only in /tmp/patch.inc.get2.9J0UCU/server: util_cookies.c
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/util_debug.c /tmp/patch.inc.get2.9J0UCU/server/util_debug.c
*** /tmp/patch.inc.get1.AvnxJA/server/util_debug.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/util_debug.c	2013-04-28 19:22:13.551312047 +0200
*************** AP_DECLARE(void *) ap_get_module_config(
*** 113,119 ****
   *        usually r->per_dir_config or s->module_config
   * @param m The module to set the data for.
   * @param val The module-specific data to set
!  * @deffunc void ap_set_module_config(ap_conf_vector_t *cv, const module *m, void *val)
   */
  #if defined(ap_set_module_config)
  #undef ap_set_module_config
--- 113,119 ----
   *        usually r->per_dir_config or s->module_config
   * @param m The module to set the data for.
   * @param val The module-specific data to set
!  * @fn void ap_set_module_config(ap_conf_vector_t *cv, const module *m, void *val)
   */
  #if defined(ap_set_module_config)
  #undef ap_set_module_config
Only in /tmp/patch.inc.get2.9J0UCU/server: util_expr.c
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/util_filter.c /tmp/patch.inc.get2.9J0UCU/server/util_filter.c
*** /tmp/patch.inc.get1.AvnxJA/server/util_filter.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/util_filter.c	2013-04-28 19:22:13.551312047 +0200
*************** AP_DECLARE(ap_filter_rec_t *) ap_registe
*** 248,262 ****
                             &registered_input_filters);
  }
  
- /* Prepare to make this a #define in 2.2 */
  AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter(const char *name,
                                             ap_out_filter_func filter_func,
                                             ap_init_filter_func filter_init,
                                             ap_filter_type ftype)
  {
      return ap_register_output_filter_protocol(name, filter_func,
!                                               filter_init, ftype, 0) ;
  }
  AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter_protocol(
                                             const char *name,
                                             ap_out_filter_func filter_func,
--- 248,262 ----
                             &registered_input_filters);
  }
  
  AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter(const char *name,
                                             ap_out_filter_func filter_func,
                                             ap_init_filter_func filter_init,
                                             ap_filter_type ftype)
  {
      return ap_register_output_filter_protocol(name, filter_func,
!                                               filter_init, ftype, 0);
  }
+ 
  AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter_protocol(
                                             const char *name,
                                             ap_out_filter_func filter_func,
*************** static ap_filter_t *add_any_filter_handl
*** 279,285 ****
                                            ap_filter_t **p_filters,
                                            ap_filter_t **c_filters)
  {
!     apr_pool_t* p = r ? r->pool : c->pool;
      ap_filter_t *f = apr_palloc(p, sizeof(*f));
      ap_filter_t **outf;
  
--- 279,285 ----
                                            ap_filter_t **p_filters,
                                            ap_filter_t **c_filters)
  {
!     apr_pool_t *p = frec->ftype < AP_FTYPE_CONNECTION && r ? r->pool : c->pool;
      ap_filter_t *f = apr_palloc(p, sizeof(*f));
      ap_filter_t **outf;
  
*************** static ap_filter_t *add_any_filter_handl
*** 309,315 ****
  
      f->frec = frec;
      f->ctx = ctx;
!     f->r = r;
      f->c = c;
      f->next = NULL;
  
--- 309,316 ----
  
      f->frec = frec;
      f->ctx = ctx;
!     /* f->r must always be NULL for connection filters */
!     f->r = frec->ftype < AP_FTYPE_CONNECTION ? r : NULL;
      f->c = c;
      f->next = NULL;
  
Only in /tmp/patch.inc.get2.9J0UCU/server: util_mutex.c
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/util_pcre.c /tmp/patch.inc.get2.9J0UCU/server/util_pcre.c
*** /tmp/patch.inc.get1.AvnxJA/server/util_pcre.c	2013-04-28 19:22:12.451306580 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/util_pcre.c	2013-04-28 19:22:13.567312116 +0200
*************** AP_DECLARE(int) ap_regcomp(ap_regex_t *p
*** 128,134 ****
  const char *errorptr;
  int erroffset;
  int options = 0;
- int nsub;
  
  if ((cflags & AP_REG_ICASE) != 0) options |= PCRE_CASELESS;
  if ((cflags & AP_REG_NEWLINE) != 0) options |= PCRE_MULTILINE;
--- 128,133 ----
*************** preg->re_erroffset = erroffset;
*** 138,146 ****
  
  if (preg->re_pcre == NULL) return AP_REG_INVARG;
  
! pcre_fullinfo((const pcre *)preg->re_pcre, NULL,
!               PCRE_INFO_CAPTURECOUNT, &nsub);
! preg->re_nsub = (apr_size_t)nsub;
  return 0;
  }
  
--- 137,143 ----
  
  if (preg->re_pcre == NULL) return AP_REG_INVARG;
  
! preg->re_nsub = pcre_info((const pcre *)preg->re_pcre, NULL, NULL);
  return 0;
  }
  
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/util_script.c /tmp/patch.inc.get2.9J0UCU/server/util_script.c
*** /tmp/patch.inc.get1.AvnxJA/server/util_script.c	2013-04-28 19:22:12.443306550 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/util_script.c	2013-04-28 19:22:13.559312070 +0200
***************
*** 25,31 ****
  #include <stdlib.h>
  #endif
  
- #define CORE_PRIVATE
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_config.h"
--- 25,30 ----
*************** AP_DECLARE(void) ap_add_common_vars(requ
*** 123,129 ****
      conn_rec *c = r->connection;
      const char *rem_logname;
      char *env_path;
! #if defined(WIN32) || defined(OS2) || defined(BEOS)
      char *env_temp;
  #endif
      const char *host;
--- 122,128 ----
      conn_rec *c = r->connection;
      const char *rem_logname;
      char *env_path;
! #if defined(WIN32) || defined(OS2)
      char *env_temp;
  #endif
      const char *host;
*************** AP_DECLARE(void) ap_add_common_vars(requ
*** 187,202 ****
      apr_table_addn(e, "PATH", apr_pstrdup(r->pool, env_path));
  
  #ifdef WIN32
!     if ((env_temp = getenv("SystemRoot")) != NULL) {
          apr_table_addn(e, "SystemRoot", env_temp);
      }
!     if ((env_temp = getenv("COMSPEC")) != NULL) {
          apr_table_addn(e, "COMSPEC", env_temp);
      }
!     if ((env_temp = getenv("PATHEXT")) != NULL) {
          apr_table_addn(e, "PATHEXT", env_temp);
      }
!     if ((env_temp = getenv("WINDIR")) != NULL) {
          apr_table_addn(e, "WINDIR", env_temp);
      }
  #endif
--- 186,201 ----
      apr_table_addn(e, "PATH", apr_pstrdup(r->pool, env_path));
  
  #ifdef WIN32
!     if (env_temp = getenv("SystemRoot")) {
          apr_table_addn(e, "SystemRoot", env_temp);
      }
!     if (env_temp = getenv("COMSPEC")) {
          apr_table_addn(e, "COMSPEC", env_temp);
      }
!     if (env_temp = getenv("PATHEXT")) {
          apr_table_addn(e, "PATHEXT", env_temp);
      }
!     if (env_temp = getenv("WINDIR")) {
          apr_table_addn(e, "WINDIR", env_temp);
      }
  #endif
*************** AP_DECLARE(void) ap_add_common_vars(requ
*** 216,227 ****
      }
  #endif
  
- #ifdef BEOS
-     if ((env_temp = getenv("LIBRARY_PATH")) != NULL) {
-         apr_table_addn(e, "LIBRARY_PATH", env_temp);
-     }
- #endif
- 
      apr_table_addn(e, "SERVER_SIGNATURE", ap_psignature("", r));
      apr_table_addn(e, "SERVER_SOFTWARE", ap_get_server_banner());
      apr_table_addn(e, "SERVER_NAME",
--- 215,220 ----
*************** AP_DECLARE(int) ap_scan_script_header_er
*** 475,491 ****
          if (w[0] == '\0') {
              int cond_status = OK;
  
!            /* PR#38070: This fails because it gets confused when a
!             * CGI Status header overrides ap_meets_conditions.
!             * 
!             * We can fix that by dropping ap_meets_conditions when
!             * Status has been set.  Since this is the only place
!             * cgi_status gets used, let's test it explicitly.
!             *
!             * The alternative would be to ignore CGI Status when
!             * ap_meets_conditions returns anything interesting.
!             * That would be safer wrt HTTP, but would break CGI.
!             */
              if ((cgi_status == HTTP_UNSET) && (r->method_number == M_GET)) {
                  cond_status = ap_meets_conditions(r);
              }
--- 468,484 ----
          if (w[0] == '\0') {
              int cond_status = OK;
  
!             /* PR#38070: This fails because it gets confused when a
!              * CGI Status header overrides ap_meets_conditions.
!              * 
!              * We can fix that by dropping ap_meets_conditions when
!              * Status has been set.  Since this is the only place
!              * cgi_status gets used, let's test it explicitly.
!              *
!              * The alternative would be to ignore CGI Status when
!              * ap_meets_conditions returns anything interesting.
!              * That would be safer wrt HTTP, but would break CGI.
!              */
              if ((cgi_status == HTTP_UNSET) && (r->method_number == M_GET)) {
                  cond_status = ap_meets_conditions(r);
              }
*************** AP_DECLARE(int) ap_scan_script_header_er
*** 537,543 ****
  
              if (!buffer) {
                  /* Soak up all the script output - may save an outright kill */
!                 while ((*getsfunc)(w, MAX_STRING_LEN - 1, getsfunc_data) > 0) {
                      continue;
                  }
              }
--- 530,536 ----
  
              if (!buffer) {
                  /* Soak up all the script output - may save an outright kill */
!                 while ((*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data)) {
                      continue;
                  }
              }
*************** AP_DECLARE(int) ap_scan_script_header_er
*** 587,592 ****
--- 580,588 ----
          else if (!strcasecmp(w, "Transfer-Encoding")) {
              apr_table_set(r->headers_out, w, l);
          }
+         else if (!strcasecmp(w, "ETag")) {
+             apr_table_set(r->headers_out, w, l);
+         }
          /*
           * If the script gave us a Last-Modified header, we can't just
           * pass it on blindly because of restrictions on future values.
*************** AP_DECLARE(int) ap_scan_script_header_er
*** 602,608 ****
              apr_table_add(merge, w, l);
          }
      }
! 
      return OK;
  }
  
--- 598,604 ----
              apr_table_add(merge, w, l);
          }
      }
!     /* never reached - we leave this function within the while loop above */
      return OK;
  }
  
*************** static int getsfunc_BRIGADE(char *buf, i
*** 626,633 ****
      apr_status_t rv;
      int done = 0;
  
!     while ((dst < dst_end) && !done && e != APR_BRIGADE_SENTINEL(bb)
!            && !APR_BUCKET_IS_EOS(e)) {
          const char *bucket_data;
          apr_size_t bucket_data_len;
          const char *src;
--- 622,628 ----
      apr_status_t rv;
      int done = 0;
  
!     while ((dst < dst_end) && !done && !APR_BUCKET_IS_EOS(e)) {
          const char *bucket_data;
          apr_size_t bucket_data_len;
          const char *src;
*************** static int getsfunc_BRIGADE(char *buf, i
*** 637,643 ****
          rv = apr_bucket_read(e, &bucket_data, &bucket_data_len,
                               APR_BLOCK_READ);
          if (rv != APR_SUCCESS || (bucket_data_len == 0)) {
-             *dst = '\0';
              return APR_STATUS_IS_TIMEUP(rv) ? -1 : 0;
          }
          src = bucket_data;
--- 632,637 ----
*************** static int getsfunc_BRIGADE(char *buf, i
*** 661,667 ****
          e = next;
      }
      *dst = 0;
!     return done;
  }
  
  AP_DECLARE(int) ap_scan_script_header_err_brigade(request_rec *r,
--- 655,661 ----
          e = next;
      }
      *dst = 0;
!     return 1;
  }
  
  AP_DECLARE(int) ap_scan_script_header_err_brigade(request_rec *r,
*************** static int getsfunc_STRING(char *w, int
*** 683,692 ****
      const char *p;
      int t;
  
!     if (!strs->curpos || !*strs->curpos) {
!         w[0] = '\0';
          return 0;
-     }
      p = ap_strchr_c(strs->curpos, '\n');
      if (p)
          ++p;
--- 677,684 ----
      const char *p;
      int t;
  
!     if (!strs->curpos || !*strs->curpos)
          return 0;
      p = ap_strchr_c(strs->curpos, '\n');
      if (p)
          ++p;
*************** AP_DECLARE_NONSTD(int) ap_scan_script_he
*** 730,732 ****
--- 722,838 ----
      va_end(strs.args);
      return res;
  }
+ 
+ 
+ static void
+ argstr_to_table(char *str, apr_table_t *parms)
+ {
+     char *key;
+     char *value;
+     char *strtok_state;
+ 
+     if (str == NULL) {
+         return;
+     }
+     
+     key = apr_strtok(str, "&", &strtok_state);
+     while (key) {
+         value = strchr(key, '=');
+         if (value) {
+             *value = '\0';      /* Split the string in two */
+             value++;            /* Skip passed the = */
+         }
+         else {
+             value = "1";
+         }
+         ap_unescape_url(key);
+         ap_unescape_url(value);
+         apr_table_set(parms, key, value);
+         key = apr_strtok(NULL, "&", &strtok_state);
+     }
+ }
+ 
+ AP_DECLARE(void) ap_args_to_table(request_rec *r, apr_table_t **table)
+ {
+     apr_table_t *t = apr_table_make(r->pool, 10);
+     argstr_to_table(apr_pstrdup(r->pool, r->args), t);
+     *table = t;
+ }
+ 
+ AP_DECLARE(apr_status_t) ap_body_to_table(request_rec *r, apr_table_t **table)
+ {
+     apr_bucket_brigade *bb;
+     apr_bucket_brigade *tmpbb;
+     apr_status_t rv = APR_SUCCESS;
+ 
+     if (r->body_table) {
+         *table = r->body_table;
+         return APR_SUCCESS;
+     }
+     
+     *table = NULL;
+ 
+     bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
+     tmpbb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
+ 
+     do {
+         apr_off_t len;
+ 
+         rv = ap_get_brigade(r->input_filters, tmpbb, AP_MODE_READBYTES,
+                             APR_BLOCK_READ, AP_IOBUFSIZE);
+         if (rv) {
+             break;
+         }
+ 
+         rv = apr_brigade_length(tmpbb, 1, &len);
+         if (rv) {
+             break;
+         }
+         
+         if (len == 0) {
+             break;
+         }
+ 
+         APR_BRIGADE_CONCAT(bb, tmpbb);
+     } while(1);
+ 
+     if (!rv) {
+         r->body_table = apr_table_make(r->pool, 10);
+         
+         if (!APR_BRIGADE_EMPTY(bb)) {
+             char *buffer;
+             apr_off_t len;
+             apr_pool_t *tpool;
+ 
+             apr_pool_create(&tpool, r->pool);
+             
+             rv = apr_brigade_length(bb, 1, &len);
+ 
+             if (!rv) {
+                 apr_size_t total;
+                 /* XXX where's our test that len fits in memory??? 
+                  * theoretically can be a large file > ram space
+                  */
+                 buffer = apr_palloc(tpool, len+1);
+                 
+                 total = len+1;
+ 
+                 rv = apr_brigade_flatten(bb, buffer, &total);
+ 
+                 buffer[total] = '\0';
+ 
+                 argstr_to_table(buffer, r->body_table);
+             }
+             apr_pool_destroy(tpool);
+         }
+     }
+ 
+     apr_brigade_destroy(bb);
+     apr_brigade_destroy(tmpbb);
+ 
+     *table = r->body_table;
+ 
+     return rv;
+ }
+ 
+ 
diff -p --text -r /tmp/patch.inc.get1.AvnxJA/server/vhost.c /tmp/patch.inc.get2.9J0UCU/server/vhost.c
*** /tmp/patch.inc.get1.AvnxJA/server/vhost.c	2013-04-28 19:22:12.435306500 +0200
--- /tmp/patch.inc.get2.9J0UCU/server/vhost.c	2013-04-28 19:22:13.551312047 +0200
***************
*** 27,33 ****
  #define APR_WANT_STRFUNC
  #include "apr_want.h"
  
- #define CORE_PRIVATE
  #include "ap_config.h"
  #include "httpd.h"
  #include "http_config.h"
--- 27,32 ----
*************** const char *ap_parse_vhost_addrs(apr_poo
*** 250,257 ****
  }
  
  
! const char *ap_set_name_virtual_host(cmd_parms *cmd, void *dummy,
!                                      const char *arg)
  {
      /* use whatever port the main server has at this point */
      return get_addresses(cmd->pool, arg, &name_vhost_list_tail,
--- 249,257 ----
  }
  
  
! AP_DECLARE_NONSTD(const char *)ap_set_name_virtual_host(cmd_parms *cmd,
!                                                         void *dummy,
!                                                         const char *arg)
  {
      /* use whatever port the main server has at this point */
      return get_addresses(cmd->pool, arg, &name_vhost_list_tail,
Only in /tmp/patch.inc.get1.AvnxJA/srclib: apr
Only in /tmp/patch.inc.get1.AvnxJA/srclib: apr-util
Only in /tmp/patch.inc.get1.AvnxJA/srclib: pcre
